<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-03-28 16:09:04
 -->
# 简介
JS中的任务分为同步和异步任务，其中异步任务又分为宏任务和微任务，简单复习下宏任务和微任务，在事件循环机制中总是以这样的顺序来执行任务：同步任务->微任务(微任务队列全部执行完毕)->宏任务(宏任务队列中拿出队首执行)->微任务。

常见的宏任务:
- setTimeout\setInterval
- setImmediate(Nodejs)
- IO操作(例如ajax，文件操作等)
- MessageChannel(通过接口提供的Port1和Port2来互相传递消息)
- requestAnimationFrame(浏览器独有)
- UI rendering(浏览器独有，渲染相关)

常见的微任务：
- process.nextTick(node独有)
- promise
- MutationObserver
- object.observe

也就是说，在使用到上述的相关任务时，都是异步的，当这些异步任务有返回结果的时候，我们该如何去处理？这就是异步编程应该思考的问题

## 回调函数
最常见的处理异步任务返回结果的方式，就是回调函数。  
回调函数的处理方式是，向异步任务传递一个回调函数，当这个异步任务有返回结果的时候，调用回调函数，并传入结果。

例如我们在执行ajax的时候:
```javascript
function Ajax(callback){
    //超时事件ms
    xhr.timeout = 3000
    //返回的数据格式
    xhr.responseType = "text"
    //创建一个post请求，采用异步
    xhr.open('POST', '/server', true)
    //注册相关事件回调
    //传输完成
    xhr.onload = function (e) {
        //this指向xhr
        if (this.status == 200 || this.status == 304) {
            callback(this.responseText)
        }
    }
}

Ajax(function callback(resp){
    console.log("我收到了异步的返回结果:",resp);
});
```
即传入回调函数，异步任务有返回结果时，执行回调。

这种处理方式最大的弊端就是会造成回调嵌套，也称作回调地狱(callback hell).
```javascript
Ajax(function callback(resp){
    //第二个异步任务，依赖第一个异步任务的返回结果
    Ajax(function callback2(res2){
        Ajax(function callback3(res3){
            ...
        })
    })
})
```

## 事件监听(发布/订阅者模式)
本质上也是利用回调，但多了一个发布、订阅的逻辑关系。  
事件监听的处理方式：对某一事件的监听，当事件被触发时，调用事件监听的回调。  
- 对某一事件的监听，可以理解为将回调函数收集到事件的订阅者中心中。  
- 事件的触发，会调用回调，可以理解为发布当前事件，依次调用订阅者中心的回调。

事件的使用例子：  
1. DOM的事件监听
```javascript
<div id="documenta"></div>

var element = document.querySelector("#documenta");
element.addEventListener("click",function(){

})

```
2. 自定义Event事件

```javascript
<div id="documenta"></div>

var element = document.querySelector("#documenta");
var event = new Event("test");
element.addEventListener("test",function(){

});
element.dispatchEvent(event);

var event2 =  new CustomEvent(eventname, options);
/*
其中 options 可以是：
{
  detail: {
    ...
  },
  bubbles: true,    //是否冒泡
  cancelable: false //是否取消默认事件
}*/
element.addEventListner("test2",function(event){

});
element.dispatchEvent(event2);

```
3. nodeJS中的EventEmitter
```javascript
var events = required("events");
var EventEmitter = new events.EventEmitter();

EventEmitter.addEventListener("myEvent",function listener(){

});

//触发
EventEmitter.emit("myEvent")

```

### 事件监听的本质实现
事件监听的本质就是发布订阅者模式

```javascript
function EventEmitter(){
    //订阅者中心
    this.deps = Object.create(null);
}
EventEmitter.prototype.removeListener = function(event,listener){
    if(!this.dep[event]){
        return;
    }
    if(listener){
        //删除事件的其中一个订阅
        var index = this.dep[event].findIndex((item)=>item===listener);
        if(index===-1){
            return;
        }
        this.dep[event].splice(index,1);
    }else{
        //删除事件的所有订阅
        this.dep[event] && delete this.dep[event];
    }
}
EventEmitter.prototype.addEventListener = function(event,listener){
    if(!this.dep[event]){
        this.dep[event] = [];
    }
     this.dep[event].push(listener);
}
EventEmitter.prototype.dispatchEvent = function(event){
    var args = Array.protoype.slice.call(arguments,1);
    if(this.dep[event]){
        this.dep[event].forEach((fn)=>{
            fn.apply(this,args);
        })
    }
}

```

## Promise
Promise解决了回调函数的嵌套回调问题，Promise是一套规范，不同的库根据规范有不同的实现。

了解Promise,从它的使用特性开始：  
1. 立即执行
```javascript
//传入的函数是同步执行的
new Promise((resolve,reject)=>{
    console.log('promise');
});

console.log('hello');
//先输出promise再输出hello
```
2. Promise维护三种状态：pending,resolved,rejected
```javascript
//Promise{[[PromiseStatus]]:"resolved",[[PromiseValue]]:1};
var p1 = new Promise((resolve,reject)=>{
    resolve(1);
});
//在setTimeout被执行前都是{[[PromiseStatus]]:"pending",[[PromiseValue]]:undefined}
var p2 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve();
    },10000);
});
//{[[PromiseStatus]]:"rejected",[[PromiseValue]]:1}
var p3 = new Promise((resolve,reject)=>{
    reject(1);
});
```
3. 状态不可逆
```javascript
//一旦状态被更改，不可逆
var p1 = new Promise(function(resolve, reject){
  resolve("success1");
  resolve("success2");
});
//success1
p1.then((value)=>{
    console.log(value);
});
```
4. 链式调用
```javascript
var p = new Promise(function(resolve, reject){
  resolve(1);
});
p.then(function(value){               
  console.log(value);
  return value*2;
}).then(function(value){              
  console.log(value);
}).then(function(value){              
  console.log(value);
  return Promise.resolve('resolve'); 
}).then(function(value){              
  console.log(value);
  return new Promise(function(resolve,reject){
      resolve(value);
  });
}).then(function(){
  console.log(value);
  return Promise.reject('reject');
}).then(function(value){              
  console.log('resolve: '+ value);
}, function(err){
  console.log('reject: ' + err);
});

/*
1
2
undefined
resolve
resolve
reject: reject
*/

```
由上面的代码可知：
then方法返回一个新的Promise对象，所以可以继续通过链式调用then方法。  
then方法接受两个函数作为参数，第一个参数是Promise执行resolve时的回调，第二个参数是Promise执行reject时的回调。  
then方法中函数的返回值将决定then返回的Promise对象状态。  
- return一个同步值，或者没有return值（相当于return undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。
- return一个Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。
- throw一个同步异常，then方法将返回一个rejected状态的Promise,值是该异常。

5. Promise.resolve()
Promise.resolve(value)方法返回一个以给定值解析后的Promise对象。
- 如果这个值是一个promise ，那么将返回这个promise 
- 如果这个值是thenable（即带有"then" 方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态
- 其余值返回一个resolved状态的Promise对象，对象的值就是这个参数。

```javascript
//Promise{[[PromiseStatus]]:"resolved",[[PromiseValue]]:1}
var p1 = Promise.resolve(1);
var p2 = Promise.resolve(p1);
//true
console.log(p2===p1);
```
6. resolve和reject
```javascript
var p1 = new Promise(function(resolve, reject){
  resolve(Promise.resolve('resolve'));
});

var p2 = new Promise(function(resolve, reject){
  resolve(Promise.reject('reject'));
});

var p3 = new Promise(function(resolve, reject){
  reject(Promise.resolve('resolve'));
});

p1.then(
  function fulfilled(value){
    console.log('fulfilled: ' + value);
  }, 
  function rejected(err){
    console.log('rejected: ' + err);
  }
);

p2.then(
  function fulfilled(value){
    console.log('fulfilled: ' + value);
  }, 
  function rejected(err){
    console.log('rejected: ' + err);
  }
);

p3.then(
  function fulfilled(value){
    console.log('fulfilled: ' + value);
  }, 
  function rejected(err){
    console.log('rejected: ' + err);
  }
);
//输出
p3 rejected: [object Promise]
p1 fulfilled: resolve
p2 rejected: reject
```
Promise回调函数中的第一个参数resolve，会对Promise执行"拆箱"动作。即当resolve的参数是一个Promise对象时，resolve会"拆箱"获取这个Promise对象的状态和值，但这个过程是异步的。p1"拆箱"后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2"拆箱"后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。


### Promise的实现
1. Promise接受一个函数，并且函数立即执行
```javascript
const isFunction = function(handle){
    return typeof handle === 'function'
}
//es5
function Promise(handle){
    //传入的必须是函数
    if(!isFunction(handle)){
        throw new Error("");
    }
    handle();
}
//es6
class Promise{
    constructor(handle){
        if(!isFunction(handle)){
            throw new Error("");
        }
    }
    handle();
}
```
2. Promise具有三个状态:resolved,rejected,pending,状态只能由pending->resolved或者pending->rejected,并且修改状态后，不会发生变化。  
- 状态是由resolve或者reject函数改变的。
- Promise的值是传入resolve和reject函数的值。

所以Promise应该有一个状态属性，一个值属性，并且需要向handle传入resolve和reject函数

```javascript
//定义状态常量
const PENDING = "pending";
const FULFILLED = "resolved";
const REJECTED = "rejected";

//es5实现
function Promise(handle){
    if(!isFunction(handle)){
        throw new Error();
    }
    this.status = PENDING;
    this.value = void 0;
    //这里有两点要注意，第一点是函数执行时出现错误，catch到的错误应该用reject处理
    try{
        //第二点，因为this是动态作用域，resolve和reject中的this应该指向当前Promise实例，所以这里用bind绑定了this为Promise实例
        handle(this.resolve.bind(this),this.reject.bind(this));
    }catch(err){
        this.reject.call(err);
    }
}

Promise.prototype.resolve = function(result){
    if(this.status !== PENDING){
        return;
    }
    this.status = FULFILLED;
    this.value = result;
}
Promise.prototype.reject = function(result){
    if(this.status !== PENDING){
        return;
    }
    this.status = REJECTED;
    this.value = result;
}

//es6

class Promise{
    constructor(handle){
        if(!isFunction(handle)){
            throw new Error("");
        }
        this.status = PENDING;
        this.value = void 0 ;
        try{
            handle(this.resolve.bind(this),this.reject.bind(this));
        }catch(err){
            this.reject(err);
        }
    }
    resolve(result){
        if(this.status !== PENDING){
            return;
        }
        this.status = FULFILLED;
        this.value = result;
    }
    reject(result){
        if(this.status !== PENDING){
            return;
        }
        this.status = REJECTED;
        this.value = result;
    }
}
```
3. 链式调用,Promise的then方法
- then方法可以链式调用，意味着then返回的是一个promise
- then方法接受两个参数onFulfilled和onRejected
    - 都是可选参数,如果不是函数会被忽略
    - 当promise状态改变时，根据状态调用onFulfilled(resolve)和onRejected(reject),并传入值
- then返回的Promise,将由onFullfilled或者onRejected的返回值决定
    - 假设返回值不是Promise,则返回值作为新返回的Promise对象的值
    - 假设返回值是Promise,这时下一个then中的回调会等待该Promise的状态发生变化后才会被调用，返回新的Promise对象的值最终状态和返回值的Promise一致
    - 如果onFullfiled或者onRejected抛出异常或者返回异常，则返回的Promise状态修改为rejected，并将异常值作为Promise的值
    - 如果onFulfilled和onRejected不是函数，生成的Promise则根据上一个Promise的状态来设置值和状态。
```javascript
then(onFulfilled,onRejected);
//链式调用
var promise2 = promise1.then(onFulfilled,onRejected);
promise2.then(onFulfilled,onRejected);
```
then返回Promise的例子：

```javascript
var promise1 =  new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve("success")
    },5000);
})


//假设返回值不是Promise,则返回值作为新返回的Promise对象的值
//等待执行后变成Promise{[[PromiseStatus]]:'resolve',[[PromiseValue]]:'string'}
var promise2 = promise1.then((res)=>{
    //返回非Promise值
    return 'string'
});

promise2.then((res)=>{
    //string
    console.log(res);
})

//假设返回值是Promise,这时下一个then中的回调会等待该Promise的状态发生变化后才会被调用，返回新的Promise对象的值最终状态和返回值的Promise一致
var promise3 = promise1.then((res)=>{
    //返回promise
    return new Promise((resolve,reject)=>{
        resolve("返回Promise");
    });
});

promise3.then((result)=>{
    //返回Promise
    console.log(result);
});

var promise5 = new Promise((resolve,reject)=>{
    resolve("promise5");
});

//一开始PromiseValue为Undefined，Promise1中resolve后，会变成promise5
var promise6 = promise1.then((res)=>{
    return promise5;
})

//false
console.log(promise6 === promise5);


//如果onFufilled或者onRejected在执行过程中异常或者返回异常，则修改Promise状态为rejected，值为返回的异常
var promise7 = promise1.then((res)=>{
    throw new Error("异常e");
})
promise7.then((res)=>{

},(err)=>{
    console.log(err); //值为异常e的异常
})

//如果onFulfilled和onRejected不是函数，生成的Promise则根据上一个Promise的状态来设置值和状态
//Promise{[[PromiseValue]]:'success',[[PromiseStatus]]:resolved}
promise8 = promise1.then("onFulfilled是字符串");
promise8.then(()=>{

})
```
进一步修改Promise的构造函数，then中接收回调函数的过程，类似于事件监听，只是这个时候监听的是状态，如果状态发生了改变，则执行回调函数。
所以我们可以维护两个队列，一个是fulfilled队列，一个是rejected队列
```javascript
//es5
function Promise(handler){
    if(!isFunction(handler)){
        throw new Error("");
    }
    this.status = PENDING;
    this.value = void 0;
    //维护两个队列
    this.fulfilledQueues = [];
    this.rejectedQueues = [];
    try{
        handler(this.resolve.bind(this),this.reject.bind(this));
    }catch(err){
        this.reject(err);
    }
}
Promise.protoype.then = function(onFulfilled,onRejected){
    //根据当前状态，如果状态为Pending，则推入队列
    //如果状态为FULFILLED，则立即执行onFulFilled
    //如果状态为REJECTED.则立即执行onRejected   
    switch(this.status){
        case PENDING:
            this.fulfilledQueues.push(onFulFilled);
            this.rejectedQueues.push(onRejected);
            break;
        case FULFILLED:
            onFulfilled(this.value);
            break;
        case REJECTED:
            onRejected(this.value);
            break;        
    }
    //返回一个新的Promise对象
    return new Promise(function(){

    });
}

//es6
class Promise{
    constructor(handler){
        if(!isFunction(handler)){
            throw new Error();
        }
        this.status = PENDING;
        this.value = void 0;
        this.fulfilledQueues = [];
        this.rejectedQueues = [];
        try{
            handler(this.resolve.bind(this),this.reject.bind(this))
        }catch(err){
            this.reject(err);
        }
    }
    then(onFulfilled,onRejected){
        const { value,status } = this;
        swtich(status){
            case PENDING:
                this.fulfilledQueues.push(onFulfilled);
                this.rejectedQueues.push(onRejected);
                break;
            case FULFILLED:
                onFulfilled(value);
                break;
            case REJECTED:
                onRejected(value);
                break;       
        }
        return new Promise(()=>{

        })
    }
}

```
then函数应该返回一个Promise，Promise对象的状态依赖于当前回调函数执行的情况以及返回值。  
根据规则进一步完善then:
```javascript
then(onFulfilled,onRejected){
	const { value,status } = this;
	const that = this;
	return new Promise(function(resolve,reject){
		let fulfilled = function(){
			try{
				if(!isFunction(onFulfilled)){
					//因为不是函数，所以不用执行
					//将上一个promise的结果作为当前promise的结果
					resolve(value);
				}else{
					let res = onFulfilled(value);
					if( res instanceof Promise){
						// 如果then回调返回的是Promise对象，则等待其执行完毕后调用resolve,reject
						res.then(resolve,reject);
					} else{
						resolve(res);
					}
				}
			}catch(err){
					reject(err);
			}
		}
		let rejected = function(){
			try{
				if(!isFunction(onRejected)){
					reject(error);
				} else{
					let res = onRejected(error);
					if( res instanceof Promise){
						res.then(resolve,reject);
					}else{
						reject(res);
					}
				}
			}catch(error){
				reject(error);
			}
		}
		swtich(status){
			case PENDING:
				this.fulfilledQueues.push(fulfilled);
				this.rejectedQueues.push(rejected);
				break;
			case FULFILLED:
				fulfilled(value);
				break;
			case REJECTED:
				rejected(value);
				break;		
		}
	})
}

```

