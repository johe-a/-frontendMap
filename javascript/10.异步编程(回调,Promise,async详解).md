<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-03-28 16:09:04
 -->
# 简介
JS中的任务分为同步和异步任务，其中异步任务又分为宏任务和微任务，简单复习下宏任务和微任务，在事件循环机制中总是以这样的顺序来执行任务：同步任务->微任务(微任务队列全部执行完毕)->宏任务(宏任务队列中拿出队首执行)->微任务。

常见的宏任务:
- setTimeout\setInterval
- setImmediate(Nodejs)
- IO操作(例如ajax，文件操作等)
- MessageChannel(通过接口提供的Port1和Port2来互相传递消息)
- requestAnimationFrame(浏览器独有)
- UI rendering(浏览器独有，渲染相关)

常见的微任务：
- process.nextTick(node独有)
- promise
- MutationObserver
- object.observe

也就是说，在使用到上述的相关任务时，都是异步的，当这些异步任务有返回结果的时候，我们该如何去处理？这就是异步编程应该思考的问题

## 回调函数
最常见的处理异步任务返回结果的方式，就是回调函数。  
回调函数的处理方式是，向异步任务传递一个回调函数，当这个异步任务有返回结果的时候，调用回调函数，并传入结果。  

缺点：
1. 回调嵌套
2. 控制反转（回调函数的执行不能够被确定）
    - 回调函数执行多次 (Promise一旦状态改变，再次调用resolve/reject无效，解决了这个问题)
    - 回调函数没有执行（Promise通过race函数来解决）
    - 回调函数有时是同步，有时是异步执行（Promise即使状态同步更改，其FulFilled和Rejected回调依然是异步执行）


例如我们在执行ajax的时候:
```javascript
function Ajax(callback){
    //超时事件ms
    xhr.timeout = 3000
    //返回的数据格式
    xhr.responseType = "text"
    //创建一个post请求，采用异步
    xhr.open('POST', '/server', true)
    //注册相关事件回调
    //传输完成
    xhr.onload = function (e) {
        //this指向xhr
        if (this.status == 200 || this.status == 304) {
            callback(this.responseText)
        }
    }
}

Ajax(function callback(resp){
    console.log("我收到了异步的返回结果:",resp);
});
```
即传入回调函数，异步任务有返回结果时，执行回调。

这种处理方式最大的弊端就是会造成回调嵌套，也称作回调地狱(callback hell).
```javascript
Ajax(function callback(resp){
    //第二个异步任务，依赖第一个异步任务的返回结果
    Ajax(function callback2(res2){
        Ajax(function callback3(res3){
            ...
        })
    })
})
```


## 事件监听(发布/订阅者模式)
本质上也是利用回调，但多了一个发布、订阅的逻辑关系。  
事件监听的处理方式：对某一事件的监听，当事件被触发时，调用事件监听的回调。  
- 对某一事件的监听，可以理解为将回调函数收集到事件的订阅者中心中。  
- 事件的触发，会调用回调，可以理解为发布当前事件，依次调用订阅者中心的回调。

事件的使用例子：  
1. DOM的事件监听
```javascript
<div id="documenta"></div>

var element = document.querySelector("#documenta");
element.addEventListener("click",function(){

})

```
2. 自定义Event事件

```javascript
<div id="documenta"></div>

var element = document.querySelector("#documenta");
var event = new Event("test");
element.addEventListener("test",function(){

});
element.dispatchEvent(event);

var event2 =  new CustomEvent(eventname, options);
/*
其中 options 可以是：
{
  detail: {
    ...
  },
  bubbles: true,    //是否冒泡
  cancelable: false //是否取消默认事件
}*/
element.addEventListner("test2",function(event){

});
element.dispatchEvent(event2);

```
3. nodeJS中的EventEmitter
```javascript
var events = required("events");
var EventEmitter = new events.EventEmitter();

EventEmitter.addEventListener("myEvent",function listener(){

});

//触发
EventEmitter.emit("myEvent")

```

### 事件监听的本质实现
事件监听的本质就是发布订阅者模式

```javascript
function EventEmitter(){
    //订阅者中心
    this.deps = Object.create(null);
}
EventEmitter.prototype.removeListener = function(event,listener){
    if(!this.dep[event]){
        return;
    }
    if(listener){
        //删除事件的其中一个订阅
        var index = this.dep[event].findIndex((item)=>item===listener);
        if(index===-1){
            return;
        }
        this.dep[event].splice(index,1);
    }else{
        //删除事件的所有订阅
        this.dep[event] && delete this.dep[event];
    }
}
EventEmitter.prototype.addEventListener = function(event,listener){
    if(!this.dep[event]){
        this.dep[event] = [];
    }
     this.dep[event].push(listener);
}
EventEmitter.prototype.dispatchEvent = function(event){
    var args = Array.protoype.slice.call(arguments,1);
    if(this.dep[event]){
        this.dep[event].forEach((fn)=>{
            fn.apply(this,args);
        })
    }
}

```

## Promise
Promise解决了回调函数的嵌套回调问题，Promise是一套规范，不同的库根据规范有不同的实现。

Promise如何解决回调函数的控制反转问题：
- 回调函数执行多次 (Promise一旦状态改变，再次调用resolve/reject无效，解决了这个问题)
- 回调函数没有执行（Promise通过race函数来解决）
```javascript
function timeoutPromise(delay){
    return new Promise((resolve,reject)=>{
        setTimeout(function(){
            reject('超时!');
        },delay)
    })
}

Promise.race([fechAPI(),timeoutPromise(3000)]).then(()=>{
},()=>{
})
```
- 回调函数有时是同步，有时是异步执行（Promise即使状态同步更改，其FulFilled和Rejected回调依然是异步执行）

了解Promise,从它的使用特性开始：  
1. 立即执行
```javascript
//传入的函数是同步执行的
new Promise((resolve,reject)=>{
    console.log('promise');
});

console.log('hello');
//先输出promise再输出hello
```
2. Promise维护三种状态：pending,resolved,rejected
```javascript
//Promise{[[PromiseStatus]]:"resolved",[[PromiseValue]]:1};
var p1 = new Promise((resolve,reject)=>{
    resolve(1);
});
//在setTimeout被执行前都是{[[PromiseStatus]]:"pending",[[PromiseValue]]:undefined}
var p2 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve();
    },10000);
});
//{[[PromiseStatus]]:"rejected",[[PromiseValue]]:1}
var p3 = new Promise((resolve,reject)=>{
    reject(1);
});
```
3. 状态不可逆
```javascript
//一旦状态被更改，不可逆
var p1 = new Promise(function(resolve, reject){
  resolve("success1");
  resolve("success2");
});
//success1
p1.then((value)=>{
    console.log(value);
});
```
4. 链式调用
```javascript
var p = new Promise(function(resolve, reject){
  resolve(1);
});
p.then(function(value){               
  console.log(value);
  return value*2;
}).then(function(value){              
  console.log(value);
}).then(function(value){              
  console.log(value);
  return Promise.resolve('resolve'); 
}).then(function(value){              
  console.log(value);
  return new Promise(function(resolve,reject){
      resolve(value);
  });
}).then(function(){
  console.log(value);
  return Promise.reject('reject');
}).then(function(value){              
  console.log('resolve: '+ value);
}, function(err){
  console.log('reject: ' + err);
});

/*
1
2
undefined
resolve
resolve
reject: reject
*/

```
由上面的代码可知：
then方法返回一个新的Promise对象，所以可以继续通过链式调用then方法。  
then方法接受两个函数作为参数，第一个参数是Promise执行resolve时的回调，第二个参数是Promise执行reject时的回调。  
then方法中函数的返回值将决定then返回的Promise对象状态。  
- return一个同步值，或者没有return值（相当于return undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。
- return一个Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。
- throw一个同步异常，then方法将返回一个rejected状态的Promise,值是该异常。

5. Promise.resolve()
Promise.resolve(value)方法返回一个以给定值解析后的Promise对象。
- 如果这个值是一个promise ，那么将返回这个promise 
- 如果这个值是thenable（即带有"then" 方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态
- 其余值返回一个resolved状态的Promise对象，对象的值就是这个参数。

```javascript
//Promise{[[PromiseStatus]]:"resolved",[[PromiseValue]]:1}
var p1 = Promise.resolve(1);
var p2 = Promise.resolve(p1);
//true
console.log(p2===p1);
```
6. resolve和reject
```javascript
var p1 = new Promise(function(resolve, reject){
  resolve(Promise.resolve('resolve'));
});

var p2 = new Promise(function(resolve, reject){
  resolve(Promise.reject('reject'));
});

var p3 = new Promise(function(resolve, reject){
  reject(Promise.resolve('resolve'));
});

p1.then(
  function fulfilled(value){
    console.log('fulfilled: ' + value);
  }, 
  function rejected(err){
    console.log('rejected: ' + err);
  }
);

p2.then(
  function fulfilled(value){
    console.log('fulfilled: ' + value);
  }, 
  function rejected(err){
    console.log('rejected: ' + err);
  }
);

p3.then(
  function fulfilled(value){
    console.log('fulfilled: ' + value);
  }, 
  function rejected(err){
    console.log('rejected: ' + err);
  }
);
//输出
p3 rejected: [object Promise]
p1 fulfilled: resolve
p2 rejected: reject
```
Promise回调函数中的第一个参数resolve，会对Promise执行"拆箱"动作。即当resolve的参数是一个Promise对象时，resolve会"拆箱"获取这个Promise对象的状态和值，但这个过程是异步的。p1"拆箱"后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2"拆箱"后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。


### Promise的实现
1. Promise接受一个函数，并且函数立即执行
```javascript
const isFunction = function(handle){
    return typeof handle === 'function'
}
//es5
function Promise(handle){
    //传入的必须是函数
    if(!isFunction(handle)){
        throw new Error("");
    }
    handle();
}
//es6
class Promise{
    constructor(handle){
        if(!isFunction(handle)){
            throw new Error("");
        }
    }
    handle();
}
```
#### promise的状态
2. Promise具有三个状态:resolved,rejected,pending,状态只能由pending->resolved或者pending->rejected,并且修改状态后，不会发生变化。  
- 状态是由resolve或者reject函数改变的。
- Promise的值是传入resolve和reject函数的值。

所以Promise应该有一个状态属性，一个值属性，并且需要向handle传入resolve和reject函数

```javascript
//定义状态常量
const PENDING = "pending";
const FULFILLED = "resolved";
const REJECTED = "rejected";

//es5实现
function Promise(handle){
    if(!isFunction(handle)){
        throw new Error();
    }
    this.status = PENDING;
    this.value = void 0;
    //这里有两点要注意，第一点是函数执行时出现错误，catch到的错误应该用reject处理
    try{
        //第二点，因为this是动态作用域，resolve和reject中的this应该指向当前Promise实例，所以这里用bind绑定了this为Promise实例
        handle(this.resolve.bind(this),this.reject.bind(this));
    }catch(err){
        this.reject.call(err);
    }
}

Promise.prototype.resolve = function(result){
    if(this.status !== PENDING){
        return;
    }
    this.status = FULFILLED;
    this.value = result;
}
Promise.prototype.reject = function(result){
    if(this.status !== PENDING){
        return;
    }
    this.status = REJECTED;
    this.value = result;
}

//es6

class Promise{
    constructor(handle){
        if(!isFunction(handle)){
            throw new Error("");
        }
        this.status = PENDING;
        this.value = void 0 ;
        try{
            handle(this.resolve.bind(this),this.reject.bind(this));
        }catch(err){
            this.reject(err);
        }
    }
    resolve(result){
        if(this.status !== PENDING){
            return;
        }
        this.status = FULFILLED;
        this.value = result;
    }
    reject(result){
        if(this.status !== PENDING){
            return;
        }
        this.status = REJECTED;
        this.value = result;
    }
}
```

#### promise的then方法
3. 链式调用,Promise的then方法
- then方法可以链式调用，意味着then返回的是一个promise
- then方法接受两个参数onFulfilled和onRejected
    - 都是可选参数,如果不是函数会被忽略
    - 当promise状态改变时，根据状态调用onFulfilled(resolve)和onRejected(reject),并传入值
- then返回的Promise,将由onFullfilled或者onRejected的返回值决定
    - 假设返回值不是Promise,则返回值作为新返回的Promise对象的值
    - 假设返回值是Promise,这时下一个then中的回调会等待该Promise的状态发生变化后才会被调用，返回新的Promise对象的值最终状态和返回值的Promise一致
    - 如果onFullfiled或者onRejected抛出异常或者返回异常，则返回的Promise状态修改为rejected，并将异常值作为Promise的值
    - 如果onFulfilled和onRejected不是函数，生成的Promise则根据上一个Promise的状态来设置值和状态。
```javascript
then(onFulfilled,onRejected);
//链式调用
var promise2 = promise1.then(onFulfilled,onRejected);
promise2.then(onFulfilled,onRejected);
```
then返回Promise的例子：

```javascript
var promise1 =  new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve("success")
    },5000);
})


//假设返回值不是Promise,则返回值作为新返回的Promise对象的值
//等待执行后变成Promise{[[PromiseStatus]]:'resolve',[[PromiseValue]]:'string'}
var promise2 = promise1.then((res)=>{
    //返回非Promise值
    return 'string'
});

promise2.then((res)=>{
    //string
    console.log(res);
})

//假设返回值是Promise,这时下一个then中的回调会等待该Promise的状态发生变化后才会被调用，返回新的Promise对象的值最终状态和返回值的Promise一致
var promise3 = promise1.then((res)=>{
    //返回promise
    return new Promise((resolve,reject)=>{
        resolve("返回Promise");
    });
});

promise3.then((result)=>{
    //返回Promise
    console.log(result);
});

var promise5 = new Promise((resolve,reject)=>{
    resolve("promise5");
});

//一开始PromiseValue为Undefined，Promise1中resolve后，会变成promise5
var promise6 = promise1.then((res)=>{
    return promise5;
})

//false
console.log(promise6 === promise5);


//如果onFufilled或者onRejected在执行过程中异常或者返回异常，则修改Promise状态为rejected，值为返回的异常
var promise7 = promise1.then((res)=>{
    throw new Error("异常e");
})
promise7.then((res)=>{

},(err)=>{
    console.log(err); //值为异常e的异常
})

//如果onFulfilled和onRejected不是函数，生成的Promise则根据上一个Promise的状态来设置值和状态
//Promise{[[PromiseValue]]:'success',[[PromiseStatus]]:resolved}
promise8 = promise1.then("onFulfilled是字符串");
promise8.then(()=>{

})
```
进一步修改Promise的构造函数，then中接收回调函数的过程，类似于事件监听，只是这个时候监听的是状态，如果状态发生了改变，则执行回调函数。
所以我们可以维护两个队列，一个是fulfilled队列，一个是rejected队列
```javascript
//es5
function Promise(handler){
    if(!isFunction(handler)){
        throw new Error("");
    }
    this.status = PENDING;
    this.value = void 0;
    //维护两个队列
    this.fulfilledQueues = [];
    this.rejectedQueues = [];
    try{
        handler(this.resolve.bind(this),this.reject.bind(this));
    }catch(err){
        this.reject(err);
    }
}
Promise.protoype.then = function(onFulfilled,onRejected){
    //根据当前状态，如果状态为Pending，则推入队列
    //如果状态为FULFILLED，则立即执行onFulFilled
    //如果状态为REJECTED.则立即执行onRejected   
    switch(this.status){
        case PENDING:
            this.fulfilledQueues.push(onFulFilled);
            this.rejectedQueues.push(onRejected);
            break;
        case FULFILLED:
            onFulfilled(this.value);
            break;
        case REJECTED:
            onRejected(this.value);
            break;        
    }
    //返回一个新的Promise对象
    return new Promise(function(){

    });
}

//es6
class Promise{
    constructor(handler){
        if(!isFunction(handler)){
            throw new Error();
        }
        this.status = PENDING;
        this.value = void 0;
        this.fulfilledQueues = [];
        this.rejectedQueues = [];
        try{
            handler(this.resolve.bind(this),this.reject.bind(this))
        }catch(err){
            this.reject(err);
        }
    }
    then(onFulfilled,onRejected){
        const { value,status } = this;
        swtich(status){
            case PENDING:
                this.fulfilledQueues.push(onFulfilled);
                this.rejectedQueues.push(onRejected);
                break;
            case FULFILLED:
                onFulfilled(value);
                break;
            case REJECTED:
                onRejected(value);
                break;       
        }
        return new Promise(()=>{

        })
    }
}

```
then函数应该返回一个Promise，Promise对象的状态依赖于当前回调函数执行的情况以及返回值。  
根据规则进一步完善then:
```javascript
then(onFulfilled, onRejected) {
    //then方法要做两件事，一件是根据当前promise的状态来决定是否推入回调队列
    //二是返回一个新的Promise
    //返回的Promise的状态由回调函数决定
    return new MyPromise((resolve, reject) => {
        //当前promise状态为FULFILLED的回调
        let fulfilledHanlder = function (value) {
            //如果当前promise为FULFILLED状态
            //执行onFulfilled查看其返回值来决定返回的Promise
            //但是当onFulfilled不为函数的时候，则直接按照当前Promise的值作为结果
            if (typeof onFulfilled !== 'function') {
                resolve(value)
            } else {
                try {
                    //执行onFulfilled
                    let res = onFulfilled(value);
                    //如果返回值是promise，则等待promise来决定
                    if (res instanceof MyPromise) {
                        res.then(resolve, reject);
                    } else {
                        resolve(res);
                    }
                } catch (err) {
                    reject(err);
                }
            }
        }
        let rejectedHandler = function (error) {
            //如果当前promise为FULFILLED状态
            //执行onFulfilled查看其返回值来决定返回的Promise
            //但是当onFulfilled不为函数的时候，则直接按照当前Promise的值作为结果
            if (typeof onRejected !== 'function') {
                reject(error)
            } else {
                try {
                    let res = onRejected(error);
                    //如果返回值是promise，则等待promise来决定
                    if (res instanceof MyPromise) {
                        res.then(resolve, reject);
                    } else {
                        reject(res);
                    }
                } catch (err) {
                    reject(err);
                }
            }
        }
        //根据状态来决定是否立即执行
        switch (this.status) {
            case PENDING:
                this.fulfilledQueues.push(fulfilledHanlder);
                this.rejetedQueues.push(rejectedHandler);
                break;
            case REJECTED:
                rejectedHandler(this.value);
                break;
            case FULFILLED:
                fulfilledHanlder(this.value);
                break;
        }
    })
}

```
#### promise的resolve和reject
4. 进一步完善resolve和reject,resolve此时的任务不仅仅是修改值和状态，还要执行回调函数队列中的函数。  

但是要注意一点，如果resolve中传递的是一个promise,当前promise的状态和值则由resolve传递的promise决定，例如：

```javascript
let p1 = new Promise((resolve,reject)=>{
})
let p2 = new Promise((resolve,reject)=>[
    resolve(p1);
])
```
由于p2中resolve(p1)，则p2要等待p1执行完毕后，将其结果作为p2的结果，根据p1的结果来决定调用onFulFilled还是onRejected:
```javascript
resolve(value){
    if(this.status!==PENDING){
        return;
    }
    let onFullfiled = function(result){
        while(let cb = this.fulfilledQueues.shift()){
            cb(result);
        }
    }
    let onRejected = function(err){
        while(let cb = this.rejectedQueues.shift()){
            cb(err);
        }
    }
    if(value instanceof Promise){
        value.then((result)=>{
            this.status = FULFILLED;
            this.value = result;
            onFullfiled(result);
        },(error)=>{
            this.status = REJECTED;
            this.value = error;
            onRejected(error)
        })
    }else{
        this.status = FULFILLED;
        onFullfiled(result);
    }
}

```
***所以即使调用了resolve,也不一定会调用其onFulfilled的回调，因为resolve(promise1)的话，当前promise依赖resolve传递的promise1的值，如果promise1的status为REJCTED，则promise也会变成REJCTED***

reject方法没有此特性，所以它的功能就是修改status和value,执行reject的回调
```javascript
reject(error){
    if(this.status !== PENDING ){
        return false;
    }
    this.status = REJECTED;
    this.value = error;
    while(let cb = this.rejectedQueues.shift()){
        cb(error);
    }
}

```
#### promise的catch方法
***根据MDN中的介绍，catch方法实质上就是调用了then(undefined,onRejected)***
问题：then(undefined,onRejected)明明是接受上一个promise的rejected，为什么能够接收链式调用中的rejected和异常？
```javascript
new Promise((resolve,reject)=>{
    reject('err')
}).then(()=>{
}).then(()=>{
}).catch((error)=>{
    //err
    console.log(error)
});
```
***then(undefined,onRejected)能够接受链式调用中的rejected和异常的前提条件是：异常没有被拦截***

在上面的例子中，其余的then方法都没有设置onRejected，根据then返回Promise的规则，Promise依赖onRejected的返回值，但是then方法中的onRejected没有设置，则取上一个Promise的值作为reject的结果。

上面例子等同于下面的例子：
```javascript
let p1 = new Promise((resolve,reject)=>{
    reject('err');
});
//实际上p2为Promise{[[PromiseStatus]]:rejected,[[PromiseValue]]:err}
let p2 = p1.then(()=>{
});
//依旧没有onRejected函数，p3为Promise{[[PromiseStatus]]:rejected,[[PromiseValue]]:err}
let p3 = p2.then(()=>{ 
})
let p4 = p3.then(undefined,(err)=>{
    //'err'
    console.log(err);
})
```

#### Promise的resolve、reject方法(静态函数)
根据上面所提到的Promise.resolve(value):
- 如果value为promise，则直接返回这个promise
- 如果value为普通值，则返回一个新的Promise,则为value,状态为Fulfilled

```javascript
class Promise{
    static resolve(value){
        if( value instanceof Promise){
            return value;
        }else{
            return new Promise((resolve,reject)=>resolve(value));
        }
    }
}
```
Promise.reject(value)不管value是什么直接返回一个新的Promise,并将value作为值
```javascript
class Promise{
    static reject(value){
        return new Promise((resolve,reject)=>reject(value));
    }
}
```

#### Promise的all方法(静态函数)
Promise.all([p1,p2,p3]),接受一个数组，返回一个Promise。
- 数组内的成员可以是任意值，如果是Promise的实例，则等待Promise执行完毕后传入对应的value数组
- 如果是其他值，则直接传入value数组
- 如果p1、p2、p3其中有一个为rejected，则Promise的值为reject值，并且status为Rejected

```javascript
class Promise{
    static all(list) {
        //执行list中的Promise返回一个新的Promise值为这两个Promise的值，如果不为Promise，直接resolve,为Promise则等待其执行结果
        return new MyPromise((resolve, reject) => {
            let value = [];
            let count = 0;
            for (let [index, p] of list.entries()) {
                //这里采用this.resolve，由于all也是静态方法，this指向MyPromise
                //MyPromise.resolve一定会返回一个MyPromise的实例，并且处理了p不为MyPromise的情况
                this.resolve(p).then((res) => {
                    value[index] = res;
                    //利用闭包记录
                    count++;
                    //这里不能用index === list.length-1判断，因为该回调的执行不一定按顺序
                    if (count === list.length) {
                        resolve(value);
                    }
                }, (error) => {
                    //有一个reject，则直接返回reject
                    reject(error);
                })
            }
        })
    }
}

```

#### Promise.race方法(静态函数)
Promise.race([p1,p2]),结果由p1、p2中先改变状态的Promise决定
```javascript
class Promise{
    static race(list){
        return new Promise((resolve,reject)=>{
            let value;
            for(let [index,p] of list.entries()){
                this.resolve(p).then(res=>{
                    resolve(res)
                },err=>{
                    reject(err)
                });
            }
        })
    }
}

```

#### promise.finally方法（原型函数）
finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作

```javascript
finally (cb) {
  return this.then(
    value  => MyPromise.resolve(cb()).then(() => value),
    reason => MyPromise.resolve(cb()).then(() => { throw reason })
  );
};
```

### Promise完整代码

```javascript
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";
class MyPromise {
	constructor(handler) {
		this.status = PENDING;
		this.value = void 0;
		this.fulfilledQueues = [];
		this.rejetedQueues = [];
		try {
			handler(this.resolve.bind(this), this.reject.bind(this));
		} catch (err) {
			this.reject(err);
		}
	}
	resolve(result) {
		//resolve完成以下工作：
		//修改状态
		//修改值
		//执行未执行的回调
		//由于resolve在接收promise的情况下，需要等待promise的值来修改当前promise的值
		let fulfilledHanlder = function (value) {
			let cb;
			while (cb = this.fulfilledQueues.shift()) {
				cb(value);
			}
		}
		let rejectedHandler = function (err) {
			let cb;
			while (cb = this.rejetedQueues.shift()) {
				cb(err);
			}
		}
		const run = ()=>{ 
            if (this.status !== PENDING) {
			    return;
            }
            if (result instanceof MyPromise) {
                result.then((res) => {
                    this.status = FULFILLED;
                    this.value = res;
                    fulfilledHanlder(res);
                }, (error) => {
                    this.status = REJECTED;
                    this.value = error;
                    rejectedHandler(error);
                })
            } else {
                this.status = FULFILLED;
                this.value = result;
                fulfilledHanlder(result);
            }
        }
        //模拟promise的异步执行，这里用的是宏任务，但实际上应该是微任务
        setTimeout(run,0);
	}
	reject(error) {
        const run = ()=>{
            if (this.status !== PENDING) {
                return;
            }
            this.status = REJECTED;
            this.value = error;
            let cb;
            while (cb = this.rejetedQueues.shift()) {
                cb(error);
            }
        }
        setTimeout(run,0);
	}
	then(onFulfilled, onRejected) {
		//then方法要做两件事，一件是根据当前promise的状态来决定是否推入回调队列
		//二是返回一个新的Promise
		//返回的Promise的状态由回调函数决定
		return new MyPromise((resolve, reject) => {
			//当前promise状态为FULFILLED的回调
			let fulfilledHanlder = function (value) {
				//如果当前promise为FULFILLED状态
				//执行onFulfilled查看其返回值来决定返回的Promise
				//但是当onFulfilled不为函数的时候，则直接按照当前Promise的值作为结果
				if (typeof onFulfilled !== 'function') {
					resolve(value)
				} else {
					try {
						//执行onFulfilled
						let res = onFulfilled(value);
						//如果返回值是promise，则等待promise来决定
						if (res instanceof MyPromise) {
							res.then(resolve, reject);
						} else {
							resolve(res);
						}
					} catch (err) {
						reject(err);
					}
				}
			}
			let rejectedHandler = function (error) {
				//如果当前promise为FULFILLED状态
				//执行onFulfilled查看其返回值来决定返回的Promise
				//但是当onFulfilled不为函数的时候，则直接按照当前Promise的值作为结果
				if (typeof onRejected !== 'function') {
					reject(error)
				} else {
					try {
						let res = onRejected(error);
						//如果返回值是promise，则等待promise来决定
						if (res instanceof MyPromise) {
							res.then(resolve, reject);
						} else {
							reject(res);
						}
					} catch (err) {
						reject(err);
					}
				}
			}
			//根据状态来决定是否立即执行
			switch (this.status) {
				case PENDING:
					this.fulfilledQueues.push(fulfilledHanlder);
					this.rejetedQueues.push(rejectedHandler);
					break;
				case REJECTED:
					rejectedHandler(this.value);
					break;
				case FULFILLED:
					fulfilledHanlder(this.value);
					break;
			}
		})
	}
	catch(callback) {
		return this.then(undefined, callback);
	}
	static resolve(value) {
		if (value instanceof MyPromise) {
			return value;
		} else {
			return new MyPromise((resolve, reject) => {
				resolve(value);
			})
		}
	}
	static reject(value) {
		return new MyPromise((resolve, reject) => reject(value));
	}
	static all(list) {
		//执行list中的Promise返回一个新的Promise值为这两个Promise的值，如果不为Promise，直接resolve,为Promise则等待其执行结果
		return new MyPromise((resolve, reject) => {
			let value = [];
			let count = 0;
			for (let [index, p] of list.entries()) {
				//这里采用this.resolve，由于all也是静态方法，this指向MyPromise
				//MyPromise.resolve一定会返回一个MyPromise的实例，并且处理了p不为MyPromise的情况
				this.resolve(p).then((res) => {
					value[index] = res;
					//利用闭包记录
					count++;
					//这里不能用index === list.length-1判断，因为该回调的执行不一定按顺序
					if (count === list.length) {
						resolve(value);
					}
				}, (error) => {
					//有一个reject，则直接返回reject
					reject(error);
				})
			}
		})
	}
	static race(list) {
		//只要有一个有返回结果，按照最快返回结果的promise作为新返回Promise的值
		return new Prommise((resolve, reject) => {
			for (let p of list) {
				this.resolve(p).then((res) => {
					resolve(res);
				}, (err) => {
					reject(err);
				})
			}
		})
	}
}

```


## 迭代器对象和生成器函数

### 迭代器对象
要了解迭代器和生成器，首先要了解可迭代协议
>可迭代协议：用来定义对象的迭代行为，例如，在一个for...of结构中，有哪些值可以被遍历到。一些内置类型同时是内置可迭代对象，并且有默认的迭代行为，例如Array、Map、Set、String、TypeArray、Arguments类数组对象、NodeList对象。

***为了成为可迭代对象，一个对象必须实现@@iterator方法，意味着对象或者它的原型链上的某个对象，必须要有一个名为@@iterator的方法,可以通过常量Symbol.iterator访问该属性.***

当一个对象需要被迭代的时候，例如被放置到一个for...of循环时，首先会不带参数的调用它的@@iterator方法（来获取迭代器），然后用此方法返回的迭代器获取要迭代的值。


***只有实现了一个拥有以下语义的next()方法，一个对象才能成为迭代器***

next方法必须返回一个对象，该对象有两个属性：done和value，如果返回了一个非对象值(例如false或者undefined)(在被当做迭代器访问的时候),则会抛出一个TypeError异常。  
done:如果迭代器可以产生序列中的下一个值，则为false，如果序列迭代完毕，则为true。  
value:任意值，done为true时可以省略

```javascript
var myIterator = {
    next:function(){},
    [Symbol.iterator]:function(){return this}
}
```
不一定要返回this，但一定要返回一个迭代器对象，例如：
```javascript
class SimpleClass {
  constructor(data) {
    this.data = data
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.data.length) {
          return {value: this.data[index++], done: false}
        } else {
          return {done: true}
        }
      }
    }
  }
}

const simple = new SimpleClass([1,2,3,4,5])

for (const val of simple) {
  console.log(val)   //'1' '2' '3' '4' '5' 
}
```

使用内置对象String的迭代器:
```javascript
let str = 'hello';
//访问迭代器
let iterator = str[Symbol.iterator]();

iterator.next().value; //'h'
iterator.next().value; //'e'
iterator.next().value; //'l'
iterator.next().value; //'l'
iterator.next().value; //'o'

```

#### 迭代器的方法
迭代器对象除了具有next方法，还可以具有return、trow方法。  
- next方法是必须部署的，return和throw方法是可选的。  
- return方法的使用场景是，如果for...of循环提前退出(通常是因为出错，或者有break语句、continue语句)，就会调用return方法。如果一个对象在完成遍历前，需要清理或者释放资源，就可以部署return方法。

也就是说如果在for...of循环内出错或者使用了break、continue退出循环，就会调用迭代器的return方法。
```javascript
function createIterator(items) {
    var i = 0;
    return {
        next: function() {
            var done = i >= items.length;
            var value = !done ? items[i++] : undefined;

            return {
                done: done,
                value: value
            };
        },
        return: function() {
            console.log("执行了 return 方法");
            return {
                value: 23333,
                done: true
            };
        }
    };
}

var colors = ["red", "green", "blue"];

var iterator = createIterator([1, 2, 3]);

colors[Symbol.iterator] = function() {
    return iterator;
};

for (let color of colors) {
    if (color == 1) break;
    console.log(color);
}

```

#### 用于可迭代对象的语法
一些语句和表达式适用于可迭代对象，例如for...of循环、展开语法、yield*和解构赋值。
```javascript
for(let value of ['a','b','c']){
    console.log(value);
}

[..."abc"];//['a','b','c']

function* gen(){
    yield* ['a','b','c'];
}
gen().next();//{value:'a',done:false}

[a,b,c] = new Set(["a","b","c"]);
a// "a"
```

#### 自定义可迭代对象
```javascript
let iteratorObject = (function(){
    let value = 0;
    return {
        next:function(){
            if(value < 10){
                value++;
                return {value,done:false}
            }else{
                return {done:true}
            }
        },
        [Symbol.iterator]:function(){
            return this;
        }
    }
})()
```
通过yield可以定义每次迭代过程产生的值
```javascript
var myIterator = {
    [Symbol.iterator]:function* (){
        yield 1;
        yield 2;
        yield 3;
    }
};
[...myIterator];

```
### 生成器函数
>function*函数被称为生成器函数(generator function)。

虽然自定义的迭代器(对象)是一个有用的工具，但由于需要显式的维护内部状态(next方法)，所以要谨慎的创建，生成器函数提供了一个强大的选择，它允许定义一个包含自有迭代算法的函数，同时自动维护状态(不用写next方法)。

- ***生成器函数第一次调用时会返回迭代器，不执行任何代码***  
- ***通过调用生成器产生的迭代器next()方法来执行生成器代码，生成器代码会执行直到遇到yield关键字。***
- yield value等同于next方法中的return { value:value,done:false}
- 可以根据需要多次调用生成器函数，每次都会返回一个新的迭代器对象，每个迭代器只能迭代一次(直到done为true)


写一个生成器函数，能够生成一个在特定范围内迭代的迭代器
```javascript
function* makeRangeIterator(start = 0 ,end = Infinity ,step = 1){
    for(let i = start;i < end; i+= step ){
        yield 1;
    }
}

//生成一个1-10范围内迭代的迭代器
var a = makeRangeIterator(1,10,2);
a.next() // {value:1,done:false}
a.next() // {value:2,done:false}
a.next() // {value:3,done:false}
```

#### 生成器代码执行过程

```javascript
function* foo(){
    yield 'hello';
    console.log('world');
    yield  ',';
    return 'friend';
    yield  '。';
}
let fooIterator = foo();//代码不执行，生成迭代器
> fooIterator.next();
< {value:'hello',done:false}
> fooIterator.next();
  log: 'world'
< {value:',',done:false}
> fooIterator.next();
< {value:'friend',done:true}
> fooIterator.next();
< {value:'friend',done:true}
```
- 每次代码执行会遇到下一个yield停止，每次迭代的值由yield决定
- 如果遇到了return语句，代表迭代结束，无论后面还有没有表达式和yield语句，再次调用next方法，都只会返回{value:undefined,done:true}
- yield不能再普通函数内使用
- yield如果在表达式中，必须放在圆括号内

```
console.log('hello'+ (yield 123))
```


#### 生成器传参
给生成器generator传参的结果是，这个参数能在生成器函数的任何状态中读取到。
```javascript
function* foo(x){
    console.log(x);
    yield 'step1';

    console.log(x);
    yield 'step2';

    console.log(x);
    return 'step3'
}

const fooIterator = foo("hello world");
```
无论在函数体的哪个状态，都能读取到x参数

#### 迭代器传参
> 生成器生成的迭代器可以用next方法传递参数。

***yield语句本身没有返回值，总是返回undefined。 ***
这是因为我们可以看yield value为next函数中的return {value,done:false}

这个时候我们需要知道上一个yield的返回值怎么办？***通过next传递的参数，可以作为上一个yield语句的返回值。***


从以下例子可以看出yield没有返回值
```javascript
function* foo(){
    let x = yield 10;
    console.log(x);
    return 'ending';
}

const fooIterator = foo();
> fooIterator.next();
< {value:10,done:false}
> fooIterator.next();
  log:undefined
< {value:'ending',done:true}
```
通过next传值作为上一个yield的返回值:
```javascript
function* foo(){
    let x = yield 10;
    console.log(x);
    return 'ending';
}

const fooIterator = foo();
> fooIterator.next();
< {value:10,done:false}
> fooIterator.next('hello world');
  log:'hello world'
< {value:'ending',done:true}
```
这里第二次调用next传递了'hello world'，作为yield 10表达式的返回值，所以x被赋值为'hello world';

再看一个传参的例子:
```javascript 
function* foo(x){
    let y = 2*(yield(x + 5));
    let z = yield y / 4 + 3;
    return (x + y - z);
}
const fooIterator = foo(10);
> fooIterator.next(); // 输出x+5
< {value:15,done:false}
> fooIterator.next(4);//代表yield(x+5)的值为4,即y = 8
< {value:5,done:false}
> fooIterator.next(8);//代表yield y / 4 + 3的值为8,即z为8
< {value:10+8-8,done:true}
```

#### 生成器错误捕获
- generator函数能够在函数体内部捕获错误
- 错误一经捕获，generator函数就会停止遍历,done为true
```javascript
function* foo(){
    try{
        yield console.log(a);
    }catch(err){    
        console.log(err);
    }
}

let fooIterator = foo();
> foo.next();
  log:ReferenceError:a is not defined
< {value:undefined,done:true}
```

```javascript
function* foo() {
  try {    
    yield console.log(variate)
    yield console.log('hello world')
  } catch(err) {
    throw err 
  }
}

const g = foo()

try {
    g.next()
} catch(err) {
    console.log('外部捕获', err)
}

> 外部捕获 ReferenceError: variate is not defined
    at foo (index.js:3)
    at foo.next (<anonymous>)
    at index.js:13
```
### 迭代语法
迭代语法用于迭代器的迭代，由于生成器函数每次生成一个迭代器，所以生成器生成的迭代器也可以被迭代语法使用。  
常见的迭代语法：
- for...of
- yield* 与for...of类似
- 展开运算符...
- 解构赋值

#### for...of
```javascript
function* foo(){
    yield 1;
    yield 2;
    return 3;
}

for( let i of foo()){
    console.log(i); //1 2
}
```
- 使用for...of会自动调用next方法，并且每次取到next返回的对象中的value
- 一旦next方法返回的对象done为true,则会停止遍历
- for...of不会返回done为true时的value值，所以上面的例子不会输出3

for...of的模拟实现：通过对象的Symbol.iterator属性获取迭代器对象，遍历迭代器，直到返回的done为true。这里要注意一点，for...of不会返回done为true的那个迭代值。
```javascript
//使用callback来接收值
function forOf(obj,callback){
    //判断obj的Symbol.iterator是否为函数
    if(typeof obj[Symbol.iteraotr] !== 'function'){
        throw new Error("")
    }
    if(typeof callback !== 'function'){
        throw new Error("")
    }
    //iterator实际上是一个拥有next方法的对象
    var iterator = obj[Symbol.iterator];
    var result = iterator.next();
    if(!result.done){
        callback(result.value);
        result = iterator.next();
    }
}
forOf([1,2,3],function(a){
    console.log(a);
})

```

#### yield*语句
用于在generator函数内部调用另一个generator函数，本质上与for...of一致

```javascript
function* foo(){
    yield 3;
    yield 4;
    return 5;
}


function* bar(){
    yield 1;
    yield 2;
    /*完全等价于
       for(let i of foo()){
           yield i;
       } 
    */
    yield* foo();
    yield 5;
    return 'end';
}

for(let v of bar()){
    console.log(v);  
}
//< 1 2 3 4 5
```
- 实际上是对迭代器对象的循环
- 可以看做是for...of的语法糖
- 不能在generator函数外使用

因为它与for...of行为一致，所以它也可以迭代数组和字符串等内置可迭代对象
```javascript
function* foo(){
    yield* [1,2,3];
    yield* '456'
}
for(let i of foo()){
    console.log(i); 
}
// < 1 2 3 4 5 6
```

yield*语句可以保存返回值，和yield不同的是yield本身没有返回值，必须由next方法赋予  
如果yield*代理的genearator函数由return语句时，return返回的值可以永久被保存
```javascript
function* foo(){
    yield 2;
    return 'hello yield*';
}

function* bar(){
    let a = yield 1;
    console.log(a);//undefined

    let b = yield* foo();
    console.log(b);//hello yield*
}

```
用yield*拍平数组
```javascript
let tree =  [1, 2, [3, 4, [5, 6, [7, 8, 9]]], 10, 11];
function* loopTree(tree){
    if(Array.isArray(tree)){
        for(let item of tree){
            yield* loopTree(item);
        }
    }else{
        yield tree;
    }
}

for(let i of loopTree(tree) ){
    console.log(i);
}

//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
console.log([...loopTree(tree)]);r

//传统的拍平数组
function flatArray(tree){
    let result = [];
    for(let item of tree){
        if(Object.prototype.toString.call(item)==='[object Array]'){
            result = result.concat(flatArray(item));
        }else{
            result.push(item);
        }
    }
    return result;
}
```
### 内建迭代器
ES6为数组、Map、Set集合内建了以下三种迭代器：
- entries()返回一个遍历器对象，用来遍历[键名,键值]组成的数组，对于数组，键名就是索引值
- keys()返回一个遍历器对象，用来遍历所有的键名
- values()返回一个遍历器对象，用来遍历所有的键值

使用for...of循环的时候，数组和set集合默认的迭代器是values方法，Map集合的默认迭代器是entries方法。这就是为什么for...of遍历set和map时，会有不同的数据结构返回。

Map和数组类似：
```javascript
var colors = ["red","green","blue"];

for(let index of colors.keys()){
    // 0 1 2
    console.log(index);
}

for(let value of color.values()){
    // red green blue
    console.log(value);
}

for(let item of color.entries()){
    //[0,red] [1,green] [2,blue]
    console.log(item);
}
```
对于Set，其keys和values返回的是相同的迭代器，这也意味着在Set这种数据结构中key和value相同。
```javascript
var colors = new Set(["red","green","blue"]);

for(let key of color.keys()){
    //red green blue
    console.log(key);
}

for(let value of color.values()){
    //red green blue
    console.log(value);
}

for(let item of color.entries()){
    //['red','red'] ['green','green'] ['blue','blue']
    console.log(item);
}
```
由于for...of循环Map数据结构时遍历的是entries()迭代器，所以可以顺便使用解构赋值：
```javascript
const values = new Map([
    ['key1','value1'],
    ['key2','value2']
]);

for (let [key,value] of values){
    console.log(key,value);
}

```


### 用生成器实现异步
生成器的生成的迭代器能够按迭代的步骤执行，我们知道同步代码都是按顺序执行的，但是异步代码则不是。如何让异步代码以同步的顺序写出？我们可以使用生成器。

假设有以下需求：我们需要去调用第三方接口，但是调用第三方接口前，先要获取token，再去调用第三方接口。所以就有个先后循序的问题。

```javascript
function getToken(){
    ajax({
        type:'get',
        url:'/getToken',
        success:function(data){
            iterator.next(data);
        }
    })
}
function getData(token){
    ajax({
        type:'get',
        data:{
            token
        },
        url:'/getData',
        sucess:function(data){
            iterator.next(data);
        }
    })
}

//制造一个生成器函数
function* getDataGenerator(){
    let token = yield getToken();
    let data = yield getData(token);
    console.log(data);
}

var iterator = getDataGenerator();
iterator.next();

```


## async/await
async函数，也叫做异步函数，await关键字只能在异步函数内使用。
- async函数可以看做是generator函数和自动执行器的结合.
- await可以看做是promise中的then
- generator函数的执行必须依靠执行器，需要调用next方法。而async函数不需要调用next方法，自动执行。
- async表示函数里面有异步操作，await表示紧跟在后面的表达式需要等待结果。
- await命令与Promise对象合作，共同完成异步操作

generator的缺点是还需要我们手动控制next执行，使用async/await的时候，只要await后面跟着一个Promise,它就会自动等到Promise决议后的返回值(接收resolve)，reject值需要在try/catch中捕获。

```javascript
function getToken(){
    return new Promise((resolve,reject)=>{
        setTimeout(function(){
            resolve('token');
        },1000);
    })
}
function getData(token){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve(token+' data');
        },500)
    })
}
async function getDataFunc(){
    let token = await getToken();
    let data = await getData(token);
    console.log(data);
}

//token data
getDataFunc();
```
### async/await异常捕获
我们可以使用try/catch或者promise catch的方式捕获async函数中的异常

```javascript
function getData(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            reject();
        },1000)
    })
}
async function main(){
    await getData();
    //不会被执行
    console.log('success');
}

main();
```
上面的代码会报Uncaught(in promise)，因为异常没有被捕获到

使用try/catch捕获异常：
```javascript
function getData(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            reject('error');
        },1000)
    })
}
async function main(){
    try{
      await getData();
    }catch(err){
      console.log(err); 
    }
    //会被执行
    console.log('success');
}

main();
```
但是这种情况无法捕获：
```javascript
function getData(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            throw new Error("error");
        },1000)
    })
}
async function main(){
    try{
      await getData();
    }catch(err){
      console.log(err); 
    }
    //会被执行
    console.log('success');
}

//Uncaught Error: error
main();
```
这是由于setTimeout内的回调执行时，上下文已经不是当前的try/catch上下文

由于generator返回Promise,所以我们可以用catch()来捕获错误:
```javascript
function getData(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            reject('error');
        },1000)
    })
}
async function main(){
      await getData();
}
main().then(()=>{
    //不会被执行
    console.log('success');
}).catch((err)=>{
    console.log(err);
})
```

### 实现async/await的自动执行
async/await是生成器和自动执行器的结合，拥有自动执行迭代器的特点（自动调用next）。  
思考使用Promise+生成器的方式，来实现async/await，首先需要生成一个函数，该函数接受生成器，返回一个async的模拟函数。
- 函数内部调用生成器来生成迭代器
- 函数内部返回一个Promise
- 函数内部需要实现自动调用迭代器（在Promise内）
```javascript
function getData(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve('getData');
        },1000)
    })
}

//调用方式
let test = asyncMock(
    function* generator(){
        yield getData();
        yield 1;
        return 'success';
    }
)

test().then((result)=>{
	console.log(result);
})

function asyncMock(generator){
	//返回一个函数，模拟async函数
	return function(){
		//生成执行器
		let iterator = generator.apply(this,arguments);
		//由于async函数最终返回Promise，所以我们也需要返回一个Promsie
		return new Promise((resolve,reject)=>{
			//resolve,reject是最终的结果
			//我们需要实现自动调用执行器
			function step(method,arg){
				let yieldResult;
				try{
					yieldResult = iterator[method](arg);
				}catch(err){
					reject(err);
				}
				console.log(yieldResult);
				let { value,done } = yieldResult;
				if(done){
					resolve(value);
				}else{
					//静态resolve方法，如果value是Promise，则会直接返回Promise,如果是其他值，会作将值作为Promise的结果，返回一个新的Promise
					Promise.resolve(value).then((result)=>{
						step("next",value);
					},(err)=>{
						step("throw",err);
					})
				}
			}
			step("next")
		})
	}
}

```

### 简化async的异常捕获
尽管我们可以使用try catch捕获异常，但是当我们需要捕获多个错误并做不同的处理时，很快try catch就会导致代码杂乱：
```javascript
async function asyncTask(cb) {
    try {
       const user = await UserModel.findById(1);
       if(!user) return cb('No user found');
    } catch(e) {
        return cb('Unexpected error occurred');
    }

    try {
       const savedTask = await TaskModel({userId: user.id, name: 'Demo Task'});
    } catch(e) {
        return cb('Error occurred while saving task');
    }

    if(user.notificationsEnabled) {
        try {
            await NotificationService.sendNotification(user.id, 'Task Created');
        } catch(e) {
            return cb('Error while sending notification');
        }
    }

    if(savedTask.assignedUser.id !== user.id) {
        try {
            await NotificationService.sendNotification(savedTask.assignedUser.id, 'Task was created for you');
        } catch(e) {
            return cb('Error while sending notification');
        }
    }

    cb(null, savedTask);
}

```
为了简化这种错误的捕获，我们可以给await后面的promise对象添加catch函数，为此我们需要写一个helper:
```javascript
export default function to(promise){
        promise.then((result)=>{
            return [null,result]
        }).catch((err)=>{
            return [err]
        })
}

async function asyncTask() {
     let err, user, savedTask;

     [err, user] = await to(UserModel.findById(1));
     if(!user) throw new CustomerError('No user found');

     [err, savedTask] = await to(TaskModel({userId: user.id, name: 'Demo Task'}));
     if(err) throw new CustomError('Error occurred while saving task');

    if(user.notificationsEnabled) {
       const [err] = await to(NotificationService.sendNotification(user.id, 'Task Created'));
       if (err) console.error('Just log the error and continue flow');
    }
}

```