<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-03-28 16:09:04
 -->
# 简介
JS中的任务分为同步和异步任务，其中异步任务又分为宏任务和微任务，简单复习下宏任务和微任务，在事件循环机制中总是以这样的顺序来执行任务：同步任务->微任务(微任务队列全部执行完毕)->宏任务(宏任务队列中拿出队首执行)->微任务。

常见的宏任务:
- setTimeout\setInterval
- setImmediate(Nodejs)
- IO操作(例如ajax，文件操作等)
- MessageChannel(通过接口提供的Port1和Port2来互相传递消息)
- requestAnimationFrame(浏览器独有)
- UI rendering(浏览器独有，渲染相关)

常见的微任务：
- process.nextTick(node独有)
- promise
- MutationObserver
- object.observe

也就是说，在使用到上述的相关任务时，都是异步的，当这些异步任务有返回结果的时候，我们该如何去处理？这就是异步编程应该思考的问题

## 回调函数
最常见的处理异步任务返回结果的方式，就是回调函数。  
回调函数的处理方式是，向异步任务传递一个回调函数，当这个异步任务有返回结果的时候，调用回调函数，并传入结果。

例如我们在执行ajax的时候:
```javascript
function Ajax(callback){
    //超时事件ms
    xhr.timeout = 3000
    //返回的数据格式
    xhr.responseType = "text"
    //创建一个post请求，采用异步
    xhr.open('POST', '/server', true)
    //注册相关事件回调
    //传输完成
    xhr.onload = function (e) {
        //this指向xhr
        if (this.status == 200 || this.status == 304) {
            callback(this.responseText)
        }
    }
}

Ajax(function callback(resp){
    console.log("我收到了异步的返回结果:",resp);
});
```
即传入回调函数，异步任务有返回结果时，执行回调。

这种处理方式最大的弊端就是会造成回调嵌套，也称作回调地狱(callback hell).
```javascript
Ajax(function callback(resp){
    //第二个异步任务，依赖第一个异步任务的返回结果
    Ajax(function callback2(res2){
        Ajax(function callback3(res3){
            ...
        })
    })
})
```

## 事件监听(发布/订阅者模式)
本质上也是利用回调，但多了一个发布、订阅的逻辑关系。  
事件监听的处理方式：对某一事件的监听，当事件被触发时，调用事件监听的回调。  
- 对某一事件的监听，可以理解为将回调函数收集到事件的订阅者中心中。  
- 事件的触发，会调用回调，可以理解为发布当前事件，依次调用订阅者中心的回调。

事件的使用例子：  
1. DOM的事件监听
```javascript
<div id="documenta"></div>

var element = document.querySelector("#documenta");
element.addEventListener("click",function(){

})

```
2. 自定义Event事件

```javascript
<div id="documenta"></div>

var element = document.querySelector("#documenta");
var event = new Event("test");
element.addEventListener("test",function(){

});
element.dispatchEvent(event);

var event2 =  new CustomEvent(eventname, options);
/*
其中 options 可以是：
{
  detail: {
    ...
  },
  bubbles: true,    //是否冒泡
  cancelable: false //是否取消默认事件
}*/
element.addEventListner("test2",function(event){

});
element.dispatchEvent(event2);

```
3. nodeJS中的EventEmitter
```javascript
var events = required("events");
var EventEmitter = new events.EventEmitter();

EventEmitter.addEventListener("myEvent",function listener(){

});

//触发
EventEmitter.emit("myEvent")

```

### 事件监听的本质实现
事件监听的本质就是发布订阅者模式

```javascript
function EventEmitter(){
    //订阅者中心
    this.deps = Object.create(null);
}
EventEmitter.prototype.removeListener = function(event,listener){
    if(!this.dep[event]){
        return;
    }
    if(listener){
        //删除事件的其中一个订阅
        var index = this.dep[event].findIndex((item)=>item===listener);
        if(index===-1){
            return;
        }
        this.dep[event].splice(index,1);
    }else{
        //删除事件的所有订阅
        this.dep[event] && delete this.dep[event];
    }
}
EventEmitter.prototype.addEventListener = function(event,listener){
    if(!this.dep[event]){
        this.dep[event] = [];
    }
     this.dep[event].push(listener);
}
EventEmitter.prototype.dispatchEvent = function(event){
    var args = Array.protoype.slice.call(arguments,1);
    if(this.dep[event]){
        this.dep[event].forEach((fn)=>{
            fn.apply(this,args);
        })
    }
}

```

## Promise
Promise解决了回调函数的嵌套回调问题，Promise是一套规范，不同的库根据规范有不同的实现。

了解Promise,从它的使用特性开始：  
1. 立即执行
```javascript
//传入的函数是同步执行的
new Promise((resolve,reject)=>{
    console.log('promise');
});

console.log('hello');
//先输出promise再输出hello
```
2. Promise维护三种状态：pending,resolved,rejected
```javascript
//Promise{[[PromiseStatus]]:"resolved",[[PromiseValue]]:1};
var p1 = new Promise((resolve,reject)=>{
    resolve(1);
});
//在setTimeout被执行前都是{[[PromiseStatus]]:"pending",[[PromiseValue]]:undefined}
var p2 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve();
    },10000);
});
//{[[PromiseStatus]]:"rejected",[[PromiseValue]]:1}
var p3 = new Promise((resolve,reject)=>{
    reject(1);
});
```
3. 状态不可逆
```javascript
//一旦状态被更改，不可逆
var p1 = new Promise(function(resolve, reject){
  resolve("success1");
  resolve("success2");
});
//success1
p1.then((value)=>{
    console.log(value);
});
```
4. 链式调用
```javascript
var p = new Promise(function(resolve, reject){
  resolve(1);
});
p.then(function(value){               
  console.log(value);
  return value*2;
}).then(function(value){              
  console.log(value);
}).then(function(value){              
  console.log(value);
  return Promise.resolve('resolve'); 
}).then(function(value){              
  console.log(value);
  return new Promise(function(resolve,reject){
      resolve(value);
  });
}).then(function(){
  console.log(value);
  return Promise.reject('reject');
}).then(function(value){              
  console.log('resolve: '+ value);
}, function(err){
  console.log('reject: ' + err);
});

/*
1
2
undefined
resolve
resolve
reject: reject
*/

```
由上面的代码可知：
then方法返回一个新的Promise对象，所以可以继续通过链式调用then方法。  
then方法接受两个函数作为参数，第一个参数是Promise执行resolve时的回调，第二个参数是Promise执行reject时的回调。  
then方法中函数的返回值将决定then返回的Promise对象状态。  
- return一个同步值，或者没有return值（相当于return undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。
- return一个Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。
- throw一个同步异常，then方法将返回一个rejected状态的Promise,值是该异常。

5. Promise.resolve()
Promise.resolve(value)方法返回一个以给定值解析后的Promise对象。
- 如果这个值是一个promise ，那么将返回这个promise 
- 如果这个值是thenable（即带有"then" 方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态
- 其余值返回一个resolved状态的Promise对象，对象的值就是这个参数。

```javascript
//Promise{[[PromiseStatus]]:"resolved",[[PromiseValue]]:1}
var p1 = Promise.resolve(1);
var p2 = Promise.resolve(p1);
//true
console.log(p2===p1);
```
6. resolve和reject
```javascript
var p1 = new Promise(function(resolve, reject){
  resolve(Promise.resolve('resolve'));
});

var p2 = new Promise(function(resolve, reject){
  resolve(Promise.reject('reject'));
});

var p3 = new Promise(function(resolve, reject){
  reject(Promise.resolve('resolve'));
});

p1.then(
  function fulfilled(value){
    console.log('fulfilled: ' + value);
  }, 
  function rejected(err){
    console.log('rejected: ' + err);
  }
);

p2.then(
  function fulfilled(value){
    console.log('fulfilled: ' + value);
  }, 
  function rejected(err){
    console.log('rejected: ' + err);
  }
);

p3.then(
  function fulfilled(value){
    console.log('fulfilled: ' + value);
  }, 
  function rejected(err){
    console.log('rejected: ' + err);
  }
);
//输出
p3 rejected: [object Promise]
p1 fulfilled: resolve
p2 rejected: reject
```
Promise回调函数中的第一个参数resolve，会对Promise执行"拆箱"动作。即当resolve的参数是一个Promise对象时，resolve会"拆箱"获取这个Promise对象的状态和值，但这个过程是异步的。p1"拆箱"后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2"拆箱"后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。


### Promise的实现
1. Promise接受一个函数，并且函数立即执行
```javascript
const isFunction = function(handle){
    return typeof handle === 'function'
}
//es5
function Promise(handle){
    //传入的必须是函数
    if(!isFunction(handle)){
        throw new Error("");
    }
    handle();
}
//es6
class Promise{
    constructor(handle){
        if(!isFunction(handle)){
            throw new Error("");
        }
    }
    handle();
}
```
#### promise的状态
2. Promise具有三个状态:resolved,rejected,pending,状态只能由pending->resolved或者pending->rejected,并且修改状态后，不会发生变化。  
- 状态是由resolve或者reject函数改变的。
- Promise的值是传入resolve和reject函数的值。

所以Promise应该有一个状态属性，一个值属性，并且需要向handle传入resolve和reject函数

```javascript
//定义状态常量
const PENDING = "pending";
const FULFILLED = "resolved";
const REJECTED = "rejected";

//es5实现
function Promise(handle){
    if(!isFunction(handle)){
        throw new Error();
    }
    this.status = PENDING;
    this.value = void 0;
    //这里有两点要注意，第一点是函数执行时出现错误，catch到的错误应该用reject处理
    try{
        //第二点，因为this是动态作用域，resolve和reject中的this应该指向当前Promise实例，所以这里用bind绑定了this为Promise实例
        handle(this.resolve.bind(this),this.reject.bind(this));
    }catch(err){
        this.reject.call(err);
    }
}

Promise.prototype.resolve = function(result){
    if(this.status !== PENDING){
        return;
    }
    this.status = FULFILLED;
    this.value = result;
}
Promise.prototype.reject = function(result){
    if(this.status !== PENDING){
        return;
    }
    this.status = REJECTED;
    this.value = result;
}

//es6

class Promise{
    constructor(handle){
        if(!isFunction(handle)){
            throw new Error("");
        }
        this.status = PENDING;
        this.value = void 0 ;
        try{
            handle(this.resolve.bind(this),this.reject.bind(this));
        }catch(err){
            this.reject(err);
        }
    }
    resolve(result){
        if(this.status !== PENDING){
            return;
        }
        this.status = FULFILLED;
        this.value = result;
    }
    reject(result){
        if(this.status !== PENDING){
            return;
        }
        this.status = REJECTED;
        this.value = result;
    }
}
```

#### promise的then方法
3. 链式调用,Promise的then方法
- then方法可以链式调用，意味着then返回的是一个promise
- then方法接受两个参数onFulfilled和onRejected
    - 都是可选参数,如果不是函数会被忽略
    - 当promise状态改变时，根据状态调用onFulfilled(resolve)和onRejected(reject),并传入值
- then返回的Promise,将由onFullfilled或者onRejected的返回值决定
    - 假设返回值不是Promise,则返回值作为新返回的Promise对象的值
    - 假设返回值是Promise,这时下一个then中的回调会等待该Promise的状态发生变化后才会被调用，返回新的Promise对象的值最终状态和返回值的Promise一致
    - 如果onFullfiled或者onRejected抛出异常或者返回异常，则返回的Promise状态修改为rejected，并将异常值作为Promise的值
    - 如果onFulfilled和onRejected不是函数，生成的Promise则根据上一个Promise的状态来设置值和状态。
```javascript
then(onFulfilled,onRejected);
//链式调用
var promise2 = promise1.then(onFulfilled,onRejected);
promise2.then(onFulfilled,onRejected);
```
then返回Promise的例子：

```javascript
var promise1 =  new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve("success")
    },5000);
})


//假设返回值不是Promise,则返回值作为新返回的Promise对象的值
//等待执行后变成Promise{[[PromiseStatus]]:'resolve',[[PromiseValue]]:'string'}
var promise2 = promise1.then((res)=>{
    //返回非Promise值
    return 'string'
});

promise2.then((res)=>{
    //string
    console.log(res);
})

//假设返回值是Promise,这时下一个then中的回调会等待该Promise的状态发生变化后才会被调用，返回新的Promise对象的值最终状态和返回值的Promise一致
var promise3 = promise1.then((res)=>{
    //返回promise
    return new Promise((resolve,reject)=>{
        resolve("返回Promise");
    });
});

promise3.then((result)=>{
    //返回Promise
    console.log(result);
});

var promise5 = new Promise((resolve,reject)=>{
    resolve("promise5");
});

//一开始PromiseValue为Undefined，Promise1中resolve后，会变成promise5
var promise6 = promise1.then((res)=>{
    return promise5;
})

//false
console.log(promise6 === promise5);


//如果onFufilled或者onRejected在执行过程中异常或者返回异常，则修改Promise状态为rejected，值为返回的异常
var promise7 = promise1.then((res)=>{
    throw new Error("异常e");
})
promise7.then((res)=>{

},(err)=>{
    console.log(err); //值为异常e的异常
})

//如果onFulfilled和onRejected不是函数，生成的Promise则根据上一个Promise的状态来设置值和状态
//Promise{[[PromiseValue]]:'success',[[PromiseStatus]]:resolved}
promise8 = promise1.then("onFulfilled是字符串");
promise8.then(()=>{

})
```
进一步修改Promise的构造函数，then中接收回调函数的过程，类似于事件监听，只是这个时候监听的是状态，如果状态发生了改变，则执行回调函数。
所以我们可以维护两个队列，一个是fulfilled队列，一个是rejected队列
```javascript
//es5
function Promise(handler){
    if(!isFunction(handler)){
        throw new Error("");
    }
    this.status = PENDING;
    this.value = void 0;
    //维护两个队列
    this.fulfilledQueues = [];
    this.rejectedQueues = [];
    try{
        handler(this.resolve.bind(this),this.reject.bind(this));
    }catch(err){
        this.reject(err);
    }
}
Promise.protoype.then = function(onFulfilled,onRejected){
    //根据当前状态，如果状态为Pending，则推入队列
    //如果状态为FULFILLED，则立即执行onFulFilled
    //如果状态为REJECTED.则立即执行onRejected   
    switch(this.status){
        case PENDING:
            this.fulfilledQueues.push(onFulFilled);
            this.rejectedQueues.push(onRejected);
            break;
        case FULFILLED:
            onFulfilled(this.value);
            break;
        case REJECTED:
            onRejected(this.value);
            break;        
    }
    //返回一个新的Promise对象
    return new Promise(function(){

    });
}

//es6
class Promise{
    constructor(handler){
        if(!isFunction(handler)){
            throw new Error();
        }
        this.status = PENDING;
        this.value = void 0;
        this.fulfilledQueues = [];
        this.rejectedQueues = [];
        try{
            handler(this.resolve.bind(this),this.reject.bind(this))
        }catch(err){
            this.reject(err);
        }
    }
    then(onFulfilled,onRejected){
        const { value,status } = this;
        swtich(status){
            case PENDING:
                this.fulfilledQueues.push(onFulfilled);
                this.rejectedQueues.push(onRejected);
                break;
            case FULFILLED:
                onFulfilled(value);
                break;
            case REJECTED:
                onRejected(value);
                break;       
        }
        return new Promise(()=>{

        })
    }
}

```
then函数应该返回一个Promise，Promise对象的状态依赖于当前回调函数执行的情况以及返回值。  
根据规则进一步完善then:
```javascript
then(onFulfilled, onRejected) {
    //then方法要做两件事，一件是根据当前promise的状态来决定是否推入回调队列
    //二是返回一个新的Promise
    //返回的Promise的状态由回调函数决定
    return new MyPromise((resolve, reject) => {
        //当前promise状态为FULFILLED的回调
        let fulfilledHanlder = function (value) {
            //如果当前promise为FULFILLED状态
            //执行onFulfilled查看其返回值来决定返回的Promise
            //但是当onFulfilled不为函数的时候，则直接按照当前Promise的值作为结果
            if (typeof onFulfilled !== 'function') {
                resolve(value)
            } else {
                try {
                    //执行onFulfilled
                    let res = onFulfilled(value);
                    //如果返回值是promise，则等待promise来决定
                    if (res instanceof MyPromise) {
                        res.then(resolve, reject);
                    } else {
                        resolve(res);
                    }
                } catch (err) {
                    reject(err);
                }
            }
        }
        let rejectedHandler = function (error) {
            //如果当前promise为FULFILLED状态
            //执行onFulfilled查看其返回值来决定返回的Promise
            //但是当onFulfilled不为函数的时候，则直接按照当前Promise的值作为结果
            if (typeof onRejected !== 'function') {
                reject(error)
            } else {
                try {
                    let res = onRejected(error);
                    //如果返回值是promise，则等待promise来决定
                    if (res instanceof MyPromise) {
                        res.then(resolve, reject);
                    } else {
                        reject(res);
                    }
                } catch (err) {
                    reject(err);
                }
            }
        }
        //根据状态来决定是否立即执行
        switch (this.status) {
            case PENDING:
                this.fulfilledQueues.push(fulfilledHanlder);
                this.rejetedQueues.push(rejectedHandler);
                break;
            case REJECTED:
                rejectedHandler(this.value);
                break;
            case FULFILLED:
                fulfilledHanlder(this.value);
                break;
        }
    })
}

```
#### promise的resolve和reject
4. 进一步完善resolve和reject,resolve此时的任务不仅仅是修改值和状态，还要执行回调函数队列中的函数。  

但是要注意一点，如果resolve中传递的是一个promise,当前promise的状态和值则由resolve传递的promise决定，例如：

```javascript
let p1 = new Promise((resolve,reject)=>{
})
let p2 = new Promise((resolve,reject)=>[
    resolve(p1);
])
```
由于p2中resolve(p1)，则p2要等待p1执行完毕后，将其结果作为p2的结果，根据p1的结果来决定调用onFulFilled还是onRejected:
```javascript
resolve(value){
    if(this.status!==PENDING){
        return;
    }
    let onFullfiled = function(result){
        while(let cb = this.fulfilledQueues.shift()){
            cb(result);
        }
    }
    let onRejected = function(err){
        while(let cb = this.rejectedQueues.shift()){
            cb(err);
        }
    }
    if(value instanceof Promise){
        value.then((result)=>{
            this.status = FULFILLED;
            this.value = result;
            onFullfiled(result);
        },(error)=>{
            this.status = REJECTED;
            this.value = error;
            onRejected(error)
        })
    }else{
        this.status = FULFILLED;
        onFullfiled(result);
    }
}

```
***所以即使调用了resolve,也不一定会调用其onFulfilled的回调，因为resolve(promise1)的话，当前promise依赖resolve传递的promise1的值，如果promise1的status为REJCTED，则promise也会变成REJCTED***

reject方法没有此特性，所以它的功能就是修改status和value,执行reject的回调
```javascript
reject(error){
    if(this.status !== PENDING ){
        return false;
    }
    this.status = REJECTED;
    this.value = error;
    while(let cb = this.rejectedQueues.shift()){
        cb(error);
    }
}

```
#### promise的catch方法
***根据MDN中的介绍，catch方法实质上就是调用了then(undefined,onRejected)***
问题：then(undefined,onRejected)明明是接受上一个promise的rejected，为什么能够接收链式调用中的rejected和异常？
```javascript
new Promise((resolve,reject)=>{
    reject('err')
}).then(()=>{
}).then(()=>{
}).catch((error)=>{
    //err
    console.log(error)
});
```
***then(undefined,onRejected)能够接受链式调用中的rejected和异常的前提条件是：异常没有被拦截***

在上面的例子中，其余的then方法都没有设置onRejected，根据then返回Promise的规则，Promise依赖onRejected的返回值，但是then方法中的onRejected没有设置，则取上一个Promise的值作为reject的结果。

上面例子等同于下面的例子：
```javascript
let p1 = new Promise((resolve,reject)=>{
    reject('err');
});
//实际上p2为Promise{[[PromiseStatus]]:rejected,[[PromiseValue]]:err}
let p2 = p1.then(()=>{
});
//依旧没有onRejected函数，p3为Promise{[[PromiseStatus]]:rejected,[[PromiseValue]]:err}
let p3 = p2.then(()=>{ 
})
let p4 = p3.then(undefined,(err)=>{
    //'err'
    console.log(err);
})
```

#### Promise的resolve、reject方法(静态函数)
根据上面所提到的Promise.resolve(value):
- 如果value为promise，则直接返回这个promise
- 如果value为普通值，则返回一个新的Promise,则为value,状态为Fulfilled

```javascript
class Promise{
    static resolve(value){
        if( value instanceof Promise){
            return value;
        }else{
            return new Promise((resolve,reject)=>resolve(value));
        }
    }
}
```
Promise.reject(value)不管value是什么直接返回一个新的Promise,并将value作为值
```javascript
class Promise{
    static reject(value){
        return new Promise((resolve,reject)=>reject(value));
    }
}
```

#### Promise的all方法(静态函数)
Promise.all([p1,p2,p3]),接受一个数组，返回一个Promise。
- 数组内的成员可以是任意值，如果是Promise的实例，则等待Promise执行完毕后传入对应的value数组
- 如果是其他值，则直接传入value数组
- 如果p1、p2、p3其中有一个为rejected，则Promise的值为reject值，并且status为Rejected

```javascript
class Promise{
    static all(list) {
        //执行list中的Promise返回一个新的Promise值为这两个Promise的值，如果不为Promise，直接resolve,为Promise则等待其执行结果
        return new MyPromise((resolve, reject) => {
            let value = [];
            let count = 0;
            for (let [index, p] of list.entries()) {
                //这里采用this.resolve，由于all也是静态方法，this指向MyPromise
                //MyPromise.resolve一定会返回一个MyPromise的实例，并且处理了p不为MyPromise的情况
                this.resolve(p).then((res) => {
                    value[index] = res;
                    //利用闭包记录
                    count++;
                    //这里不能用index === list.length-1判断，因为该回调的执行不一定按顺序
                    if (count === list.length) {
                        resolve(value);
                    }
                }, (error) => {
                    //有一个reject，则直接返回reject
                    reject(error);
                })
            }
        })
    }
}

```

#### Promise.race方法(静态函数)
Promise.race([p1,p2]),结果由p1、p2中先改变状态的Promise决定
```javascript
class Promise{
    static race(list){
        return new Promise((resolve,reject)=>{
            let value;
            for(let [index,p] of list.entries()){
                this.resolve(p).then(res=>{
                    resolve(res)
                },err=>{
                    reject(err)
                });
            }
        })
    }
}

```

#### promise.finally方法（原型函数）
finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作

```javascript
finally (cb) {
  return this.then(
    value  => MyPromise.resolve(cb()).then(() => value),
    reason => MyPromise.resolve(cb()).then(() => { throw reason })
  );
};
```

### Promise完整代码

```javascript
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";
class MyPromise {
	constructor(handler) {
		this.status = PENDING;
		this.value = void 0;
		this.fulfilledQueues = [];
		this.rejetedQueues = [];
		try {
			handler(this.resolve.bind(this), this.reject.bind(this));
		} catch (err) {
			this.reject(err);
		}
	}
	resolve(result) {
		//resolve完成以下工作：
		//修改状态
		//修改值
		//执行未执行的回调
		//由于resolve在接收promise的情况下，需要等待promise的值来修改当前promise的值
		let fulfilledHanlder = function (value) {
			let cb;
			while (cb = this.fulfilledQueues.shift()) {
				cb(value);
			}
		}
		let rejectedHandler = function (err) {
			let cb;
			while (cb = this.rejetedQueues.shift()) {
				cb(err);
			}
		}
		if (this.status !== PENDING) {
			return;
		}
		if (result instanceof MyPromise) {
			result.then((res) => {
				this.status = FULFILLED;
				this.value = res;
				fulfilledHanlder(res);
			}, (error) => {
				this.status = REJECTED;
				this.value = error;
				rejectedHandler(error);
			})
		} else {
			this.status = FULFILLED;
			this.value = result;
			fulfilledHanlder(result);
		}
	}
	reject(error) {
		if (this.status !== PENDING) {
			return;
		}
		this.status = REJECTED;
		this.value = error;
		let cb;
		while (cb = this.rejetedQueues.shift()) {
			cb(error);
		}
	}
	then(onFulfilled, onRejected) {
		//then方法要做两件事，一件是根据当前promise的状态来决定是否推入回调队列
		//二是返回一个新的Promise
		//返回的Promise的状态由回调函数决定
		return new MyPromise((resolve, reject) => {
			//当前promise状态为FULFILLED的回调
			let fulfilledHanlder = function (value) {
				//如果当前promise为FULFILLED状态
				//执行onFulfilled查看其返回值来决定返回的Promise
				//但是当onFulfilled不为函数的时候，则直接按照当前Promise的值作为结果
				if (typeof onFulfilled !== 'function') {
					resolve(value)
				} else {
					try {
						//执行onFulfilled
						let res = onFulfilled(value);
						//如果返回值是promise，则等待promise来决定
						if (res instanceof MyPromise) {
							res.then(resolve, reject);
						} else {
							resolve(res);
						}
					} catch (err) {
						reject(err);
					}
				}
			}
			let rejectedHandler = function (error) {
				//如果当前promise为FULFILLED状态
				//执行onFulfilled查看其返回值来决定返回的Promise
				//但是当onFulfilled不为函数的时候，则直接按照当前Promise的值作为结果
				if (typeof onRejected !== 'function') {
					reject(error)
				} else {
					try {
						let res = onRejected(error);
						//如果返回值是promise，则等待promise来决定
						if (res instanceof MyPromise) {
							res.then(resolve, reject);
						} else {
							reject(res);
						}
					} catch (err) {
						reject(err);
					}
				}
			}
			//根据状态来决定是否立即执行
			switch (this.status) {
				case PENDING:
					this.fulfilledQueues.push(fulfilledHanlder);
					this.rejetedQueues.push(rejectedHandler);
					break;
				case REJECTED:
					rejectedHandler(this.value);
					break;
				case FULFILLED:
					fulfilledHanlder(this.value);
					break;
			}
		})
	}
	catch(callback) {
		return this.then(undefined, callback);
	}
	static resolve(value) {
		if (value instanceof MyPromise) {
			return value;
		} else {
			return new MyPromise((resolve, reject) => {
				resolve(value);
			})
		}
	}
	static reject(value) {
		return new MyPromise((resolve, reject) => reject(value));
	}
	static all(list) {
		//执行list中的Promise返回一个新的Promise值为这两个Promise的值，如果不为Promise，直接resolve,为Promise则等待其执行结果
		return new MyPromise((resolve, reject) => {
			let value = [];
			let count = 0;
			for (let [index, p] of list.entries()) {
				//这里采用this.resolve，由于all也是静态方法，this指向MyPromise
				//MyPromise.resolve一定会返回一个MyPromise的实例，并且处理了p不为MyPromise的情况
				this.resolve(p).then((res) => {
					value[index] = res;
					//利用闭包记录
					count++;
					//这里不能用index === list.length-1判断，因为该回调的执行不一定按顺序
					if (count === list.length) {
						resolve(value);
					}
				}, (error) => {
					//有一个reject，则直接返回reject
					reject(error);
				})
			}
		})
	}
	static race(list) {
		//只要有一个有返回结果，按照最快返回结果的promise作为新返回Promise的值
		return new Prommise((resolve, reject) => {
			for (let p of list) {
				this.resolve(p).then((res) => {
					resolve(res);
				}, (err) => {
					reject(err);
				})
			}
		})
	}
}

```


## 迭代器对象和生成器函数

### 迭代器对象
要了解迭代器和生成器，首先要了解可迭代协议
>可迭代协议：用来定义对象的迭代行为，例如，在一个for...of结构中，有哪些值可以被遍历到。一些内置类型同时是内置可迭代对象，并且有默认的迭代行为，例如Array、Map、Set、String、TypeArray、Arguments类数组对象、NodeList对象。

***为了成为可迭代对象，一个对象必须实现@@iterator方法，意味着对象或者它的原型链上的某个对象，必须要有一个名为@@iterator的方法,可以通过常量Symbol.iterator访问该属性.***

当一个对象需要被迭代的时候，例如被放置到一个for...of循环时，首先会不带参数的调用它的@@iterator方法（来获取迭代器），然后用此方法返回的迭代器获取要迭代的值。


***只有实现了一个拥有以下语义的next()方法，一个对象才能成为迭代器***

next方法必须返回一个对象，该对象有两个属性：done和value，如果返回了一个非对象值(例如false或者undefined)(在被当做迭代器访问的时候),则会抛出一个TypeError异常。  
done:如果迭代器可以产生序列中的下一个值，则为false，如果序列迭代完毕，则为true。  
value:任意值，done为true时可以省略

这意味着创造一个迭代器需要满足两个条件:
- 拥有特定规则的next方法
- 拥有一个名为Symbol.iterator的方法

```javascript
var myIterator = {
    next:function(){},
    [Symbol.iterator]:function(){return this}
}
```
不一定要返回this，但一定要返回一个迭代器对象，例如：
```javascript
class SimpleClass {
  constructor(data) {
    this.data = data
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.data.length) {
          return {value: this.data[index++], done: false}
        } else {
          return {done: true}
        }
      }
    }
  }
}

const simple = new SimpleClass([1,2,3,4,5])

for (const val of simple) {
  console.log(val)   //'1' '2' '3' '4' '5' 
}
```

使用内置对象String的迭代器:
```javascript
let str = 'hello';
//访问迭代器
let iterator = str[Symbol.iterator]();

iterator.next().value; //'h'
iterator.next().value; //'e'
iterator.next().value; //'l'
iterator.next().value; //'l'
iterator.next().value; //'o'

```

#### 用于可迭代对象的语法
一些语句和表达式适用于可迭代对象，例如for...of循环、展开语法、yield*和结构赋值。
```javascript
for(let value of ['a','b','c']){
    console.log(value);
}

[..."abc"];//['a','b','c']

function* gen(){
    yield* ['a','b','c'];
}
gen().next();//{value:'a',done:false}

[a,b,c] = new Set(["a","b","c"]);
a// "a"
```

#### 自定义可迭代对象
```javascript
let iteratorObject = (function(){
    let value = 0;
    return {
        next:function(){
            if(value < 10){
                value++;
                return {value,done:false}
            }else{
                return {done:true}
            }
        },
        [Symbol.iterator]:function(){
            return this;
        }
    }
})()
```
通过yield可以定义每次迭代过程产生的值
```javascript
var myIterator = {
    [Symbol.iterator]:function* (){
        yield 1;
        yield 2;
        yield 3;
    }
};
[...myIterator];

```
### 生成器函数
>function*函数被称为生成器函数(generator function)。

虽然自定义的迭代器(对象)是一个有用的工具，但由于需要显式的维护内部状态(next方法)，所以要谨慎的创建，生成器函数提供了一个强大的选择，它允许定义一个包含自有迭代算法的函数，同时自动维护状态(不用写next方法)。

- ***生成器函数第一次调用时会返回迭代器，不执行任何代码***  
- ***通过调用生成器产生的迭代器next()方法来执行生成器代码，生成器代码会执行直到遇到yield关键字。***
- yield value等同于next方法中的return { value:value,done:false}
- 可以根据需要多次调用生成器函数，每次都会返回一个新的迭代器对象，每个迭代器只能迭代一次(直到done为true)


写一个生成器函数，能够生成一个在特定范围内迭代的迭代器
```javascript
function* makeRangeIterator(start = 0 ,end = Infinity ,step = 1){
    for(let i = start;i < end; i+= step ){
        yield 1;
    }
}

//生成一个1-10范围内迭代的迭代器
var a = makeRangeIterator(1,10,2);
a.next() // {value:1,done:false}
a.next() // {value:2,done:false}
a.next() // {value:3,done:false}
```

#### 生成器代码执行过程

```javascript
function* foo(){
    yield 'hello';
    console.log('world');
    yield  ',';
    return 'friend';
    yield  '。';
}
let fooIterator = foo();//代码不执行，生成迭代器
> fooIterator.next();
< {value:'hello',done:false}
> fooIterator.next();
  log: 'world'
< {value:',',done:false}
> fooIterator.next();
< {value:'friend',done:true}
> fooIterator.next();
< {value:'friend',done:true}
```
- 每次代码执行会遇到下一个yield停止，每次迭代的值由yield决定
- 如果遇到了return语句，代表迭代结束，无论后面还有没有表达式和yield语句，再次调用next方法，都只会返回{value:undefined,done:true}
- yield不能再普通函数内使用
- yield如果在表达式中，必须放在圆括号内

```
console.log('hello'+ (yield 123))
```


#### 生成器传参
给生成器generator传参的结果是，这个参数能在生成器函数的任何状态中读取到。
```
function* foo(x){
    console.log(x);
    yield 'step1';

    console.log(x);
    yield 'step2';

    console.log(x);
    return 'step3'
}

const fooIterator = foo("hello world");
```
无论在函数体的哪个状态，都能读取到x参数

#### 迭代器传参
> 生成器生成的迭代器可以用next方法传递参数。

***yield语句本身没有返回值，总是返回undefined。 ***
这是因为我们可以看yield value为next函数中的return {value,done:false}

这个时候我们需要知道上一个yield的返回值怎么办？***通过next传递的参数，可以作为上一个yield语句的返回值。***


从以下例子可以看出yield没有返回值
```javascript
function* foo(){
    let x = yield 10;
    console.log(x);
    return 'ending';
}

const fooIterator = foo();
> fooIterator.next();
< {value:10,done:false}
> fooIterator.next();
  log:undefined
< {value:'ending',done:true}
```
通过next传值作为上一个yield的返回值:
```javascript
function* foo(){
    let x = yield 10;
    console.log(x);
    return 'ending';
}

const fooIterator = foo();
> fooIterator.next();
< {value:10,done:false}
> fooIterator.next('hello world');
  log:'hello world'
< {value:'ending',done:true}
```
这里第二次调用next传递了'hello world'，作为yield 10表达式的返回值，所以x被赋值为'hello world';