<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-03-15 19:03:46
 -->
# 原型链继承
方法：子构造函数的prototype指向为父构造函数的实例,因为原型链是__proto__的链表,父构造函数的实例的__proto__指向父构造函数实例的原型。

```javascript
function Parent(){
    this.name = 'johe'
}

Parent.prototype.getName = function(){
    console.log(this.name)
}

function Child(){

}

//原型必须是对象，所以为Parent的实例
Child.prototype = new Parent()

var child1 = new Child()

child1.getName()

```
问题：
1. 引用类型的属性被所有实例共享
2. 创建Child的实例时，不能向parent传参
```javascript
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {

}

Child.prototype = new Parent();

var child1 = new Child();

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy", "yayu"]

```
***这是因为Parent在实例化之后，成为了Child的原型，原型上的属性和方法是共享的。***

# 借用构造函数(经典继承)
调用父构造函数
```javascript
function Parent(){
    this.names = ['kevin','daisy'];
}

function Child(){
    Parent.call(this);
}

var Child1 = new Child()

Child1.names.push('johe')

var Child2 = new Child()

//['kevin','daisy']
Child2.names

```
优点：
1. 避免了引用类型的属性被所有实例共享
2. 可以在Child中向Parent传参
缺点：
1. 方法都在构造函数中定义，每次创建实例都会创建一遍方法
2. instanceof检验为false

```javascript
function Parent(name){
    this.name = name;
}

function Child(name){
    Parent.call(this,name)
}

var Child1 = new Child('johe')

//johe 
Child1.name
```
# 组合继承（原型链继承和经典继承）
优点：借用构造函数继承解决了传参问题和实例属性被共享的问题，原型链继承能够满足共享方法不被重复创建。  
缺点：调用了两次父构造函数

```javascript
function Parent(name){
    this.name = name
    this.names = ['johe']
}

Parent.prototype.getName = function(){
    return this.name
}

function Child(name,age){
    //调用父级的构造方法，实现实例属性
    Parent.call(this,name)
    this.age = age
}

//这里不用参数是因为子构造函数调用父构造函数时已实现实例属性，有实例属性的情况下不会从原型链中查找
Child.prototype = new Parent()

var child1 = new Child('johe',18)
child1.names.push("johe2")
console.log(child1.name);//johe
console.log(child1.age);18
//["johe","johe2"]
console.log(child1.names);

var child2 = new Child('child2',19)
console.log(child2.name);//child2
console.log(child2.age);19
//["johe"]
console.log(child1.names);
```

# 原型式继承（Object.create）
Object.create的模拟实现

```javascript
function createObj(o){
    function F();
    F.protoype = o;
    return new F()
}
```
缺点：
包含引用类型的属性值始终都会共享响应的值，这点跟原型链继承一样。

# 寄生组合式继承（组合继承优化）
组合继承的最大缺点就是会调用两次父构造函数  
一次是设置子类型实例的原型：
```
Child.protoype = new Parent()
```
一次是创建子类型实例的时候:
```
function Child(name,age){
    Parent.call(this,name)
}

var child1 = new Child('johe',18)
```

这个时候Child.prototype这个对象内的属性其实是没用的，因为子类型实例已经调用了父构造函数进行了属性实例化。

所以就用到了寄生组合式继承，让Child.prototype间接的访问到Parent.prototype

```javascript
function Parent(name){
    this.name = name
    this.names = ['johe']
}
Parent.prototype.getName = function(){return this.name}

function Child(name,age){
    Parent.call(this,name)
    this.age = age
}

function F(){}

F.prototype = Parent.prototype

Child.prototype = new F()

var child1 = new Child('johe',18)
```

封装继承方法：
```javascript
function Parent(name){
    this.name = name
    this.names = ['johe']
}
Parent.prototype.getName = function(){return this.name}

function Child(name,age){
    Parent.call(this,name)
    this.age = age
}

function createObject(o){
    function F(){}
    F.prototype = o
    return new F();
}

function setPrototype(child,parent){
    var prototype = createObject(parent)
    prototype.constructor = Child
    Child.protoype = prototype
}

setPrototype(Child,Parent)
```
***这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式***

这里为什么不直接使用Child.prototype=Parent.prototype，是因为Parent.constructor应该指向Parent,并且如果我们需要给Child实例的原型设置方法和属性时，会影响到Parent的实例，这明显是不合理的。


# ES6的class继承
> ECMAScript6 引入了一套新的关键字用来实现 class。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不同的。JavaScript 仍然基于原型。这些新的关键字包括 class, constructor，static，extends 和 super。

```javascript
class Fruits{
    constructor(type,size){
        this.type = type;
        this.size = size;
    }
}

class Banana extends Fruits{
    constructor(type,size,color){
        super(type,size);
        this.color = color;
    }
}

```