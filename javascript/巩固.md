<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-07-07 15:45:57
--> 
# 基本数据类型和引用类型
基本数据类型：Number、String、Boolean、Null、Undefined、Symbol
引用类型：Object、Function、Date、Array、Reg、Math等等

基本数据类型存储在栈内存中，引用数据类型存储在堆内存中，引用数据类型的指针存储在栈内存中。
传参都是按值传参，基本数据类型传递的是值，引用类型传的是引用。

# typeof
基本类型中的Null会被typeof错误检测为Object,这是由于在进行存储的时候通常是数据类型+存储值进行存储的，Null的存储类型跟Object一样都是0.

引用类型中的function会被typeof检测为function。

# instanceof
instanceof检测构造函数的prototype是否在对象的原型链上。
```javascript
function instanceof(obj,constructor){
    let proto = obj.__proto__
    while(true){
        if(!proto){
            return false;
        }
        if(proto === constructor.prototype){
            return true;
        }
        proto = proto.__proto__
    }
}
```

# 类型检测的通用方法
Object.prototype.toString能够检测出大部分数据类型，但IE低版本可能会把Null的toString为Object，所以要对Null进行区分，针对基本数据类型，使用typeof来检测。
```javascript
function getType(data){
    if(data == null){
        return data + '';
    }
    const isReferenceType = typeof data === 'object'||typeof data ==='function';
    const stringType = Object.prototype.toString.call(data).slice(8,-1);
    return isReferenceType ?  stringType||"object" : typeof data;
}
```

# 赋值浅拷贝深拷贝
差别在引用类型上提现出来：赋值和被赋值对象指向同一引用，浅拷贝和深拷贝都是新的地址，但是如果引用类型的属性包含引用类型，浅拷贝指向同一地址，深拷贝指向新的地址。

浅拷贝实现：
- 判断是否为Null、基本数据类型，是的直接返回
- 根据类型创建一个新对象/数组
- 赋值旧对象的属性
```javascript
function shallowCopy(obj){
    if(obj == null){
        return obj;
    }
    if(typeof obj !== 'object'&&typeof obj !== 'function'){
        return obj;
    }
    let newObj;
    if(Array.isArray(obj)){
        newObj = [];
    }else{
        newObj = Object.create(null);
    }
    for(let property in obj){
        if(obj.hasOwnProperty(property)){
            newObj[property] = obj[property];
        }
    }
    return newObj;
}
```
深拷贝实现：
- 判断是否为Null、基本数据类型，是的直接返回
- 如果是引用类型，根据类型创建数组或者对象，对子属性进行深拷贝
```javascript
function deepClone(obj){
    if(obj === null){
        return obj;
    }
    if(typeof obj !== 'object' && typeof obj !=='function'){
        return obj;
    }
    let newObj;
    if(Array.isArray(obj)){
        newObj = [];
    }else{
        newObj = Object.create(null);
    }
    for(let property in obj){
        if(obj.hasOwnProperty(property)){
            newObj[property] = deepClone(obj[property]);
        }
    }
    return newObj;
}

```

# 静态作用域和动态作用域
差别：静态作用域，作用域是在定义时就决定的。动态作用域是在运行时决定的。

# 闭包
广义：广义上函数都是闭包，因为外部访问不到函数内的变量
狭义上的闭包：让外部能够访问函数的内部变量

闭包是依靠静态作用域实现的，因为函数在定义时存在[[scope]]变量，将外部的变量对象存储起来

# 执行上下文
执行上下文包含：变量对象、作用域链、this
包含全局上下文和函数上下文。
```javascript
function checkScope(){
    var a = 1;
    function f(){
        console.log(a);
    }
    return f();
}
checkScope()
/*
执行上下文变化
ECS[ globalContext ]
ECS[ globalContext,checkScopeContext]
ECS[ globalContext,checkScopeContext,fContext ]
ECS.pop();
ECS.pop();
ECS.pop();
*/
function checkScope(){
    var a = 1;
    function f(){
        console.log(a);
    }
    return f;
}
checkScope()();
/*
执行上下文变化
ECS[ globalContext ]
ECS[ globalContext,checkScopeContext]
ECS.pop();
ECS[ globalContext,fContext ]
ECS.pop();
ECS.pop();
*/
```
# 变量对象
变量对象是执行上下文的一个部分，包含当前作用域的形参、函数、变量。
```javascript
function checkScope(a){
    function b(){}
    var c = 1;
}
checkScope(1);
```
变量对象的变化分为两个阶段：分析和执行阶段,在被激活时变成活动对象AO
分析阶段：形参、函数、变量初始化，形参会被赋值为传递的值，函数被赋值为函数引用，变量被初始化为Undefined
在有同名参数的情况下，函数优先级>形参>变量，形参、函数、变量被创建和初始化，形参、函数被赋值，变量不会被赋值
```javascript
checkScopeContext = {
    AO:{
        arguments:{
            a:1,
            length:1
        },
        b:reference to function b,
        c:undefined
    }
}
```
执行阶段：逐步赋值变量
```javascript
checkScopeContext = {
    AO:{
        arguments:{
            a:1,
            length:1
        },
        b:reference to function b,
        c:1
    }
}
```

下面的代码会报错，因为在执行console.log(a)的时候，从自己的变量对象中找不到a，顺着作用域链从全局也找不到a
```javascript
function foo(){
    console.log(a);
    a = 1;
}
foo();//???
```
下面的代码会输出undefined，在执行console.log(a)时，a在分析阶段已经被创建和初始化为undefined
```javascript
function foo(){
    console.log(a);
    var a = 1;
}

```
# 作用域链
作用域链是一个包含变量对象的链表，作用域链也是执行上下文的一部分。
```javascript
var scope = "global scope";
function checkscope(a){
    var scope2 = 'local scope';
    function b();
    return scope2;
}
checkscope(1);

/*
globalContext = {
    VO:[global,checkscope,scope],
    Scope:[globalContext.VO],
    this:global
}
ECS = [ globalContext ];
checkscope.[[scope]] = [globalContext];
checkscopeContext = {
    AO:{
        arguments:{
            length:1,
            a:1
        },
        b: reference to function b,
        scope2:undefined
    },
    Scope:[AO,...checkscope.[[scope]]],
    this:global
}

checkscopeContext = {
    AO:{
        arguments:{
            length:1,
            a:1
        },
        b: reference to function b,
        scope2:'local scope'
    },
    Scope:[AO,...checkscope.[[scope]]],
    this:global
}
ECS = [checkscopeContext,globalContext];
*/
```
变量通过执行上下文中的作用域链进行查找。

# 什么是块级作用域
块级作用域就是除了全局作用域、函数作用域之外的作用域。  
块级作用域的特点：拥有暂时性死区(在初始化前不能被使用)，也就是在块级作用域的变量对象里，分析阶段被创建但未被初始化。

块级作用域通常是为了解决在循环内没有块级作用域带来的困扰：
```javascript
var list = []
for(var  i =0 ;i<10;i++){
    list[i] = function(){
        console.log(i);
    }
}
list.forEach((func)=>{
    //输出10
    func();
})
```
这是由于JS采用静态作用域，函数的作用域在定义时就决定了，等到函数执行的时候，外部作用域的i已经变成了10，所以输出10
通过块级作用域解决:
```javascript
var list = []
for(let i =0 ;i<10;i++){
    list[i] = function(){
        console.log(i);
    }
}
list.forEach((func)=>{
    //0-9顺序输出
    func();
})
```
相当于
```javascript
var list = []
for(var i =0 ;i<10;i++){
    (function(i){
        list[i] = function(){
            console.log(i);
        }
    })(i)
}
list.forEach((func)=>{
    //0-9顺序输出
    func();
})
```
相当于使用闭包，匿名函数的变量对象保存在list函数内，list函数通过访问匿名函数的变量对象得到值，类似于闭包。


# 变量提升
变量提升意味着变量在函数分析阶段就被变量创建了。实际上函数声明、形参、var、let、const都存在变量提升。

变量对象的创建分为解析阶段和执行阶段，解析阶段函数声明、形参、var、let、const都被创建了，但是let和const没有进行初始化，在执行阶段才会被初始化。