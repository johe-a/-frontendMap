<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-05-25 23:42:17
--> 
# 前言
这一部分涉及到的计算机基础知识较多较枯燥，参考了大部分的资料，主要是探讨整数加减乘除和浮点数加减法运算

原码、反码、补码，以及他们出现的意义（了解这个有利于了解二进制的正数和负数的表示，以及二进制加减法）
https://zhuanlan.zhihu.com/p/36036038

二进制加减乘除和溢出：
https://juejin.im/post/5d2d8ef4f265da1bb2776480

浮点数的科学计数法
浮点数为什么会精度丢失，以及大数吃小数的现象：
https://juejin.im/post/5d6e74c35188254628237d5d

0.1+0.2为什么不等于0.3:
https://juejin.im/post/5d36effa6fb9a07eb15d9686


# 整数十进制和二进制的互相转换
来看一个十进制转八进制的例子：(十进制的100转八进制),通过不断的除以8求余数,直到商为0
```
100/8 = 12  余4(这意味着八进制的第一位为4)
12/8 = 1    余4(第二位为4)
1/8 = 0     余1(第三位为1)

即(100)10  =  (144)8     


100转换为二进制: 
100/2=50....(余数为0); 
50/2=25.....(余数为0); 
25/2=12.....(余数为1); 
12/2=6......(余数为0); 
6/2=3.......(余数为0); 
3/2=1.......(余数为1); 
1/2=0.......(余数为1);
即1100100
```
**我的理解是,每次除以2的过程就像100的二进制数往右移动过程，每次右移一位，直到为零，余数就是每次移位的值**

# 整数的编码方式(不包括小数，针对int和char类型)
需要记住这一点：
>所有编码系统的设计，都在追求连续性和唯一性。
>原码，反码和补码的演化，就在不断提高整数编码的这两方面性能。

- 原码是整数的一种简单的表示法，符号位用0表示正号，用1表示负号，数值一般用二进制形式表示。
- 反码可由原码得到，如果是正数，则反码与原码一样；如果是负数，则反码是对它的原码（符号位除外）各位取反而得到的。
- 补码可由原码得到。如果是正数，则补码与原码一样；如果是负数，则补码是在反码基础上，末位加1而得到。

## 原码
原码：原码表示法是整数的一种简单的表示法，符号位用0表示正号，用1表示负号，数值一般用二进制形式表示。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5ttd5r6ij30a80avgm1.jpg)

原码存在两个问题：
1. 两个重复的0
    - 0000 0000表示正0
    - 1000 0000表示负0
2. 两个间断点
    - 0111 1111表示的127再增加就变成1000 0000负0，即127突变为-0
    - 1111 1111表示的-127再增加变成0000 0000正0，即-127突变为+0

**间断点为什么不好？因为涉及到整个范围的数值连续性，任何的间断点都会导致溢出问题，所以间断点越少越好。**

## 反码
反码：正数的反码就是原码，负数的反码是原码除了符号位的按位取反。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u2j8xxgj309d0apdg8.jpg)

反码跟原码的差别在于它的复述是原码的取反，即现在反码的1000 0000代表原码的1111 1111的-127。也就是负数那部分图形反过来。

反码解决了原码的其中一个间断点（由于1111 1111代表-0，加一变成正0，所以解决了该间断点），但存在以下问题：
1. 还是有重复0
    - 0000 0000表示正0
    - 1111 1111表示负0
2. 存在一个间断点(不能再优化了)
    - 0111 1111的127突变到1000 0000的-127

## 补码
补码：正数的补码就是原码，负数的补码是原码除了符号位按位取反后末位加1。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5ufugviij30a4096dg5.jpg)


也就是负数那部分图形反过来之后再整体往下移动1，因为加了1，即1000 0000的补码是通过1000 0000的原码得到的，补码规定这个值为-128,这个时候-127原码为1111 1111补码为1000 0001。

可以看到通过这样的手段，就解决掉了重复的0。

**实质上，取反就是为了解决间断点问题，补位是为了解决重复0问题**


# 二进制整数的加减乘除
## 加减法计算
**二进制的计算过程没有减法，比如计算1-1 会被转化成 1+(-1)，实现一个减法的过程不是不可以，而是对计算机的成本太大，代价也很大，尤其要考虑到减数，被减数，以及结果的正负，转换成加上一个负数，可以统一计算过程（都是加法），大大减小了计算的复杂性。**


通过1+1、1+(-1)、(-1)+(-1)，来查看原码、反码、补码的计算

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5uonla6yj30lz0eoabb.jpg)

所有的求和，都可以看做是x轴的叠加，然后看y轴对应的值。

先看1+1，不管是原码，反码还是补码，都是1的二进制码横轴叠加，对应y轴为2
再看1+（-1）
原码：1对应1，-1对应中间位置，那两者叠加，肯定是-1向右移1个，也就是-2
反码：1对应1，-1对应末尾位置，那两者叠加，肯定是-1向右移1个，也就是-0
补码：1对应1，-1对应末尾位置，那两者叠加，肯定是-1向右移1个，回到原点是0
再看（-1）+（-1）
原码：-1对应中间位置偏右1位，那两者叠加，肯定是越界返回原点错2个，也就是2
反码：-1对应末尾位置偏左1位，那两者叠加，肯定是越界后末尾偏左2个，也就是-3
补码：1对应1，-1对应末尾位置，那两者叠加，肯定是-1向右移1个，回到原点是-2

再看看-100+(-100)的补码(由于是八位，所以已经溢出了)计算：

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5wqqobqdj30o80hojsg.jpg)


## 为什么会溢出
> 理论上N位二进制所能表达的数字一定是有限的，比如8位二进制的范围就是[-128, 127]，当计算到127的时候，+1 就会"跳"到-128，就像一个圆圈一样，一切都回到了原点重新开始，只是这个临界点不是“0”而是“127”和“-128”，所以，溢出是一定会出现的，当计算结果超出当前range范围，就会产生溢出的行为，理解这个行为，我们要先理解“模”这个概念。

假如给一个钟表，因为钟表的范围一共就是12个格子，所以“12”就是它的“模”，超过12就会重新计算，这种现象，就是“溢出”，在看下面的例子：假如现在时针在2点的位置，如果我想要他变为6点，有几种办法，理论上有N种，我可以不停的旋转然后再回来，我们讨论最基本的，其实是2种，正向走过4个格子，到6，这就是 2 + 4 = 6；还可以反向走 8 个格子，[2>1>12>11>10>9>8>7>6] ，会发现一个绝妙的点：4+8=12，同时，4和8就是对于“模”12的一对补数，在钟表上我们可以看出来2-8==2+4 往后退8个就等于往前走4个，也就是说，在“模”运算中，x-y==x+y的补数，回到二进制，二进制的计算和钟表的计算是非常像的，8位二进制的“模”就是256，从[0-127]以及[-1,-128]，各有128位数字，到达临界点的时候就会break到下一个原始的点，比如从-128 再走就回到 +127，从+127再走就到了-128.

例如以下C++代码:
```c++
#include <stdio.h>

int main(void)
{
    char a, b;
    char c;

    a = 127;
    b = 1;
    c = a + b;

    printf("c=%d", c);

    return 0;
}
```
由于char是八位的，表示范围在[-128,127],所以上面的代码输出为-128,因为超过了127，溢出到了-128

但是如果我们将c换成十六位的short,就能解决溢出问题：
```c++
#include <stdio.h>

int main(void)
{
    char a, b;
    short c;

    a = 127;
    b = 1;
    c = a + b;

    printf("c=%d", c);

    return 0;
}
```

## 二进制乘法
我们知道二进制只有加法，没有乘法，那么二进制是如何进行乘法运算的呢。

先抛出一个结论：**计算机的乘法是依靠移位和加法来运算的**

> 在十进制的世界里，如果我们要算900*10 = 9000,实质上就是900往左移了一位，换到二进制里面也是类似，如果我们
> 要计算二进制0100 * 0010(二进制的2)，实质上就等同于0100左移一位等于1000 
> 如果我们要算十进制的9*110，其实就等同于计算9x10^2+9x10^1,等同于9左移两位加上9左移一位的和
> 10进制中，我们的乘数有可能不是10的整数次幂，例如9*5之类的，但是二进制下，所有的数字都能以2的整数次幂表示
> 例如我们要计算0100*0111,等同于0100x2^2+0100x2^1+0100x2^0，实际上就是0100左移两位加上0100左移一位再加上0100的和

|拆分|结果|
|---|---|
|0100*2^2|0001 0000|
|0100*2^1|0000 1000|
|0100*2^0|0000 0100|
|总和|0001 1100|

即4*7 = 28为二进制的0001 1100 

**所以计算2³最快的方式是2<<2**

## 二进制除法
先抛出结论，**二进制除法就是不断累加除数，直到除数大于被除数的过程**

例如计算19/3，19是被除数，3是除数，计算机只有加法，所以我们只能不断的通过加除数
- 19/3，除数<被除数，商加1，为1
- 19/(3+3)，加上除数，此时除数为6，小于19,商加1，为2
- 19/(3+3+3),商加1，为3
- ...
- 19/18,商加1,为6
- 19/21,退出，此时商为上一次的结果，余数为被除数-中间数(18),为1
即结果为6余1.  
从这个过程来看，可以知道除法需要寄存四个东西：除数、被除数、商、中间数  
**所以除法要用到四个寄存器：存放除数、被除数、中间数、商**，余数则用被除数-中间数。

所以运算速度：**位移>加减>乘>除**

## 总结
- 整数二进制都是以补码进行运算的
- 溢出是正常的，根据位数决定范围
- 计算机没有乘除减法，只有加法

# 定点数和浮点数
假设我们有32位的存储空间，如何用定点数和浮点数的方式来存储数字呢

## 定点数
如果我们1-24位用来表示整数位，其余8位来表示小数，整数部分每4位来表示0~9则整数位最多可以有6位，剩余2位表示小数部分。

那么32位定点数可以表示0到999999.99这样一亿个实数，这种用二进制来表示10进制的方式，叫做BCD编码。

定点数的缺点：
- 占了很大的位数，但是表示的数字范围却是有限的。
- 无法同事表示很大的数字和很小的数字

## 浮点数
想象下，假设红色区域是能放置的数字的最大空间：
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf670r0ni5j30h6075t93.jpg)

如果这个时候我们想要继续加0的时候，发现空间是有限的，这个时候我们就可以用**科学计数法**：
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf671ep8cwj30er07mmxc.jpg)

**就像使用科学计数法一样，浮点数的设计也用了一样的思想，IEEE的标准定义了2个基本的浮点格式，一个是32位的单精度浮点数，一个是64位的双精度浮点数**，即float/float32或者double/float64两个数据格式。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6742jqbdj30zk05f3yy.jpg)

浮点数的科学计数法分为三部分：
- 第一部分是符号位，用s表示，代表正负，1个比特。
- 第二部分是指数位，用e表示，代表指数，8个比特。
    - 0和255去掉头尾，用1~254去映射到-126~127，这样就可以表示最大和最小数字。
    - 0和255有特殊的含义。
- 第三部分是有效位，用f表示，代表的是有效的数位，23个比特。

如果是64位的，则位数分别为(s=1,e=11,f=52)：
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6anwh2tkj30ri04imyn.jpg)

也就是我们不直接存储浮点数，而是存储浮点数科学计数法之后的关键信息s、e、f。

**浮点数可以表示为公式**:
```
//这里的s、e、f、1.f都是二进制
(-1)^s * 1.f * 2^e
```
看完这个公式，会发现这个公式无法表示0，我们用指数位的0和255来表示一些特殊值：

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf67henwmlj30zk0e2aba.jpg)

以0.5为例，由于0.5是正数，所以s为0，f也是0,e是-1
```
0.5 = (-1)^0*1.0*2^-1
```
这里的指数位为-1，但是由于指数位没有用于表示符号的位，我们用的是1~254去表示-126~127的，所以0用127来表示，-1用126(-1+127)来表示

|s|e|f|
|---|---|---|
|0|0111 1110|000...0|
|1位|8位|23位|

通过这样的表示方式，可以明显发现32位所表示的实数范围是很大的。  
**因为这种方式创建的实数中小数点的位置是可以"浮动"的(通过指数位浮动)，所以也被叫做浮点数**


# 0.1+0.2!=0.3
要了解为什么0.1+0.2不等于0.3，首先要了解浮点数是如何存储和运算的。
浮点数的存储：
- 先转化为2进制
- 用科学计数法表示当前二进制，存储关键的s、e、f

## 浮点数的二进制转换
二进制(0.1001)转化为十进制时，我们可以按照小数点后每一位表示的是2的-N次方，因此十进制就是：  
```
//0.1001的二进制转十进制
(1*2^-1)+(0*2^-2)+(0*2^-3)+(1*2^-4) = 1/2 + 1/2^4 = 0.5625
```

一个十进制转二进制：
- 整数部分，除以2，直到商为0，看余数(我的理解是相当于右移，取移除的数)
- 小数部分，则是用一个相似的反方向操作，每次乘以2(相当于左移)，然后看是否大于1(大于1代表小数点后面还有值),如果大于1，就记1(表示当前位为1)，并把当前数减去1，用这个结果重复以上过程

小数部分可以拆分成以下步骤：
1. 每次乘以2，得到新的数a
2. 如果a < 1,则记当前位为0，因为如果当前位不为0，结果一定大于等于1
3. 如果a = 1,则记当前位为1，结束循环
4. 如果a > 1,则记当前位为1，为什么会大于1？因为后面还有数。所以用a-1得到当前的小数部分，重复以上步骤

则0.1转化为2进制的过程为：
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf69e494wsj30zk0gvq4z.jpg)

则会得到一个无限循环的部分"0011"，因此结果就是0.000110011...

则整数9.1表示为1001.000110011...

再用科学计数法表示则为1.001000110011...*2^3

则得到s = 0,f= 00100011001100110011001(到23位后自动舍弃，因为最长只能放23位有效数字)。  

指数位十进制为3，二进制的指数位e之前提到的，通过1~254对半分来表示-126~127，所以二进制1代表-126，二进制127代表0,所以3为二进制的130,二进制的结果是1000 0010,所以得到e=1000 0010.

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf69q2paevj30zk060my5.jpg)

如果我们再把这个浮点数转化成十进制，实际得到的准确值是9.09999942779541015625.


## 浮点数的加法
浮点数的加法需要先对齐(指数位对齐)，然后按位相加(符号位和有效位)。

以0,5+0.125的计算为例，套用科学计数法
0.5的s=0,f=0,e=-1  
0.125的s=0,f=0,e=-3

这里0.5的指数位为-1,0.125的指数位为-3,则统一指数位为-1。  
则0.125的科学计数法 1x1.0x2^-3变化为1x0.01(1.0右移两位)x2^-1:

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6a3qlipej30y00fomy3.jpg)

结果就是1.25*2^-1 = 0.625;

## 大数吃小数
什么是大数吃小数？
> 由于浮点数的加法运算过程中，需要先对齐，但是有效数位的长度是23位，假如有一个很大的数字和一个很小的数字相加，在对齐的过程中，较小数的小数位在对齐过程中直接被丢掉了，从而导致结果上的误差。

js内置的Number是64位的，可以通过以下验证大数吃小数的现象：
```javascript
//1125899906842624，可以看到小数被忽略了
Math.pow(2,50) + 0.1
```
这是由于0.1的二进制为0.000110011...科学计数法表示为1.10011...*2^-4,则指数位为-4,有效位为10011...(总共52位)，而2的50次方代表着指数位为50,则0.1在对齐过程中需要将有效位往右移54位，超过了52位有效位，溢出为0,则0.1在对齐过程中由1.10011..x2^-4变成了0x2^50,结果为0，则相加为大数。

## 0.1+0.2!=0.3的原因
**从上已经可以知道，浮点数的小数部分在转化成二进制的时候，会存在无限循环的二进制数，但由于浮点数的有效位数(比如32位的就是23位的有效位)有限，所以存储的值只能是近似的，那么两个近似的值相加的结果，也一定是近似的。**

所以综上，0.1+0.2!=0.3的原因总结：
- 浮点数的小数点转化成二进制存在无限循环。
- 浮点数是按科学计数法的方式存储的，存在有效位，所以存储的值是近似的。

# 浮点数精度丢失问题解决
从上可知，0.1+0.2!=0.3实质上是精度丢失的问题:
- 浮点数小数转化成二进制可能存在无限循环的数
- 浮点数的存储方式是科学计数法，存在有效位，超出的会被截断，所以就存在了精度丢失问题

从上面介绍的可以知道，整数的加减乘除（本质上都是加法），没有精度丢失问题，只存在溢出问题。  

**所以我们可以通过将浮点数转化成整数再进行运算**

例如0.1+0.2，如果转化成(1+2)/10，则能够准确的输出0.3

浮点数的加法转化成整数加法：
```javascript
function floatAdd(arg1,arg2){
    //如果其中有一个不是数字，则返回原来的加法
    if(typeof arg1 !=='number' || typeof arg2 !=='number'){
        return arg1+arg2;
    }
    //分别记录arg1、arg2的小数点后位数，powMaxLength记录arg1和arg2的小数点较大位数，absolute记录两个小数点位数的绝对值
    let arg1FixedLength,arg2FixedLength,powMaxLength,absolute;
    try{
        arg1FixedLength =  arg1.toString().split(".")[1].length;
    }catch(e){
        arg1FixedLength = 0
    }
    try{
        arg2FixedLength = arg2.toString().split(".")[1].length;
    }catch(e){
        arg2FixedLength = 0;
    }
    powMaxLength = Math.max(arg1FixedLength,arg2FixedLength);
    powMax = Math.pow(10,powMaxLength);
    return (arg1*powMax + arg2*powMax) / powMax;
}

```