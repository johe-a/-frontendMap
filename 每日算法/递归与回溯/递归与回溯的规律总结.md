# 概念
> 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。
> 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。
> 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。
> 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。 ——LeetCode

重点关注，回溯算法的基本思想是:**从一条路往前走，能进则进，不能进则退回来，换一条路再试。**

这个回溯算法和之前学到的`DFS`，好像讲的是一件事情？这样想的话，`DFS`算法其实就是回溯思想的体现。

> 一般而言，"设计剪枝操作的递归，称之为回溯"。

# 解题模板
对于`全排列`、`组合`、`限定组合`这三道典型的递归与回溯算法题，解题方法是非常相似的。是不是意味着涉及递归回溯、或者说涉及`DFS`应用的题目，都有某种共同之处呢？会不会存在某种解题套路，可以帮助我们举一反三？

如何总结出一套解题模板？只需要搞清楚三个问题：
1. 什么时候用？（明确场景）
2. 为什么这样用？（提供依据）
3. 怎么用？（细化步骤）

## 什么时候用
两个特征：
1. 题目中暗示了一个或者多个解，并且要求我们详尽地列举出每一个解的内容时，一定要想到`DFS`与`递归回溯`。
2. 题目经过分析后，可以转化为树形逻辑模型求解。


## 为什么这样用
递归与回溯的过程，本身就是穷举的过程。题目要求我们列举出每一个解的内容，解从哪来？解是介于穷举思想、对搜索树进行恰当地剪枝后得来的。

> 这里需要注意另一种问法：不问解的内容，只问解的个数。这类问题往往不用`DFS`来解，而是用动态规划。


## 怎么用
- 一个模型：树形逻辑模型
- 两个要点：递归式和递归边界

树形逻辑模型的构建，关键在于找"坑位"，一个坑位就对应树中的一层。每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容。至于递归边界，要么在题目中约束得非常清楚、要么默认为“坑位”数量的边界。

大部分题解都符合以下特征：
```javascript
function xxx(入参) {
  前期的变量定义、缓存等准备工作

  // 定义路径栈
  const path = [];

  // 进入 dfs
  dfs(起点)

  function dfs(递归参数) {
    if (到达了递归边界) {
      结合题意处理边界逻辑，往往和 path 内容有关 
      return
    }

    for(遍历坑位的可选值) {
      path.push(当前选中值)
      处理坑位本身的相关逻辑
      path.pop()
    }
  }
}

```

# 经典例题分析

## 排列问题
> 从n个不同元素中任取m(m<=n)个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫做全排列。

任取的`m`个元素的排列，意味着`m`个元素都必须被选择，只是所在的顺序会有不同。我们要做的就是穷举这`m`个数的所有排列方式。

当我们看到这个熟悉的关键词`穷举`时，我们就能联想到`DFS`和递归。

> 在这个变化的序列中，变化的是数的位置，不变的是`m`个数的坑位，意味着每一个坑位都必须有一个数字去填充。

从一道真题入手：
```
题目描述：给定一个没有重复数字的序列，返回其所有可能的全排列。

示例：   
输入: [1,2,3]
输出: [
[1,2,3],
[1,3,2],
[2,1,3],
[2,3,1],
[3,1,2],
[3,2,1]
]
```
在这道题中，因为是全排列，`坑位`就是`3`个，我们必须往这三个坑位内填充数字，不管数字是哪个。

![坑位示意图](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a215aa6c68~tplv-t2oaga2asx-zoom-in-crop-mark:3780:0:0:0.awebp)

那么我们应该如何填充这三个坑位？
1. 面对第一个坑，我有三种选择，填1、2、3其中一个
2. 面对第二个坑，由于Step1中已经分出去1个数字，现在只剩下两个选择。比如如果step1中填进去的数字是1，现在就就剩下2、3。
3. 面对第三个坑，由于前面已经消耗了2个数字，此时我们手里只剩下1个数字了。

列举"路径"，我们首先要找到"坐标"，在这里题目里，坐标就是每一个坑里可能填进去的数字。

我们想象自己处于选坑的起点，起点应该是一个空坐标，叫做`root`:

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a215c76113~tplv-t2oaga2asx-zoom-in-crop-mark:3780:0:0:0.awebp)

然后我们开始选择第一个坑位的数字，现在我们面对三个数字，每选择一个数字都会影响下一个坑位的选择：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a21761dd46~tplv-t2oaga2asx-zoom-in-crop-mark:3780:0:0:0.awebp)

然后我们来到第二个坑位的数字，现在我们选择的数字是依赖于第一个坑位的选择的：
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a217acd94b~tplv-t2oaga2asx-zoom-in-crop-mark:3780:0:0:0.awebp)

终于我们走到了第三个坑，此时，我们的手里只剩下一个数字：
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a21bed6cbe~tplv-t2oaga2asx-zoom-in-crop-mark:3780:0:0:0.awebp)

> **对于每一个坑，像不像树形结构？根据坑的顺序，上一个坑会影响下一个坑的选择，这跟树的结构类似。**

从这个树结构里，我们可以清晰地看出，全排列的所有可能性。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a21d81055e~tplv-t2oaga2asx-zoom-in-crop-mark:3780:0:0:0.awebp)

以圆点为七点，以箭头为终点，起点和终点之前就是一个完整的排列。

我们的思维路径是一个树结构，但并不以为着我们需要真的在编码的时候去构造一棵树出来。需要什么？需要**递归!**

这道题的解答思路中也有一个非常关键的特征在提醒你往递归去向，那就是重复。

> 以后只要分析出重复的逻辑，就要往递归方向上想。

对于重复的内容，在递归中就是**递归式**。这个重复递归式的动作一直持续到了最后一个数字也被填进坑里为止——**"重复"的终点，就是递归边界**。

递归的编码实现，就是将递归式和递归边界翻译成代码，在实现时我们要利用栈来实现递归：
```javascript
const arr = [1,2,3];
// 记录所有排列结果
const result = [];
// 记录当前路径的栈
const curPath = [];
// 记录当前路径上已经选择过的数字
const visited = {};

function dfs(depth) {
  // 当前路径已经到达递归边界
  if (curPath.length === arr.length) {
    // 保存当前路径的副本而不是引用
    result.push(curPath.slice());
    return;
  }
  // 每一层都根据之前层已选择的数字筛选
  for(let i = 0; i < arr.length; i ++) {
    // 之前的坑位已选择当前数字，则跳过
    if (visited[arr[i]]) {
      continue;
    }
    // 深度优先遍历
    visited[arr[i]] = true;
    curPath.push(arr[i]);
    dfs(depth + 1);
    // 基于当前数字的深度优先遍历结束
    curPath.pop();
    visited[arr[i]] = false;
  }
}

// 从深度为0的地方开始选坑位
dfs(0);

console.log(result);

```

## 组合问题
给定一组不含重复元素的整数数组，返回该数字所有可能的子集（幂集），解集不能包含重复的子集。

```
示例: 输入: nums = [1,2,3]
输出:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]
```

这道题我们应该想到的是`穷举`出现了，大概率会用到`DFS`，只要用到`DFS`，就不得不想到树形思维方式，进而不得不思考**递归式**和**递归边界**问题。在这个思考过程中，最重要的一环就是对坑位的定位和分析，以及坑位内容的选择项。

**从上一道题不难看出，"坑位"对应的就是树形逻辑中树的某一层，"坑位数"往往意味着递归边界的限制条件。**

找`坑位`的思路是具有规律的，`坑位`往往是那些不会变化的东西。在上一题中，排列的顺序是变化的，而每个排列中数字的个数却是不变的。因此数字的个数就对应`坑位`的个数。在这题中。每个组合中数字的个数是不确定的，不变的东西变成了`可以参与组合的数字`。变化的东西是每个数字在组合中的`存在性`。因此我们的思路可以他调整为，从每一个数字入手，讨论出它出现或者不出现的情况。

**排列和组合的坑位个数都是确定的，都是参与排列或组合的数字个数。但是坑位的内容不一样，排列的重点是顺序，所以坑位的内容是选择的数字，坑位的内容会根据之前坑位选择的内容发生变化。而组合的重点是是否选择，所以坑位的内容是根据坑位的层次决定的，即是否选择当前层次的数字，之前坑位的选择不会影响后续坑位的内容**

我们仍然采取树形思维模型：
![树形思维模型](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a25410cf07~tplv-t2oaga2asx-zoom-in-crop-mark:3780:0:0:0.awebp)

- 递归式：是否选择当前坑位的数字
- 递归边界：组合里数字个数的最大值。拿示例来说，只给了3个数，因此组合里数字最多也只有3个，超过3个视为触碰递归边界。

```javascript
const arr = [1,2,3];
const result = [];
// 记录当前路径
const curPath = [];

function dfs(depth) {
  // 到达递归边界
  if (curPath === arr.length) {
    result.push(curPath.slice());
    return;
  }
  // 当前坑位的内容
  const curContent = arr[depth];
  // 选择当前坑位的内容
  curPath.push(curContent);
  dfs(depth + 1);
  // 不选择当前坑位的内容
  curPath.pop();
  dfs(depth + 1);
}

// 从第一个坑位开始选
dfs(0);

console.log(result);
```

## 限定组合问题：剪枝
题目描述：给定两个整数n和k，返回1...n中所有可能的k个数的组合。

```
示例: 输入: n = 4, k = 2
输出:
[
[2,4],
[3,4],
[2,3],
[1,2],
[1,3],
[1,4],
]
```
这是一道复杂化的组合问题，它追加了一个限定条件——只返回 n 个数中 k 个数的组合。在普通的组合问题中，树形逻辑是这样的：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a25410cf07~tplv-t2oaga2asx-zoom-in-crop-mark:3780:0:0:0.awebp)

其实和组合问题类似，只是边界条件转化了：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a254223576~tplv-t2oaga2asx-zoom-in-crop-mark:3780:0:0:0.awebp)

我们发现，只有双向箭头所指的结点组合被认为是有效结果，其它结点都被丢弃了。在寻找这三对结点组合的过程中，我们一旦找到一对，就停止继续往深处搜索，这就意味着一些结点压根没有机会被遍历到。

这其实就是“剪枝”的过程——在深度优先搜索中，有时我们会去掉一些不符合题目要求的、没有作用的答案，进而得到正确答案。这个丢掉答案的过程，形似剪掉树的枝叶，所以这一方法被称为“剪枝”。   

在这道题中，要做到剪枝，我们需要分别在组合问题的递归式和递归边界上动手脚：

- 递归式：当且仅当组合内数字个数为 k 个时，才会对组合结果数组进行更新。
- 递归边界：只要组合内数字个数达到了 k 个，就不再继续当前的路径往下遍历，而是直接返回。

```javascript
const arr = [1,2,3,4];
const k = 2;
const result = [];
// 记录当前路径
const curPath = [];

function dfs(depth) {
  // 到达递归边界
  if (curPath.length === k) {
    result.push(curPath.slice());
    return;
  }
  if (depth === arr.length) {
    return;
  }
  // 当前坑位的内容
  const curContent = arr[depth];
  // 选择当前坑位的内容
  curPath.push(curContent);
  dfs(depth + 1);
  // 不选择当前坑位的内容
  curPath.pop();
  dfs(depth + 1);
}

// 从第一个坑位开始选
dfs(0);

console.log(result);
```
  