/**
 * 给定一个数组nums和滑动窗口的大小k，请找出所有滑动窗口里的最大值
 * 例如输入：nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]
 * 解释: 滑动窗口的位置
 * ---------------
 * [1 3 -1] -3 5 3 6 7
 * 1 [3 -1 -3] 5 3 6 7
 * 1 3 [-1 -3 5] 3 6 7
 * 1 3 -1 [-3 5 3] 6 7
 * 1 3 -1 -3 [5 3 6] 7
 * 1 3 -1 -3 5 [3 6 7]
 */

/**
 * 思路一：使用双指针+遍历法，定义滑动窗口的起始指针和终止指针
 * 循环遍历，直到终止指针为最后一个数组成员，循环中取出当前窗口的最大值。
 * 时间复杂度O(kn)
 */

/**
 * 思路二：维护一个单调递减的双端队列
 * 双端队列以为着可以使用shift、unshift操作，也可以使用pop和push操作。
 * 1. 将当前元素与队尾元素相比
 *    a. 如果队尾元素比当前元素大，则当前元素直接插入。
 *    b. 如果队尾元素比当前元素小，则将队尾元素出队（从后出队），直到队尾元素比当前元素大，插入当前元素。
 * 2. 判断当前元素的下标范围，是否已经促使滑动窗口向后走一步（滑动窗口随着下标移动而移动），此时需要判断队头元素是否已经被排除在滑动窗口范围之外，如果是，则将队头元素出队。
 * 3. 重复上述过程直到下标到达数组末尾
 * 时间复杂度O(n)
 */
function maxSlidingWindow(nums: number[], k: number) {
  const length = nums.length;
  const result: number[] = [];
  const deque: number[] = [];
  for (let i = 0; i < length; i ++) {
    // 当前元素的大小比队尾大，则队尾出列
    while(deque.length && nums[deque[deque.length-1]] < nums[i]) {
      deque.pop();
    }
    // 插入当前元素下标
    deque.push(i);
    // 队头下标超过了当前窗口范围，队头出列
    if (i - deque[0] > k - 1) {
      deque.shift();
    }
    // 判断滑动窗口的状态，只有在遍历的元素个数大于k的时候才更新结果数组
    if (i >= k - 1) {
      result.push(nums[deque[0]]);
    }
  }
  return result;
}