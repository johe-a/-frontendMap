
## 目录

- [响应式系统](#响应式系统)
  * [监听(观察)数据](#监听(观察)数据)
  * [依赖(订阅者)收集](#依赖(订阅者)收集)
    + [实现一个订阅者的容器Dep(调度中心)](#实现一个订阅者的容器Dep(调度中心))
  * [观察者](#观察者)


## 响应式系统
>个人理解，响应式意味着数据的变更能够及时的响应，并且更新到依赖当前数据的视图上。

下面的图清晰地展示了整个流程，首先通过一次渲染操作来触发data中的getter(确保只有视图中被用到的data才会触发getter)进行依赖收集。
依赖收集就是依靠闭包中的Dep订阅者容器来收集订阅者，此时watcher和data像是形成了一种绑定。
data数据变化的时候会在setter中通过订阅者容器Dep来通知watcher进行视图更新。
wathcer再通知组件重新渲染，之后通过diff算法来决定视图的更新。

![响应式](https://tva1.sinaimg.cn/large/0082zybpgy1gc1ri3gpt5j30xc0kuq4q.jpg)

**Vue在初始化组件数据时，在生命周期中的beforeCreate和created钩子函数之间实现了对data、props、computed、methods、events、watch的处理，这就是为什么操作数据要在created生命周期之后**


可以将响应式分解成三个步骤：
- 数据的更改和读取可监听（Object.defineProperty）
- 依赖（订阅者）收集（获取具体的vue实例对当前数据的依赖）
- 数据更新后的响应（通知订阅者）

### 监听(观察)数据
>通过Object.defineProperty我们可以很容易监听到数据的读取和更改
```javascript
/*
  obj：目标对象
  property:目标对象的属性名
  descriptor:描述符
*/
Object.defineProperty(obj,property,descriptor)

```
descriptor描述符的属性：
  - enumerable:为true时，该属性才能够出现在对象的枚举属性中,默认为false,for in 以及Object.keys()无法获取
  - configurable:为true时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为false。
  - writable:为true时，value才能被赋值运算符改变。默认为false
  - value:该属性对应的值
  - get:定义getter
  - set:定义setter
  
  **如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。**

可以通过getter和setter来监听数据
```javascript
function observe(obj){
  if(!obj||typeof obj !=='object'){
    return 
  }
  for(let prop in obj){
    //如果当前属性对应的值是对象，递归监听
    //这里不考虑为数组的情况
    if(obj[prop]&&typeof obj[prop] === 'object'){
      observe(obj[prop])
    }
    defineReactive(obj,prop,obj[prop])
  }
}

function defineReactive(obj,prop,value){
  Object.defineProperty(obj,prop,{
      enumerable:true,
      configurable:true,
      get:function(){
        //在这里监听读操作
        return value
      },
      set:function(newValue){
        //在这里监听写操作
        value = newValue
      }
    })
}

class Vue{
  constructor(options){
    this._data = options.data()
    observe(this._data)
  }
}

```

### 依赖(订阅者)收集
>依赖(订阅者)收集帮助我们了解到哪一些vue实例使用了当前数据，在数据更新时我们就可以根据依赖来提醒哪些vue实例需要更新视图

例如:一个数据可能被多个vm实例的视图引用，当text1更新时，在视图层用到当前数据的实例需要更新视图
```javascript
let globalObj = {
    text1: 'text1'
};

let o1 = new Vue({
    template:
        `<div>
            <span>{{text1}}</span> 
        <div>`,
    data: globalObj
});

let o2 = new Vue({
    template:
        `<div>
            <span>{{text1}}</span> 
        <div>`,
    data: globalObj
});
```
**通过getter函数我们可以很清楚的知道依赖当前数据的实例**

```javascript
function defineReactive(obj,prop,value){
    ...
    Object.defineProperty(obj,prop,{
      ...
      get:function(){
        //在这里进行依赖收集
      }
    })
}
```

#### 实现一个订阅者的容器Dep(调度中心)
>哪个实例依赖了当前的数据，说明该实例需要订阅当前数据的更新，所以我们需要实现一个订阅者的容器，收集依赖当前数据的实例

![订阅者容器](https://tva1.sinaimg.cn/large/0082zybpgy1gc116d3zmmj31420ewjsi.jpg)

```javascript
class Dep{
  constructor(){
    //维护一个订阅者的数组
    this.subscribers = []
  }
  //增加订阅
  addSub(watcher){
    this.subscribers.push(watcher)
  }
  //通知所有订阅者视图更新
  notify(){
    this.subscribers.forEach((watcher)=>{
      watcher.update()
    })
  }
}

function defineReactive(obj,prop,value){
    //通过闭包维护value和Dep
    let Dep = new Dep()
    Object.defineProperty(obj,prop,{
      ...
      get:function(){
        //在这里进行订阅者收集
        Dep.addSub(watcher)
      },
      set:function(newValue){
        if(newValue!==value){
          value === newValue
          //通知订阅者
          Dep.notify()
        }
      }
    })
}
```

### 观察者
>已知我们可以在setter中，通过订阅者的容器Dep来通知订阅者。每一个订阅者都是观察者的实例

```javascript
class Watcher{
  constructor(){
    //存放当前Wathcer实例到Dep中
    Dep.target = this
  }
  update(){
    //调用视图刷新
  }
}
```

数据响应式完整代码(粗略版)
```javascript
function observe(obj){
  if(!obj||typeof obj !=='object'){
    return 
  }
  for(let prop in obj){
    //如果当前属性对应的值是对象，递归监听
    //这里不考虑为数组的情况
    if(obj[prop]&&typeof obj[prop] === 'object'){
      observe(obj[prop])
    }
    defineReactive(obj,prop,obj[prop])
  }
}

function defineReactive(obj,prop,value){
 //通过闭包维护value和Dep
  let Dep = new Dep()
  Object.defineProperty(obj,prop,{
      enumerable:true,
      configurable:true,
      get:function(){
        //在这里进行订阅者收集
        if(Dep.target){
         Dep.addSub(Dep.target)
        }
      },
      set:function(newValue){
        if(newValue!==value){
          value === newValue
          //通知订阅者
          Dep.notify()
        }
      }
    })
}

//调度中心（订阅者容器，依赖的容器）
class Dep{
  constructor(){
    //维护一个订阅者的数组
    this.subscribers = []
  }
  //增加订阅
  addSub(watcher){
    this.subscribers.push(watcher)
  }
  //通知所有订阅者视图更新
  notify(){
    this.subscribers.forEach((watcher)=>{
      watcher.update()
    })
  }
}

//订阅者
class Watcher{
  //vm用于存放vm实例
  constructor(vm,expOrFn,cb,options){
    this.cb = cb
    this.vm = vm
    //存放当前Wathcer实例到Dep中
    Dep.target = this
    //触发渲染操作,触发getter
    this.cb.call(this.vm)
  }
  update(){
    //调用视图刷新
    this.cb.call(this.vm)
  }
}


class Vue{
  constructor(options){
    this._data = options.data()
    observe(this._data)
    new Watcher(this)
  }
}

new Vue({
  data:function(){
    return {
      a:1
    }
  }
})

```

## 数据绑定的源码实现

### 初始化数据initData（数据双向绑定的实现）

>initData初始化数据，监听数据的变化，使得数据的变化能够响应

```
function initData (vm: Component) {

  /*得到data数据*/
  //如果配置中的data是函数，则执行函数，如果是对象，则直接获取
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}

  /*判断是否是对象*/
  //如果data不是对象，且不是正式环境的情况下，发出警告
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }

  // proxy data on instance
  /*遍历data对象*/
  const keys = Object.keys(data)
  const props = vm.$options.props
  let i = keys.length

  //遍历data中的数据
  while (i--) {
    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${keys[i]}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(keys[i])) {
      /*判断是否是保留字段*/

      /*将data上面的属性代理到了vm实例上,即假设data有属性a,this.data.a可以通过this.a被访问*/
      proxy(vm, `_data`, keys[i])
    }
  }
  // observe data
  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/
  observe(data, true /* asRootData */)
}
```

### proxy（代理数据）
>我们在访问vue中data、props、computed、methods的属性时，都是通过this.propertyName来访问
在初始化时，我们也会对这些数据进行区分。假设data中有属性a,我们如何通过this.a来访问this.data.a呢？
proxy就是做这件事，帮助我们把数据代理到vm实例上。

```
//target为代理的实例,proxyObjectName为被代理的对象名，proxyKey为被代理对象的属性
function proxy(target,proxyObjectName,proxyKey){
 Object.defineProperty(target,proxyKey,{
  enumerable:true,
  configurable:true,
  get:function proxyGetter(){
   //注意这里的this在运行时指向target
   return this[proxyObjectName][proxyKey]
  },
  set:function proxySetter(newVal){
   this[proxyObjectName][proxyKey] = newVal
  }
 })
}
```

**proxy之后，打印target对象看不到被代理对象的属性，但通过target[proxyKey]却能访问到,target[proxyKey]的修改也会对target[proxyObjectName][proxyKey]进行修改，这是和直接复制引用不同的地方**




















