# 源码实现
>双向绑定的实现流程如下

![双向绑定原理](https://tva1.sinaimg.cn/large/0082zybpgy1gc58pux2iij30ka0autaa.jpg)

根据上图(参考自：https://github.com/DMQ/mvvm)
双向绑定必须要实现以下几点：
- 实现一个数据监听器Observer，能够对数据的所有属性进行监听
- 实现一个订阅者的容器Dep,能够收集订阅者，并且数据变更时能够通知订阅者
- 实现一个指令解析器Compile,对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，绑定相应的更新函数，初始化视图
- 实现一个观察者Watcher,作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令对应的回调函数，更新视图


## 监听数据的实现

数据劫持监听的源码流程图如下:

![数据劫持源码流程图](https://tva1.sinaimg.cn/large/0082zybpgy1gc59swtpwej31yp0iyai2.jpg)

### 初始化数据initData

>initData初始化数据，监听数据的变化，使得数据的变化能够响应

- 获取data并判断
- 获取Props,判断data中的属性是否在Props中被定义，被定义发出警告
- 将data上的属性代理到vm实例上(代理不是取引用，为vm实例定义相同的属性，通过getter去获取data上的值，setter去修改data上的值)
- observe数据，绑定数据data

```javascript
function initData (vm: Component) {

  /*得到data数据*/
  //如果配置中的data是函数，则执行函数，如果是对象，则直接获取
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}

  /*判断是否是对象*/
  //如果data不是对象，且不是正式环境的情况下，发出警告
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }

  // proxy data on instance
  /*遍历data对象*/
  const keys = Object.keys(data)
  const props = vm.$options.props
  let i = keys.length

  //遍历data中的数据
  while (i--) {
    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${keys[i]}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(keys[i])) {
      /*判断是否是保留字段*/

      /*将data上面的属性代理到了vm实例上,即假设data有属性a,this.data.a可以通过this.a被访问*/
      proxy(vm, `_data`, keys[i])
    }
  }
  // observe data
  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/
  observe(data, true /* asRootData */)
}
```

### proxy（代理数据）
>我们在访问vue中data、props、computed、methods的属性时，都是通过this.propertyName来访问
在初始化时，我们也会对这些数据进行区分。假设data中有属性a,我们如何通过this.a来访问this.data.a呢？
proxy就是做这件事，帮助我们把数据代理到vm实例上。

```javascript
//target为代理的实例,proxyObjectName为被代理的对象名，proxyKey为被代理对象的属性
function proxy(target,proxyObjectName,proxyKey){
 Object.defineProperty(target,proxyKey,{
  enumerable:true,
  configurable:true,
  get:function proxyGetter(){
   //注意这里的this在运行时指向target
   return this[proxyObjectName][proxyKey]
  },
  set:function proxySetter(newVal){
   this[proxyObjectName][proxyKey] = newVal
  }
 })
}
```

**proxy之后，打印target对象看不到被代理对象的属性，但通过target[proxyKey]却能访问到,target[proxyKey]的修改也会对target[proxyObjectName][proxyKey]进行修改，这是和直接复制引用不同的地方**


### observe
>observe函数尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。
Observer实例放在当前对象

- 判断当前数据是否为对象
- 判断__ob__属性是否存在，存在则直接引用，不存在则创建Observer实例
- 如果是根数据则计数


```javascript
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
 /*
 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。
 */
export function observe (value: any, asRootData: ?boolean): Observer | void {
  /*判断是否是一个对象*/
  if (!isObject(value)) {
    return
  }
  let ob: Observer | void

  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/
 
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (

    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {

    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/
    ob.vmCount++
  }
  return ob
}
```
**Vue的响应式数据都会有一个__ob__的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。 所以判断数据是否可响应，看当前数据是否包含__ob__属性**


### Observer(数据监听器)
>Observer实例存在于每个响应式数据的__ob__属性中，Observer的构造函数遍历对象的所有属性，对其进行双向绑定,使属性能够响应式。

Observer实例应该具有以下属性:
- value:any 保存当前对象的值
- dep:Dep 保存依赖收集
- vmCount:number 保存vm实例将当前对象作为根数据root $data的次数

具有以下方法:
- walk(obj:Object),对对象类型的数据进行绑定
- observeArray(array : Array<any>),对数组类型的成员进行绑定（对成员调用observe）

步骤如下：
- 将Observer实例绑定到目标对象的__ob__属性
- 判断当前目标对象是否为数组
- 是数组则监听数组的方法，并且为数组的每个成员尝试构建一个Observer实例（即调用observe函数）
- 是对象则响应式对象的属性

```javascript
/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
 /*
 Observer类被赋予给每个响应式的对象，一旦拥有Observer实例，Obsever转化目标对象属性的  getter/setters，使得getter能够进行依赖收集,setter能够发布更新
 */
 
export class  {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that has this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0

    /*
    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16
    */
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      //数组的响应体现在调用方法的时候，所以直接用下标修改数组的成员无法响应
      /*
          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。
          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。
      */
      //判断是否支持__proto__属性
      //如果支持，则直接覆盖当前数组对象原型上的数组方法
      //如果不支持，则逐个覆盖目标数组的方法
      const augment = hasProto 
        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/
        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/
        
      augment(value, arrayMethods, arrayKeys)
      
      //对数组的每一个成员进行observe
      /*如果是数组则需要遍历数组的每一个成员进行observe*/
      this.observeArray(value)
      
    } else {

      /*如果是对象则直接walk进行绑定*/
      this.walk(value)
    }
  }

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)

    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array<any>) {

    /*数组需要遍历每一个成员进行observe*/
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}


```
def函数实现
```javascript
/**
 * Define a property.
 */
export function def (obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}

```

### 数组的响应
>如果修改数组的成员，并且该成员是个对象，那只需要递归对数组的成员进行双向绑定即可。
但如果我们进行pop、push等操作的时候，push进去的对象没有进行过双向绑定，那么我们如何监听数组的成员变化呢？VUE提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法。
**数组的类型也是object，可以理解为数组为具有特定实现方法的object,我们需要对这些方法进行监听并响应**

#### 重写的数组(对象)
>根据Observer中对数组的响应式处理，如果浏览器支持__proto__属性，则直接修改__proto__为VUE重写的数组(对象)，如果不支持，则需要覆盖当前数组的每一个方法为VUE重写的数组(对象)中的方法，逐个覆盖。

```javascript
/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
 /*直接覆盖原型的方法来修改目标对象或数组*/
function protoAugment (target, src: Object) {
  /* eslint-disable no-proto */
  target.__proto__ = src
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
/*定义（覆盖）目标对象或数组的某一个方法*/
function copyAugment (target: Object, src: Object, keys: Array<string>) {
  for (let i = 0, l = keys.length; i < l; i++) {
    const key = keys[i]
    def(target, key, src[key])
  }
}

```

重写的VUE数组（arrayMethods）实现:
- 获取原生数组的原型，根据原生数组的原型创建新的数组对象arrayMethods,防止污染原生数组方法
- 重写数组对象的push、pop、shift、unshift、splice、sort、reverse方法

重写方法的步骤:
- 调用原生数组方法
- 根据方法名来获取新增数据，例如如果是splice只取第三位参数开始的数据
- 从__ob__属性中获取Observer实例，对新增的数组数据进行observe即调用observeArray方法，绑定新增的数组数据（由于目标（需要响应的）数组的方法最终会继承或者被重写数组（arrayMethods）的方法覆盖，所以在重写的方法内可以调用到目标数组的属性__ob__）
- 调用Observer实例中订阅者容器Dep的发布数据更新的方法notify()，通知所有订阅当前数据的观察者


```javascript
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */
 //在这里没有采用类型检测，是因为flow这个框架在数组原型方法上表现不好
 //从这里可以了解到为什么vue3.0会采用typeScript开发

import { def } from '../util/index'

/*取得原生数组的原型*/
const arrayProto = Array.prototype
/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/
export const arrayMethods = Object.create(arrayProto)

/**
 * Intercept mutating methods and emit events
 */
 /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/
[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  /*将数组的原生方法缓存起来，后面要调用*/
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator () {
    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    let i = arguments.length
    const args = new Array(i)
    while (i--) {
      args[i] = arguments[i]
    }
    /*调用原生的数组方法*/
    const result = original.apply(this, args)

    /*数组新插入的元素需要重新进行observe才能响应式*/
    const ob = this.__ob__
    //记录新插入的元素
    let inserted
    //如果是splice(startIndex,removeNumber,...addItems),则下标为2开始的为新增元素
    switch (method) {
      case 'push':
        inserted = args
        break
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    //对新插入的元素进行绑定
    if (inserted) ob.observeArray(inserted)

    // notify change
    /*dep通知所有注册的观察者进行响应式处理*/
    ob.dep.notify()
    return result
  })
})

```
**如果当前浏览器支持__proto__属性，则可以直接覆盖整个属性为VUE重写的数组对象，如果没有该属性，则必须通过def对当前数组对象的方法进行覆盖，效率较低，所以优先使用第一种。**

**从上述重写的数组对象可以看出，如果修改了通过数组下标或者设置length来修改数组，是无法监听的，所以无法为新增元素进行绑定，但是我们可以通过Vue.set或者splice方法**
