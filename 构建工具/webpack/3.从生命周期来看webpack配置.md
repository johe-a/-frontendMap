<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-07-08 18:47:48
--> 
# webpack生命周期
webpack生命周期可以简单地分为:
- 参数分析
- 编译入口
- 编译模块
- 处理模块依赖
- 输出

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjrqhg65rj30o00ilgmy.jpg)

# 构建之前
## cleanWebpackPlugin(清理dist文件)
每次我们打包都会生成dist文件，同名的会覆盖，而不同名的会保留，为了清除历史记录，可以用cleanWebpackPlugin在构建之前删除文件夹
```shell
npm install clean-webpack-plugin --save-dev
```
```javascript
const CleanWebpackPlugin =  require('clean-webapck-plugin');
module.exports = {
    plugins:[
        new CleanWebpackPlugin(['dist'])
    ]
}

```

# 编译模块阶段
## loader(管理资源)
编译模块阶段在require/import的时候会使用loader对不同的文件类型进行处理，生成js模块。
### babel-loader(将JS转为低版本)
为了能够顺畅的写ES6代码、TS代码或者JSX代码，我们需要用到babel的功能
```javascript
module.exports = {
    entry:'./src/index.js',
    output:{
        path:path.resolve(__dirname,'dist'),
        filename:'[name].js'
    },
    module:{
        rules:[
            {
                test:/\.jsx?$/,
                use:['babel-loader']
            }
        ]
    }
}
```
babel的配置，我们可以写在rules中的options配置内，也可以写在.babelrc
```json
{
    "presets":[],
    "plugins":[]
}
```
presets用于告诉babel，转义用哪一版本的标准，有如下标准：
1. 已经被写入ECMAScript标准里的特性 
- ES2015\ES2015\ES2017\Env(最新特性) 
2. 被社区提出来但未被写入ECMAScript标准里的特性。 
- stage0:只是一个美好激进的想法，一些babel插件实现了这些特性的支持，但不确定是否会被定义为标准。 
- stage1:值得被纳入标准的特性。 
- stage2:特性规范已经被起草，将会被纳入标准。 
- stage3:该特性规范已经定稿，已经开始着手实现 
- satge4:在接下来一年里将会加入标准里。 
3. 用于支持一些特定应用场景下的语法特性，和ECMAScript标准没有关系，例如babel-preset-react用于支持React开发里的JSX语法。

plugins告诉babel要使用哪些插件，这些插件可以控制如何转换代码，例如@babel/plugin-transform-runtime用来删除转化代码时的冗余代码。@babel/plugin-transform-runtime要配合@babel/runtime使用。

```json
{
    "presets":["@babel/preset-env"],
    "plugins":["@babel/plugin-transform-runtime"]
}

```
实际上，转化代码的工作是由@babel/core来处理的，所以我们在使用babel转化代码的时候，要安装以下包:
```
cnpm install --save-dev @babe/core babel-loader @babel/preset-env @babel/plugin-transform-runtime @babel/runtime
```
### 处理css和css预处理
要让webpack识别css,需要css-loader和style-loader
- css-loader:找出css中@import和url()这样的导入语句，告诉webpack依赖这些资源，同时支持css Modules、压缩css、css sourceMap、为css的资源设置别名等功能。
- style-loader:动态创建style标签，将css插入到head中,支持css的热模块替换
- sass-loader: 将sass编译成css
**为了让我们能够写下一代的css语法(类似于js的es6，css也有一些特性需要polyfill才能使用)，postcss就是为此而生的，如果说babel是js的处理器，那么postcss就是css的处理器,所以postcss还支持插件机制，包括可以支持下一代css语法，自动添加浏览器前缀等。**
- postcss与css的关系就像babel与js
- postcss与scss的关系就像babel与typescript

在现在浏览器中，可能我们还需要添加属性前缀，postcss-loader和autoprefixer可以帮我们解决问题

假设我们现在有一个scss文件需要处理成css，为其css属性自动添加浏览器前缀，并为了能够在css中使用@import/url()，最终输出到style标签中:
1. 用sass-loader将scss编译成css,结果传给第二步,由于现在peerdependencies不会自动安装，所以还需要安装sass,node-sass,fibers。
2. 用postcss-loader和它的插件autoprefixer为其添加浏览器前缀,结果传给第三步
3. 用css-loader解析css中引用的模块，@import和url()语法，和解析module css，结果传给第四步
4. 用style-loader生成style标签插入到head中,支持css的HMR。

**如果是在生产环境下，我们可能会将css分离，这样有助于code spliting(代码分隔)按需加载。在开发环境中，我们更需要的是构建速度和css热模块替换，所以使用style-loader**

**use中的顺序是从右到左调用loader的。**
```javascript
module.exports = {
	module:{
		use:[
			{
				test:/\.s?css$/,
				use:[
					'style-loader',
					'css-loader',
					{
						loader:'postcss-loader',
						options:{
							plugins:function(){
								return [ 
									require('autoprefixer')({
											"overrideBrowserslist": [
												">0.25%",
												"not dead"
										]
									}) 
								]
							}
						}
					},
					'sass-loader'
				]
			}
		]
	}
}
```
postcss-loader的配置和babel一样，也可以选择在.browserslistrc下配置，这样除了autoprefixer之外，@babel/preset-env、stylelint、eslint-plugin-compat都可以共用。

css-loader还有如下配置：
- root: 解析URL的路径
- url: 启用/禁用url()的处理
- alias: 创建别名
- import: 启用/禁用@import处理
- modules: 启用/禁用css模块
- minimize: 启用/禁用压缩
- sourceMap: 启用/禁用sourceMap
如果想要用webpack中的路径别名resolve.alias的话，在@import和url()的引用路径前，加上'~':
```css
import('~@/assets/variable.scss');
```

### 图片或字体处理(url-loader/file-loader)
我们可以使用url-loader或者file-loader来处理资源文件。url-loader和file-loader功能类似。下载url-loader时也要下载file-loader。
**但是url-loader可以指定文件大小小于limit时，生成base64,大于limit时将图片拷贝到dist目录。**

将图片、字体转为base64可以减少http请求，但是如果base64数据过大，会导致html的下载变慢。
```javascript
module.exports = {
	module:{
		rules:[
			{
				test:/\.(jpg|png|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/,
				use:[{
					loader:'url-loader',
					options:{
						//小于10k生成base64
						limit:10*1024,
						esModule:false,
						//大于10k时生成的文件名
						name:'[name]_[hash:6].[ext]'
					}
				}]
			}
		]
	}
}
```
如果生成的图片过多，我们希望设置到同一个文件夹下，这时可以使用url-loader的outputPath:
```javascript
use:[{
	loader:'url-loader',
	options:{
		limit:10*1024,
		esModule:false,
		name:'[name]_[hash:6].[ext]',
		outputPath:'assets'
	}
}]
```
## plugins
### 分离css(MiniCssExtractPlugin.loader)
在开发环境下，我们可能需要做css分离，这是为了code-spliting代码分割，按需加载。
- MiniCssExtractPlugin.loader将代码提取成单独的css文件，在head中用link引入,开发&生产都可以使用
- style-loader将css代码防到style标签内，适用于开发环境
```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
	mode:'production',
	module:{
		rules:[
			{
				test:/\.s?css$/,
				use:[
					//将style-loader换成MiniCssExtractPlugin
					MiniCssExtractPlugin.loader,
					'css-loader'
					'postcss-loader',
					'sass-loader'
				]
			}
		]
	}
}
```
style-loader有热模块更新css的功能，MiniCssExtractPlugin.loader其实也有这个功能:
```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
	module:{
		rules:[
			{
				test:/\.s?css$/,
				use:[
					//将style-loader换成MiniCssExtractPlugin
					{
						loader:MiniCssExtractPlugin.loader,
						options:{
							//开发环境下使用热模块替换css
							hmr:process.env.NODE_ENV === 'development',
							//如果模块热更新不起作用，重新加载全部样式
							reloadAll:true
						}
					},
					'css-loader'
					'postcss-loader',
					'sass-loader'
				]
			}
		]
	}
}
```

# 管理输出阶段
## output配置
output选项可以控制webpack如何输出编译文件。
```javascript
module.exports = {
	output:{
		path:path.resolve(__dirname,'dist'),//必须是绝对路径
		filename:'[name]_[hash:6].js',
		publicPath:'/'//通常用于CDN地址
	}
}
```
publicPath:如果我们的代码最终部署在CDN上，资源的地址假设为'http://AAA/BBB/project/XXX',那么可以将生产的publicPath配置为:///AAA/BBB/

## HtmlWebpackPlugin(提供html模板能力)
在webpack打包后的文件中通常会带有hash值，例如我们在output配置中这样设置:
```javascript
module.exports = {
    output:{
        path:path.resolve(__dirname,'dist'),
        filename:'[name].[hash].[js]'
    }
}
```
此时输出的js会有hash值，如果每次都需要我们手动引入html，那会十分低效。HtmlWebpackPlugin默认帮我们引入js文件，还给Html提供模板能力，可以在html中进行编码。

默认导入编译后的js:
```javascript
//./config/index.js
module.exports = {
    build:{
        header:true,
        footer:false
    },
    dev:{
        header:false,
        footer:false
    }
}
//webpack.config.js
const config = require('./config/')[process.env.NODE_ENV === 'production' ? 'build':'dev'];
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
    plugins:[
        new HtmlWebpackPlugin({
            //模板位置
            template:path.resolve(__dirname,'index.html'),
            //输出文件名
            filename:'index.html',
            //压缩选项
            minify:{
                //是否删除属性的双引号
                resmoveAttributeQuotes:false,
                //是否折叠空白
                collapseWhitespace:false
            },
            config:config.template
        })
    ]
}

```
### HtmlWebpackPlugin配置(提供模板引擎能力)
有时候，我们可能需要在html中根据环境来决定是否加载某个资源或者修改网页的title名，这个时候就会用到模板引擎的能力
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <% if(htmlWebpackPlugin.options.config.header){ %>
        <link rel="stylesheet" type="text/css" href="//common/css/header.css">
    <%}%>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title><%= (htmlWebpackPlugin.options.config.title) %></title>
</head>

<body>

</body>
<% if(process.env.NODE_ENV==='production'){ %>
    <script src="./config.js?h=<%=compilation.hash%>">
<% } %>
</html>
```
## 模块热替换HMR(HotModuleReplace)
模块热替换一般用在开发环境中，在我们进行开发的时候，如果每次都需要手动编译，查看更改的代码结果，是十分低效的，这个时候就需要模块热替换，它允许在运行时更新各种模块（默认只支持js模块的更新检测），而无需进行完全刷新。

HMR的最简易配置:(NameModulesPlugin和HotModuleReplacementPlugin都是webpack内置插件，但只有在开发环境下存在)
```javascript
const webpack = require('webpack');

module.exports = {
    devServer:{
        //在localhost:8080下简历服务，将dist目录下的文件作为可访问文件
        contentBase:'./dist',
        //开启HMR
        hot:true
    },
    plugins:[
        //用于帮助显示模块路径为相对路径
        new webpack.NamedModulesPlugin(),
        new webpack.HotModuleReplacementPlugin()
    ]
}

//package.json
module.exports = {
    "scripts":{
        "dev":"webpack-dev-server --open"
    }
}
```
**如果要提供其他模块的热更新，需要对应的loader处理，例如css的更新需要style-loader，vue的更新需要vue-loader等**
本质是在后台判断module.hot时，调用module.hot.accept去修补需要的资源。

### NodeAPI启动HMR
```javascript
const webpackDevServer = require('webpack-dev-server');
const webpack = require('webpack');

const config = require('./webpack.config.js');
const options = {
    contentBase:'./dist',
    hot:true,
    host:'localhost'
};

//想要启用 HMR，还需要修改 webpack 配置对象，使其包含 HMR 入口起点。webpack-dev-server package 中具有一个叫做 addDevServerEntrypoints 的方法，你可以通过使用这个方法来实现
webpackDevServer.addDevServerEntrypoints(config,options);
const compiler = webpack(config);
const server = new webpackDevServer(compiler,options);

server.listen(5000,'localhost',()=>{
    console.log('dev server listening on port 5000');
});
```

## source-map(编译后文件调试,影响构建性能和安全)
devtool可以帮助我们开启source-map，sourcemap将编译后的代码映射到原始源代码，方便我们调试，但是不同的值会明显影响到构建和重新构建的速度。在开发环境和生产环境要区分使用。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggk0gpckrbj30lp0jt0vm.jpg)

- 在权衡构建速度和品质的情况下，开发环境一般使用cheap-module-eval-source-map，能够看到对应的源代码错误，而构建速度又不会太慢。开发环境注重重新构建的速度。
- 生产环境注重精准，因为只会构建一次，一般使用source-map/hidden-source-map/nosources-source-map

**生产环境下的source-map，应该设置为不允许普通用户访问。你不应将source map文件部署到web服务器。而是只将其用于错误报告工具。**

**devtool设置的source-map是针对js的，如果需要对css进行source-map，需要在css-loader里面配置sourceMap选项**

## css分离的输出管理(MiniCssExtractPlugin)
