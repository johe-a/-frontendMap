<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-07-08 18:47:48
--> 
# webpack生命周期
webpack生命周期可以简单地分为:
- 参数分析
- 编译入口
- 编译模块
- 处理模块依赖
- 输出

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjrqhg65rj30o00ilgmy.jpg)

# 构建之前
## cleanWebpackPlugin(清理dist文件)
每次我们打包都会生成dist文件，同名的会覆盖，而不同名的会保留，为了清除历史记录，可以用cleanWebpackPlugin在构建之前删除文件夹
```shell
npm install clean-webpack-plugin --save-dev
```
```javascript
const { CleanWebpackPlugin } =  require('clean-webpack-plugin');
module.exports = {
    plugins:[
			  //不需要传参
        new CleanWebpackPlugin()
    ]
}

```

# 编译模块阶段
## loader(管理资源)
编译模块阶段在require/import的时候会使用loader对不同的文件类型进行处理，生成js模块。
### babel-loader(将JS转为低版本)
为了能够顺畅的写ES6代码、TS代码或者JSX代码，我们需要用到babel的功能
```javascript
module.exports = {
    entry:'./src/index.js',
    output:{
        path:path.resolve(__dirname,'dist'),
        filename:'[name].js'
    },
    module:{
        rules:[
            {
                test:/\.jsx?$/,
                use:['babel-loader']
            }
        ]
    }
}
```
babel的配置，我们可以写在rules中的options配置内，也可以写在.babelrc
```json
{
    "presets":[],
    "plugins":[]
}
```
presets用于告诉babel，转义用哪一版本的标准，有如下标准：
1. 已经被写入ECMAScript标准里的特性 
- ES2015\ES2015\ES2017\Env(最新特性) 
2. 被社区提出来但未被写入ECMAScript标准里的特性。 
- stage0:只是一个美好激进的想法，一些babel插件实现了这些特性的支持，但不确定是否会被定义为标准。 
- stage1:值得被纳入标准的特性。 
- stage2:特性规范已经被起草，将会被纳入标准。 
- stage3:该特性规范已经定稿，已经开始着手实现 
- satge4:在接下来一年里将会加入标准里。 
3. 用于支持一些特定应用场景下的语法特性，和ECMAScript标准没有关系，例如babel-preset-react用于支持React开发里的JSX语法。

plugins告诉babel要使用哪些插件，这些插件可以控制如何转换代码，例如@babel/plugin-transform-runtime用来删除转化代码时的冗余代码。@babel/plugin-transform-runtime要配合@babel/runtime使用。

```json
{
    "presets":["@babel/preset-env"],
    "plugins":["@babel/plugin-transform-runtime"]
}

```
实际上，转化代码的工作是由@babel/core来处理的，所以我们在使用babel转化代码的时候，要安装以下包:
```
cnpm install --save-dev @babe/core babel-loader @babel/preset-env @babel/plugin-transform-runtime @babel/runtime
```
### 处理css和css预处理
要让webpack识别css,需要css-loader和style-loader
- css-loader:找出css中@import和url()这样的导入语句，告诉webpack依赖这些资源，同时支持css Modules、压缩css、css sourceMap、为css的资源设置别名等功能。
- style-loader:动态创建style标签，将css插入到head中,支持css的热模块替换
- sass-loader: 将sass编译成css
**为了让我们能够写下一代的css语法(类似于js的es6，css也有一些特性需要polyfill才能使用)，postcss就是为此而生的，如果说babel是js的处理器，那么postcss就是css的处理器,所以postcss还支持插件机制，包括可以支持下一代css语法，自动添加浏览器前缀等。**
- postcss与css的关系就像babel与js
- postcss与scss的关系就像babel与typescript

在现在浏览器中，可能我们还需要添加属性前缀，postcss-loader和autoprefixer可以帮我们解决问题

假设我们现在有一个scss文件需要处理成css，为其css属性自动添加浏览器前缀，并为了能够在css中使用@import/url()，最终输出到style标签中:
1. 用sass-loader将scss编译成css,结果传给第二步,由于现在peerdependencies不会自动安装，所以还需要安装sass,node-sass,fibers。
2. 用postcss-loader和它的插件autoprefixer为其添加浏览器前缀,结果传给第三步
3. 用css-loader解析css中引用的模块，@import和url()语法，和解析module css，结果传给第四步
4. 用style-loader生成style标签插入到head中,支持css的HMR。

**如果是在生产环境下，我们可能会将css分离，这样有助于code spliting(代码分隔)按需加载。在开发环境中，我们更需要的是构建速度和css热模块替换，所以使用style-loader**

**use中的顺序是从右到左调用loader的。**
```javascript
module.exports = {
	module:{
		use:[
			{
				test:/\.s?css$/,
				use:[
					'style-loader',
					'css-loader',
					{
						loader:'postcss-loader',
						options:{
							plugins:function(){
								return [ 
									require('autoprefixer')({
											"overrideBrowserslist": [
												">0.25%",
												"not dead"
										]
									}) 
								]
							}
						}
					},
					'sass-loader'
				]
			}
		]
	}
}
```
postcss-loader的配置和babel一样，也可以选择在.browserslistrc下配置，这样除了autoprefixer之外，@babel/preset-env、stylelint、eslint-plugin-compat都可以共用。

css-loader还有如下配置：
- root: 解析URL的路径
- url: 启用/禁用url()的处理
- alias: 创建别名
- import: 启用/禁用@import处理
- modules: 启用/禁用css模块
- minimize: 启用/禁用压缩
- sourceMap: 启用/禁用sourceMap
如果想要用webpack中的路径别名resolve.alias的话，在@import和url()的引用路径前，加上'~':
```css
import('~@/assets/variable.scss');
```

### 图片或字体处理(url-loader/file-loader)
我们可以使用url-loader或者file-loader来处理资源文件。url-loader和file-loader功能类似。下载url-loader时也要下载file-loader。
**但是url-loader可以指定文件大小小于limit时，生成base64,大于limit时将图片拷贝到dist目录。**

将图片、字体转为base64可以减少http请求，但是如果base64数据过大，会导致html的下载变慢。
```javascript
module.exports = {
	module:{
		rules:[
			{
				test:/\.(jpg|png|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/,
				use:[{
					loader:'url-loader',
					options:{
						//小于10k生成base64
						limit:10*1024,
						esModule:false,
						//大于10k时生成的文件名
						name:'[name]_[hash:6].[ext]'
					}
				}]
			}
		]
	}
}
```
如果生成的图片过多，我们希望设置到同一个文件夹下，这时可以使用url-loader的outputPath:
```javascript
use:[{
	loader:'url-loader',
	options:{
		limit:10*1024,
		esModule:false,
		name:'[name]_[hash:6].[ext]',
		outputPath:'assets'
	}
}]
```
## plugins
### 分离css(MiniCssExtractPlugin.loader)
在开发环境下，我们可能需要做css分离，这是为了code-spliting代码分割，按需加载。
- MiniCssExtractPlugin.loader将代码提取成单独的css文件，在head中用link引入,开发&生产都可以使用
- style-loader将css代码防到style标签内，适用于开发环境
```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
	mode:'production',
	module:{
		rules:[
			{
				test:/\.s?css$/,
				use:[
					//将style-loader换成MiniCssExtractPlugin
					MiniCssExtractPlugin.loader,
					'css-loader'
					'postcss-loader',
					'sass-loader'
				]
			}
		]
	}
}
```
style-loader有热模块更新css的功能，MiniCssExtractPlugin.loader其实也有这个功能:
```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
	module:{
		rules:[
			{
				test:/\.s?css$/,
				use:[
					//将style-loader换成MiniCssExtractPlugin
					{
						loader:MiniCssExtractPlugin.loader,
						options:{
							//开发环境下使用热模块替换css
							hmr:process.env.NODE_ENV === 'development',
							//如果模块热更新不起作用，重新加载全部样式
							reloadAll:true
						}
					},
					'css-loader'
					'postcss-loader',
					'sass-loader'
				]
			}
		]
	}
}
```
### 全局变量注入(ProvidePlugin)
ProvidePlugin给全局注入变量，在文件内使用不需要引入。是webpack的内置插件。  

使用方式：
```javascript
new webapck.providePlugin({
	identifier1:'module1',
	//module2对应的Property2属性
	identifier2:['module2','property2']
})
```
应用场景，在React中每个文件都要引入React，还有Lodash，jquery这样的库，可能再多个文件中使用，以及Vue等等
```javascript
module.exports = {
	plugins:[
		new webpack.ProvidePlugin({
			React:'react',
			Component:['react','Component'],
			Vue:['vue/dist/vue.esm.js','default'],
			$:'jquery',
			_map:['lodash','map']
		})
	]
}
```
Vue的配置后面多了个default，这是由于vue.esm.js中使用的是export default导出的，对于这种es6 modules必须要指定default。


# 管理输出阶段
## output配置
output选项可以控制webpack如何输出编译文件。
```javascript
module.exports = {
	output:{
		path:path.resolve(__dirname,'dist'),//必须是绝对路径
		filename:'[name]_[hash:6].js',
		publicPath:'/'//通常用于CDN地址
	}
}
```
publicPath:如果我们的代码最终部署在CDN上，资源的地址假设为'http://AAA/BBB/project/XXX',那么可以将生产的publicPath配置为:///AAA/BBB/

## copyWebpackPlugin(静态资源的拷贝)
有时候我们会需要使用已有的JS文件、CSS文件，但是不需要webpack编译，例如我们在Index.html下引入js或者css文件，这个时候如果直接打包，那么构建出来之后肯定是找不到对应的js/css了，因为这些文件没有被打包到dist目录中:
```html
<!--index.html>
<script src="./common.js"></script>
```
这个时候如果我们npm run dev发现有找不到该资源文件的报错信息。  
**使用CopyWebpackPlugin**可以帮我们将文件或者目录复制到构建目录。
```javascript
module.exports = {
	plugins:[
		new CopyWebpackPlugin([{
			  //将public/js/目录下的所有js拷贝
				from:'public/js/*.js',
				to:path.resolve(__dirname,'dist','js'),
				//只拷贝文件
				flarren:true
			},
			//还可以继续配置其他要拷贝的文件
		])
	]
}
```

## HtmlWebpackPlugin(提供html模板能力)
在webpack打包后的文件中通常会带有hash值，例如我们在output配置中这样设置:
```javascript
module.exports = {
    output:{
        path:path.resolve(__dirname,'dist'),
        filename:'[name].[hash].[js]'
    }
}
```
此时输出的js会有hash值，如果每次都需要我们手动引入html，那会十分低效。HtmlWebpackPlugin默认帮我们引入js文件，还给Html提供模板能力，可以在html中进行编码。

默认导入编译后的js:
```javascript
//./config/index.js
module.exports = {
    build:{
        header:true,
        footer:false
    },
    dev:{
        header:false,
        footer:false
    }
}
//webpack.config.js
const config = require('./config/')[process.env.NODE_ENV === 'production' ? 'build':'dev'];
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
    plugins:[
        new HtmlWebpackPlugin({
            //模板位置
            template:path.resolve(__dirname,'index.html'),
            //输出文件名
            filename:'index.html',
            //压缩选项
            minify:{
                //是否删除属性的双引号
                resmoveAttributeQuotes:false,
                //是否折叠空白
                collapseWhitespace:false
            },
            config:config.template
        })
    ]
}

```
### HtmlWebpackPlugin配置(提供模板引擎能力)
有时候，我们可能需要在html中根据环境来决定是否加载某个资源或者修改网页的title名，这个时候就会用到模板引擎的能力
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <% if(htmlWebpackPlugin.options.config.header){ %>
        <link rel="stylesheet" type="text/css" href="//common/css/header.css">
    <%}%>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title><%= (htmlWebpackPlugin.options.config.title) %></title>
</head>

<body>

</body>
<% if(process.env.NODE_ENV==='production'){ %>
    <script src="./config.js?h=<%=compilation.hash%>">
<% } %>
</html>
```
## 模块热替换HMR(HotModuleReplace)
模块热替换一般用在开发环境中，在我们进行开发的时候，如果每次都需要手动编译，查看更改的代码结果，是十分低效的，这个时候就需要模块热替换，它允许在运行时更新各种模块（默认只支持js模块的更新检测），而无需进行完全刷新。

HMR的最简易配置:(NameModulesPlugin和HotModuleReplacementPlugin都是webpack内置插件，但只有在开发环境下存在)
```javascript
const webpack = require('webpack');

module.exports = {
    devServer:{
        //在localhost:8080下简历服务，将dist目录下的文件作为可访问文件
        contentBase:'./dist',
        //开启HMR
        hot:true
    },
    plugins:[
        //用于帮助显示模块路径为相对路径
        new webpack.NamedModulesPlugin(),
        new webpack.HotModuleReplacementPlugin()
    ]
}

//package.json
module.exports = {
    "scripts":{
        "dev":"webpack-dev-server --open"
    }
}
```
**如果要提供其他模块的热更新，需要对应的loader处理，例如css的更新需要style-loader，vue的更新需要vue-loader等**
本质是在后台判断module.hot时，调用module.hot.accept去修补需要的资源。

### NodeAPI启动HMR
```javascript
const webpackDevServer = require('webpack-dev-server');
const webpack = require('webpack');

const config = require('./webpack.config.js');
const options = {
    contentBase:'./dist',
    hot:true,
    host:'localhost'
};

//想要启用 HMR，还需要修改 webpack 配置对象，使其包含 HMR 入口起点。webpack-dev-server package 中具有一个叫做 addDevServerEntrypoints 的方法，你可以通过使用这个方法来实现
webpackDevServer.addDevServerEntrypoints(config,options);
const compiler = webpack(config);
const server = new webpackDevServer(compiler,options);

server.listen(5000,'localhost',()=>{
    console.log('dev server listening on port 5000');
});
```

## source-map(编译后文件调试,影响构建性能和安全)
devtool可以帮助我们开启source-map，sourcemap将编译后的代码映射到原始源代码，方便我们调试，但是不同的值会明显影响到构建和重新构建的速度。在开发环境和生产环境要区分使用。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggk0gpckrbj30lp0jt0vm.jpg)

- 在权衡构建速度和品质的情况下，开发环境一般使用cheap-module-eval-source-map，能够看到对应的源代码错误，而构建速度又不会太慢。开发环境注重重新构建的速度。
- 生产环境注重精准，因为只会构建一次，一般使用source-map/hidden-source-map/nosources-source-map

**生产环境下的source-map，应该设置为不允许普通用户访问。你不应将source map文件部署到web服务器。而是只将其用于错误报告工具。**

**devtool设置的source-map是针对js的，如果需要对css进行source-map，需要在css-loader里面配置sourceMap选项**

## css分离的输出管理(MiniCssExtractPlugin)
为了代码分割将css分离，方便按需加载和缓存，我们可以使用MiniCssExtractPlugin。

与ExtractTextWebpackPlugin相比,MiniCssExtractPlugin包含以下特性：
1. 异步加载
2. 不会重复编译
3. 只适用CSS
```javascript
module.exports = {
	//除了配置plugin还要在Loader中使用，一般用于替换style-loader
	plugins:[
		new MiniCssExtractPlugin({
			filename:'css/[name].css',
			options:{
				//css的热模块替换，在开发模式下使用
				hmr:process.env.NODE_ENV === 'development',
				//如果模块热更新不起作用，重新加载全部样式
				reloadAll:true
			}
		})
	]
}

```

## OptimizeCssAssetsWebpackPlugin(将抽离出来的css文件进行压缩)
一般在生产环境使用，开发环境不需要压缩css
```javascript
const OptimizeCssPlugin = require('optimize-css-assets-webpack-plugin');

module.exports = {
	plugins:[
		new OptimizeCssPlugin()
	]
}
```
也可以在optimization中配置:
```javascript
const OptimizeCssPlugin = require('optimize-css-assets-webpack-plugin');

module.exports = {
	optimization:{
		minimizer:[
			new OptimizeCssPlugin()
		]
	}
}
```

## 代码分割
有时候我们并不需要一次性加载所有的js或者css文件，而是在使用到的时候再去加载，或者我们有时候可能会需要将公共的js和css抽离。

代码分割有以下好处：
- 按需加载，使用到的时候再加载
- 抽取公共的资源，减少重复导入

代码分割技术的核心是异步加载资源，即通过import()关键字让浏览器在程序执行时异步加载相关资源。

有三种常用的代码分离方法:
- 入口：从入口entry配置手动的分离代码，例如vendor
- 使用splitChunk分离公共代码(css需要先使用MiniExtractCssPlugin分离css代码，再抽取公共代码)
- 动态导入：通过函数调用import()来分离代码


### 从入口分离代码
对于公共使用的第三方类库，我们应该显式的配置为公共的部分，而不是webpack自己去判断处理。
这样做的好处是我们的应用在更新后，可以利用缓存，用户不需要再次下载这部分代码。
```javascript
const vendorPkg = [
	"babel-polyfill",
	"react",
	"react-dom"
	...
];

module.exports = {
	entry:{
		vendor:vendorPkg
	}
}

```

### import()异步代码分离
js代码的分离操作，首先考虑的就是异步代码的分离。

例如我们在点击某个按钮之后，才需要使用响应的js文件的代码，需要使用import()语法
```javascript
document.getElementById('btn').onclick = function(){
	import('./handle').then(fn => fn.default());
}
```
import()语法，需要被@babel/plugin-syntax-dynamic-import插件支持，但是因为@babel/preset-env已经预设了，所以不需要再单独安装和配置。

当webpack遇到import(***)的语法时：
- 将***为入口新生成一个Chunk
- 当代码执行到import所在的语句时，才会加载该Chunk对应的文件。

#### 魔术注释(定义分离的模块名和加载方式)
**定义chunk的名称,如果不定义的话，默认采用output的chunkFilename配置,如果定义了webpackChunkName,将会修改name为定义的名称。**
```javascript
module.exports = {
	output:{
		//这个是定义入口文件的
		filename:'[name]_[hash:6].js',
		//定义chunk默认的名称,这里的name是chunkId不是文件名
		chunkFilename:'[name].chunck.js',
		path:path.resolve(__dirname,'dist')
	}
}
```
```javascript
import(
	/*webpackChunkName:"math.js" */
	'./math.js'
)
```
如果math是第一个chunk，如果不定义webpackChunkName，将会被输出为1.chunk.js，如果定义了，会被输出为math.chunk.js。

**webpackMode帮助我们对异步模块的处理机制有更多控制权**
```javascript
import(
	/* webpackChunkName:"my-chunk-name" */
	/* webpackMode:lazy */
	'./someModule'
)
```
webpackMode 的默认值为 lazy 它会使所有异步模块都会被单独抽离成单一的 chunk，若设置该值为 lazy-once，Webpack 就会将所有带有标记的异步加载模块放在同一个 chunk 中。

**Prefetch or Preload**,类似于<link ref="prefetch">相同的特性。让浏览器在空闲状态时预先帮我们加载所需的资源，善用这个技术可以使我们的应用交互变得更加顺畅:
```javascript
import(
	/* webpackPrefetch:true */
	'./someModule'
);
```

### SplitChunksPlugin分离公共代码
SplitChunksPlugin是webpack内置的插件，可以在optimization内部使用，默认配置如下:
```javascript
module.exports = {
	optimization:{
		splitChunks:{
			chunks:'async',
			...
			//重点属性，用于定义缓存组
			cacheGroups:{

			}
		}
	}
}
```
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggl5zv70lij30ow07pjsy.jpg)

实际上，cacheGroups是我们要关注的重点，因为它可以继承/覆盖上面的外部参数，外部参数就是缓存组的公共配置。

cacheGroups除了包含外部参数chunks、minChunks等之外，还包含:
- test:表示要过滤的范围，默认为所有的Modules，可以匹配模块路径或者chunk名字，也可以是函数
- priority:表示权重，数字越大优先级越高。因为一个module可能会满足多个cacheGroups的条件，那么抽取到哪个就由权重最高的说了算。

例如，我们将node_modules中被不同的chunk引入超过1次的模块抽取为common:
```javascript
cacheGroups:{
	common:{
		//如果不使用test，就默认为全部模块
		test:/node_modules/,
		name:'common',
		chunks:'initial',
		priority:2,
		//引用次数超过1次以上
		minChunks:2
	}
}
```

#### css公共代码抽取
css首先需要通过MiniCssExtractPlugin分离出css代码，然后再通过splitChunks来抽取css公共代码:
```javascript
module.exports = {
	optimization:{
		splitChunks:{
			cacheGroups:{
				styles:{
					name:'styles',
					test:/\.css$/,
					chunks:'all',
					enforce:true,
					//注意将权重设置为最高，不然可能其他的 cacheGroups 会提前打包一部分样式文件
					priority:20
				}
			}
		}
	}
}
```

