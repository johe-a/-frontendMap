<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-06-14 22:46:37
--> 
 # 雅虎的两条军规
1. 合并资源来减少HTTP请求
2. 拆分资源以最大化利用浏览器并行下载的能力

一边是建议合并资源，一边是建议拆分资源，显然是有冲突的。

 # HTTP的请求过程
1. DNS解析(T1)
2. 建立TCP连接(T2)
3. 发送请求(T3)
4. 等待服务器返回首字节(TTFB)
5. 下载数据(T5)

例如下图，显示了HTTP请求的主要阶段
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gftb13blnqj30ax099dgb.jpg)

DNS Lookup(T1) -> Initial connection(T2) -> Request sent(T3) -> Waiting(TTFB)(T3) -> Content Download(T4)

# 实验对照
实验对照：https://juejin.im/post/5b166d1ee51d4506d5366982#heading-8

# 对照结果
从对照结果来看，合并资源往往比将资源拆分要加载的快。但这个结果是不一定的，在一些情况下，合并小文件反而有可能会明显增加资源加载时间。

我们知道TCP是一发送一应答的，但是TCP并不是每发送一次就要等到收到接收方的确认应答ACK后，再发送下一个报文。这和TCP的拥塞控制有关，TCP利用拥塞窗口，决定了TCP包每次能够传输的最大数据分段(其实取的是拥塞窗口和滑动窗口之间较小的那一个)，例如窗口大小是4个报文段，表示当前TCP可以连接发送4个报文段，而不需要等待接收方的确认信号。如下所示：

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gftbm6oa0mj30jq0btwg5.jpg)

但在实际情况下，拥塞窗口使用的慢启动算法，也就是随着每次网络往返，拥塞窗口的大小就会翻一倍，假设最初的大小为1，则变化为1,2,4,8...

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gftbnmz00oj30ge0hgtax.jpg)

实际网络中，拥塞窗口的初始值一般是10,所以拥塞窗口的大小变化为10、20、40,而MSS(Maximum Segment Size)最大报文段的大小一般是1460b,也就是1.4kb,则第一次传输的最大数据为14.6k,第二次为(10+20)*1.46 = 43.8k.

也就是说，当合并的资源大于每次往返的最大数据时，就会使得数据再次往返传输，如果网络延迟很大(例如1s)，多了两次网络往返将导致耗时增加1s，这时候合并资源就可能得不偿失了。 在实验3中，没有产生这个结果，是因为网络延时太小，没有对结果产生明显影响。

# 总结
- 对于小资源，合并资源往往具有更快的加载速度，但是在高延迟的场景下，又要注意合并资源后可能会带来网络往返次数的增加，进而影响到加载时间。
- 对于大资源，是否合并对加载时间没有明显影响，但是拆分资源可以更好的利用浏览器缓存，不会因为某个资源的更新导致所有资源缓存失效。另外还可以利用域名分片技术(每个域名限制的并行请求数量，一般是6个)，将资源拆分部署到不同域名下，既可以分散服务器压力，又可以降低网络抖动带来的影响。

另外，由于浏览器对域名的并行请求数量存在限制，一般一个域名的并行请求只有6个，在一个大项目中并行资源加载很容易超过6个，所以基本上肯定要合并，但是合并到什么程度需要细细衡量。

**总结：对于大项目，小文件基本要合并，因为浏览器对域名限制的并行请求数量很容易超过6个，但是合并的大小不能太大，在网络有延迟的情况下，太大的文件会造成TCP请求往返次数过多。这个合并的大小需要仔细衡量。**


# 文件分片上传
当使用简单的上传功能来上传较大的文件时，在上传的过程中出现了网络错误，那么此次上传失败，重试必须从文件起始位置上传，针对这种情况，我们可以使用分片上传来达到断点续传的效果。

- 大文件上传，如果网络有问题，需要重新上传
- 分片上传，可以针对失败的分片重新上传
- 分片上传，可支持暂停续传，中途暂停后，可以从上次上传完成的part继续上传
- 后端如果不支持太大的请求实体，也需要分片,nginx也可能不支持，通常都是报413 Request Entity Too Large

通过上述分析，我们可以知道分片上传并不一定比大文件直接上传快，但是它具有断点续传、暂停续传、针对部分失败分片上传等优点。我们也可以通过压缩每个分片，来缩小分片体积，优化上传速度。(例如pako库)


## 文件分片上传要注意的点
- 由于文件File是Blob的子类，所以可以用Blob的slice方法来分片
- 文件的上传进度，每一个分片的进度是可以通过各自的异步请求中的onUploadProgress事件来监听的。
- 文件的暂停上传，我们可以通过xhr.abort的方法来主动取消请求(未上传完成的分片请求)，此时请求会变成cancelld状态。
- 上传完成后，对服务器要发起一个合并文件的请求，告诉服务器合并分片
- 由于浏览器对一个域名存在并行请求限制，一般是6个(这也是为什么分片上传不一定比上传单个文件要快)，所以我们要对并行数量进行限制。

## 断点续传
即使分片上传，我们也要等待所有分片上传完毕，在上传过程中，可能会有分片上传失败的情况。由于分片未全部上传，因此无法通知服务端合成文件。这种情况下，可以通过断点续传来进行处理。

**断点续传指的是:可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。**

断点续传功能的难点在于如何保存已上传的分片信息，一般由两种策略：
- 可以通过localStorage等方式保存在浏览器中，缺点在于如果用户清除了本地文件，会导致上传记录丢失
- 服务端本身知道哪些分片已经上传，因此可以由服务端来保存上传信息。

对于如何比对文件是否是之前上传的文件，我们可以通过md5算法来为分片生成hash值(这个算法只要文件内容一致，生成的hash也一致),记录已经上传的分片hash值。在断点后重新上传时，进行本地分片hash值的对比，如果相同则跳过,继续下一个分片的上传。

# 范围请求
范围请求必须是HTTP1.1以上的版本，如果客户端或者服务端的某一端低于HTTP1.1，我们就不能使用范围请求的功能。

**如何确认服务端是否支持范围请求？在HTTP1.1中，很明确的声明了一个响应头部Accept-Ranges来标记知否支持范围请求。**
```
HTTP/1.1 206 Partial Content
Server: httpserver
Content-Range: bytes 0-6430863/6430864
Content-Length: 6430864
Accept-Ranges: bytes
Server-Check: 3b40940669580bf8ff0b8c00872dc38e
Keep-Alive: timeout=60, max=100
Last-Modified: Mon, 26 Aug 2019 05:49:20 GMT
Content-Type: audio/x-ogg
Cache-Control: max-age=7200
```
例如上面QQ音乐请求音频的例子，响应头部存在字段Accept-Ranges:bytes，说明服务端支持范围请求。

**在客户端，Http1.1中定义了Ranges的请求头部字段，来指定请求实体的范围，它的取值范围是在0 - Content-Length之间**

例如已经下载了1000bytes的资源内容，想接着继续下载之后的资源内容，只要在HTTP请求头部，增加Ranges:bytes=1000-即可。

范围请求限定范围的几种方式:
1. 500-1000:指定开始和结束的范围
2. 500-:指定开始区间，一直传递到结束，0-则代表从开头到结束
3. -500:无开始区间，则只需要最后500bytes的内容实体。
4. 100-300,1000-3000:指定多个范围请求区间。

Content-Range响应头字段，用来标记当前范围请求的内容实体范围和总长度

```
Content-Range:bytes 0-6430863/6430864
```
可以注意到响应头还含有Content-Length头部字段。它的作用和往常一样，只包含当前请求的内容实体长度，而非此资源完整的长度。

## 范围请求的资源产生变化
当我们在一些下载工具中，下载大尺寸资源的时候，偶尔中间暂停过再重新下载，可能会导致她又重头开始下载。

这看似HTTP的范围请求失败了，但是实际上很可能是因为请求的资源，在请求的过程中，发生了变化。

假设我们在下载的过程中，下载的源资源文件发生了变化，但是URL没有改变，此时文件长度等信息可能变化了，极端情况下就算长度没有变化，我们再继续下载，最终可能下载完成后，无法将下载的内容拼接成我们需要的文件。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfuhetttx7j30p408qn14.jpg)

## 校验资源是否改变
**如果我们从服务器上范围请求某个资源，一定要预防资源产生变动，在HTTP缓存中，可以通过ETag或者Last-Modified来标识当前资源是否变化。**
- ETag:当前文件的一个验证令牌指纹，用于标识文件的唯一性。
- Last-Modified:标记当前资源最后被修改的时间。

在HTTP范围请求中，也可以使用这两个字段来区分分段请求的资源，是否有修改过，只需要在请求头中，将它放在**If-Range**这个请求头部字段即可。
- If-Range:需要配合Range使用，值为Etag或者Last-Modified
    - Etag
    - Last-Modified

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfui3rdk8uj30ww0i6n4x.jpg)

## 416错误码
如果请求报文中，对Range填入的范围错误，会返回416状态码
> HTTP 416 Range Not Satisfiable 错误状态码意味着服务器无法处理所请求的数据区间。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range 首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。

## 范围请求流程

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfui7662g7j30k10pm0v1.jpg)


## 与分块传输的对比
Transfer-Encoding首部允许分块编码，这在数据量很大，并且在请求未能完全处理完成之前无法知晓响应的体积大小的情况下非常有用。服务器会直接把数据发送给客户端而无需进行缓冲或确定响应的精确大小——后者会增加延迟。范围请求与分块传输是兼容的，可以单独或搭配使用。

