# HTTP版本差别
## HTTP1.0和HTTP1.1的区别
- 主要区别就是HTTP1.1默认支持长连接:Connection:keep-alive
- 还支持只发送header不发送body,事实上post请求默认就是这样，默认拆分成两个TCP包来发送，这也是和GET请求不同的点
- host字段。

### 长连接和短连接的优点和缺点
长连接的优缺点
- 优点：省去重复的TCP建立(TCP三次握手)和关闭操作(TCP四次挥手)，减少资源浪费，节约时间
- 缺点：随着长连接变多，服务器需要保持过多长连接，这个时候如果服务端不采取一定的策略，例如保活计时，可能会导致服务器承受不住而崩溃。

短连接的优缺点
- 优点：对于服务器来说管理简单，存在的都是有用的链接。
- 缺点：对于频繁请求的客户端，需要花很多时间在建立连接上，浪费时间和带宽。TCP三次握手和四次挥手，以及TCP的拥塞策略(慢启动)都会导致浪费时间和带宽。


## HTTP2.0和HTTP1.1的区别
- 主要区别是HTTP2.0支持多路复用，允许单一的TCP连接发起多种的请求-响应消息
- 支持服务端推送，服务端在HTTP请求到达后，除了返回数据之外，还推送了额外的内容给客户端，并且还支持缓存
- 首部压缩，HTTP2.0压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少。

### 多路复用(Multiplexing)
通过同时请求379张图片，来比对http/1.1与http/2.0的请求速度差别：
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg00t21g1sj30j60d3tfm.jpg)

HTTP1.1:

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg00tffv60j30k00fkwhj.jpg)

HTTP2.2:

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg00tpb017j30r80l6grf.jpg)

可以看到HTTP2.0中明显有速度上的优势。这是因为HTTP2.0使用了多路复用(Multiplexing)

**由于HTTP1.1采用的是序列和阻塞机制，我们发送HTTP请求时，首先要建立TCP连接，经过TCP三次握手后，再发送HTTP消息，但是这个发送是一发一收的，也就是一个TCP连接发送了HTTP请求之后，必须等到响应才能发送下一个HTTP请求(长连接场景下)，这个问题也称为队头阻塞。但是HTTP2.0采用了多工复用TCP连接(双工流)，在一个连接里，允许发起多重的请求-响应消息**

注意：**为什么说了HTTP1.1是序列和阻塞机制，但是上图中仍然可以并行请求？(上图中6个并行请求)，这是因为浏览器开启了多个TCP连接，单个域名有4-8个TCP连接请求的限制（浏览器不同限制也不同），多个TCP连接，就可以发起多个请求。这也是为什么有一些站点将资源放到多个CDN域名的原因之一，值得注意的是，由于TCP是慢启动的，多个TCP连接发起的并行请求，仍然比一个TCP发起的并行请求要慢**

为了解决HTTP1.1的队头阻塞，在以往我们往往需要合并请求：
- CSS雪碧图
- 将图片内联到URL里，以base64的形式
- 将多个js文件合并

为了解决HTTP/1.1的队首阻塞，HTTP/2.0采用了二进制分帧和多路复用。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg01vnbvmqj30k00judhe.jpg)

**多路复用允许一个TCP连接发起多重的请求-响应消息，是基于二进制分帧实现的。**

**那么为什么多路复用是基于二进制分帧实现的呢？，我们先看看HTTP/1.1为什么不能实现多路复用**
#### HTTP/1.1为什么不能实现多路复用
其实在HTTP/1.1中已经有多路复用的概念，称为管道(Pipeline)，但是http1.1规定，服务端响应的发送要根据请求被接收的顺序排队，也就是说，先接收到请求的响应也要先发送。如果收到请求的处理时间长的化，响应生成也慢，就会阻塞已经生成了的响应的发送。也会造成队头阻塞。

为什么HTTP1.1要规定服务端要按顺序返回响应呢？因为HTTP/1.1是按照文本传输的，接收端在接收到响应后，并不能区分多个响应分别对应的请求。所以无法将多个响应的结果进行过重新组装，所以也就实现不了真正意义上的多路复用。

#### 多路复用如何实现
多路复用归功于帧和流(基于二进制)，帧代表最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。在一个TCP连接中可以存在多个流。

**二进制分帧**  
在不改动HTTP/1.1的情况下，HTTP/2.0是如何做到多路复用的？关键就是在应用层和传输层之间增加一个二进制分帧层。
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg02fx93z5j30hd0903zj.jpg)

**在二进制分帧层中，HTTP/2会将所有传输的信息分隔为更小的消息和帧(frame)，并对它们采用二进制格式的编码。其中HTTP/1.1的头部信息会被封装到HEADER frame中，请求实体会被封装到DATA frame中。而TCP连接中，可以承载任意数量的双向数据流(双工流)。**

在过去，HTTP性能优化的关键不在于高宽带，而在于低延迟。TCP连接由于慢启动的机制(一开始传输的数据很小，逐渐增大)，由于这种原因，让原本就具有突发性和短时性的HTTP变得十分低效。HTTP/2.0通过让所有数据流共用一个连接，可以更有效的使用TCP连接，让高宽带也能真正的服务于HTTP的性能提升。

### 服务端推送
在过去，我们为了加载一个网页，要加载其相关的所有资源，但是这些资源的请求往往是一个个发起的，为了解决这个问题(过去是合并请求，使用内联资源等手段)，HTTP/2.0有了服务端推送的机制，服务端推送是一种客户端请求之后，在响应的时可以携带除了响应之外的资源。例如我们请求一个网站的主页，其对应的所有相关资源，在一次请求中全部返回。并且可以缓存。

### 首部压缩
HTTP/1.1不支持HTTP首部压缩，为此SPDY和HTTP/2.0应运而生，SPDY采用的DEFLATE算法压缩，而HTTP/2则使用了专门为首部压缩而设计的HPACK算法。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg02scedq4j30h208labe.jpg)


## HTTPS
HTTP通信过程中，由于是明文通信，所以存在被窃听、篡改和身份伪装。

其中窃听我们是没办法防范的，无论世界哪个角落的服务器在和客户端通信时，在此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节中会遭到恶意窥视行为。即使已经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg19m4l7qrj30x00f2qdo.jpg)

**窃听者是如何做到篡改的?由于窃听者能够获取到通信内容，所以能够拦截通信内容并进行篡改，这种遭攻击者拦截并篡改内容的攻击称为中间人攻击(Man-In-The-Middle,MITM)，中间人此时能够伪装成服务端/客户端，例如服务端响应时，攻击者伪装成服务端。**

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg19svmuttj30xi0f4akt.jpg)

**既然窃听无法防止，我们要做的就是让窃听者无法解析通信内容，让接收方收到内容时能够识别内容是否被篡改、身份是否是伪装的**


### HTTPS=HTTP+加密+认证+完整性保护
HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL(Secure Socket Layer)和TLS(Transport Layer Security)协议替代而已。通常HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。**所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP**
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1fm2xctvj30gv06pt99.jpg)

**在采用SSL之后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能,SSL是独立于HTTP的协议，所以不光是HTTP，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。SSL是当今世界上应用最为广泛的网络安全技术**

记住我们要解决两个问题：
- 如何让窃听者无法解析通信内容
- 如何让客户端/服务端鉴别出对方为目标对象，而不是伪装对象


### 公开密钥加密技术
SSL采用公开密钥加密(公钥加密)(Public-key cryptography)的加密处理方式。

- 共享密钥加密(对称密钥)  
加密和解密用同一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密。共享密钥方式加密时必须将密钥也发送给对方。可是在发送密钥的时候，如果被监听，那么密钥也会落入攻击者之手，也就失去了加密的意义。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1fygsvrsj30ga0a6acp.jpg)

- 使用两把密钥的公开密钥加密(非对称密钥)  
公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key)，另一把叫做公开密钥(public key)。顾名思义，私钥不能让其他任何人知道，而公钥可以随意发布。**发送密文的一方(通常是客户端，因为客户端发送的信息更需要被保密),使用公钥进行加密处理，对方收到被加密的信息后，再使用自己的私钥进行解密。**这种方式，不需要发送用来解密的私有密钥，所以也不必担心密钥被窃听盗走(放在服务器)。但由于服务端发送的信息使用私钥加密的，只要任何拥有公钥的人都可以解密，所以服务端发送到客户端的信息，是有可能被窃听并且分析的。

想要根据加密的内容和公钥来解密是异常困难的，因为解密过程就是在对离散对数进行求值。如果能对一个非常大的整数做到快速因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1g60ougfj30hl0d6tdn.jpg)

### HTTPS采用混合加密机制
**HTTPS采用共享密钥加密(对称密钥)和公开密钥加密(非对称密钥)两者并用的混合加密机制。这是因为非对称密钥加密和对称密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式**

个人理解：这个对称密钥加密的密钥是由客户端发送的，因为在交换密钥环节使用的非对称加密，只能保证客户端发送的数据不能被解析。
- 服务器发送自己的公钥给客户端
- 客户端通过该服务器公钥加密接下来对称密钥中的密钥(客户端生成的一个被称为Pre-master secret的随机密码串)，并发送给服务器
- 服务器通过自己的私钥解密得到客户端发送过来的对称密钥
- 客户端和服务器通过对称密钥通信(这是安全的，因为密钥已经安全到达双方)

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1glwn7m8j30em0bnq79.jpg)


### 加密仍然无法解决身份伪装(证书)
遗憾的是，非对称密钥加密的方式，仍然存在一些问题，这是因为非对称密钥并不能证明密钥本身就是货真价实的公钥(不能确认就是服务器的公钥，可能是攻击者拦截后改成自己的公钥)。比如正准备和某台服务器建立非对称密钥加密方式的通信时，在服务器公钥传输的过程中，真正的公钥可能已经被攻击者替换调了。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1h3oorkmj30hy0kkacv.jpg)

**为了解决上述身份伪装的问题，可以使用由数字整数认证机构(CA,Certificate Authority)办法的非对称密钥证书。**

- 首先，服务器向数字整数认证机构提出公开密钥的申请。认证机构在判别身份后，会对申请的公开密钥(服务器的)做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书(数字证书)后绑定在一起。
- 服务器会将这份由认证机构颁发的公钥证书(数字证书)发送给客户端。
- 客户端内置各大认证机构的公钥，对数字证书(是通过认证机构的私钥加密的)进行解密。
- 如果客户端验证通过，可以知道服务器的公钥是值得信赖的。

简单来说,数字签名就是将服务器公钥和信息通过加密方法例如MD5加密后的信息。而数字证书是利用认证机构私钥加密服务器信息+数字签名后的信息。  

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1hbn7wclj30ie0edgt5.jpg)

**数字证书的作用就是利用认证机构的权威，来保证服务器的公钥就是当前公钥，并没有被篡改。**

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1h6bsqh2j30dc0c8dgx.jpg)
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1h5gvtztj30i20bvmy4.jpg)

**其中，客户端通过内置(多数浏览器都会在内部植入常用认证机构的公钥)，解决了公钥被篡改的风险，保证一定是认证机构的公钥**

这样就防止了中间人攻击:
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1hb16a6yj30hz0czwg8.jpg)


### HTTPS安全通信过程

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1hechyvgj30j80l7wna.jpg)

1. 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包 含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
2. 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL版本以及加密组件。服务器的 加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。 
4. 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL握手协商部分结束。
5. SSL第一次握手结束之后，客户端以 Client Key Exchange 报 文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。
6. 接着客户端继续发送 Change Cipher Spec 报文。该报文会提 示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。
7. 客户端发送 Finished 报文。该报文包含连接至今全部报文的 整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确 解密该报文作为判定标准。
8. 服务器同样发送 Change Cipher Spec 报文。
9. 服务器同样发送 Finished 报文。
10. 服务器和客户端的 Finished 报文交换完毕之后，SSL连接 就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用 层协议的通信，即发送 HTTP 请求。
11. 应用层协议通信，即发送 HTTP 响应。
12. 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。

个人理解，以上的关键步骤可以精简为：
1. 客户端告诉服务端自己支持的SSL加密算法
2. 服务端告诉客户端自己支持SSL，并且从客户端的加密算法中选择一个作为响应
3. 服务端发送自己的公钥。
4. 客户端生成一种Pre-master secret的随机密码串，并用服务器的公钥进行加密，发送给服务器，并告诉服务器，接下来对称加密通信过程用这个随机密码串加密。
5. 服务器通过自己的私钥(非对称加密)来得到客户端生成的随机密码串。
6. 客户端和服务器通过随机密码串加密(对称加密)的方式通信。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg1hnpmr5rj30hz0ax45n.jpg)