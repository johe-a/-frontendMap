<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-07-18 21:10:58
--> 
# 排序总结
时间复杂度和空间复杂度的总结：
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggwg6rc12bj30s10jkdiz.jpg)

# 冒泡排序
通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或者最小值。
```javascript
function bubbleSort(arr){
    let length = arr.length;
    for(let i = 0;i < arr.length;i++){
        //i控制循环比较次数，算出length轮最大值就得到有序数组
        for(let j = 0; j< arr.length - 1 - i;j++){
            //由于每一轮冒泡出最大值，则i轮冒泡出i个最大值，也就是后i个数不需要再冒泡
            if(arr[j]>arr[j+1]){
                [arr[j],arr[j+1]]=[arr[j+1],arr[j]]
            }
        }
    }
    return arr;
}
```

## 单向冒泡优化
如果某一轮冒泡没有发生任何的交换，说明已经是有序数组，没必要再排序

```javascript
function bubbleSort(arr){
    let length = arr.length;
    for(let i = 0; i < length ;i++){
        let flag = true;
        for(let j = 0;j < length - 1 - i;j++){
            if(arr[j]>arr[j+1]){
                flag = false;
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
            }
        }
        if(flag){
            return arr;
        }
    }
    return arr;
}


```
# 选择排序
依次找到剩余元素的最小值或者最大值，放在末尾或者开头。
```javascript
function selectSort(arr){
    let length = arr.length;
    for(let i = 0 ; i< length - 1;i++){
        let min = i;
        for(let j = i + 1 ;j < length ;j++){
            if(arr[j]<arr[min]){
                min = j;
            }
        }
        [arr[i],arr[min]] = [arr[min],arr[i]];
    }
    return arr;
}

```
# 插入排序
假定当前元素之前的元素已经经过排序，找到自己的位置并插入
```javascript
function insertSort(arr){
    let length = arr.length;
    for(let i = 0;i < length;i++){
        let j = i + 1;
        //如果arr[j]>arr[i]说明顺序是对的，不需要插入
        if(arr[j]<arr[i]){
            let k = i;
            let temp = arr[j];
            while(k>=0){
                if(temp<arr[k]){
                    arr[k+1] = arr[k];
                    k--;
                }else{
                    break;
                }
            }
            arr[k+1] = temp;
        }
    }
    return arr;
}

```
## 拆半插入排序实现
在插入排序的基础上，由于我们假定之前的数组元素是有序的，所以我们的插入方式可以进行二分查找法来进行插入。由于前序是有序的，二分每次从固定的区域内拆半，缩小范围，比直接插入的一个个比较更快。

```javascript
function insertSort(arr){
    let length = arr.length;
    for(let i = 0; i < length ; i++){
        let j = i + 1;
        if(arr[j] < arr[i]){
            let low = 0;
            let high = i - 1;
            while(low < high){
                let mid = ( low + high) >> 1;
                if(arr[j]>mid){
                    low = mid +1;
                }else{
                    high = mid - 1;
                }
            }
            let temp = arr[j];
            for(let k = j; k > low ; k--){
                arr[k] = arr[k-1];
            }
            arr[low] = temp;
        }
    }
    return arr;
}

```
# 希尔排序
希尔排序是插入排序的一种，也称作缩小增量排序，是直接插入培训算法的一种更高效的改进版本。  
希尔排序是把记录按下标的一定增量分组，对每组使用直接插入培训算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，算法便终止。

**希尔排序是如何优化直接插入排序的？假设有一组数长度为15,并且最后一个数是最小的，则该数需要和前面一一对比很多次才行，希尔排序通过一开始的大增量，如果末尾有一个最小数，会被替换到最前面，减少比较次数**

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggwrz4cxlij30rz0lqjxi.jpg)

横坐标代表着执行顺序，当间隔为7的时候，先比较11和6,然后比较2和26,再比较12和29...直到比较02和11和06,当前间隔的比较结束。

当间隔为3的时候，先比较26和02，再比较09和02，再比较10和12，再比较13和26和02...

```javascript
function shellSort(arr){
    let length = arr.length;
    let gap = length >> 1;
    while(gap){
        //i定义当前增量的比较位置
        for(let i = gap;i < length;i++){
            //j定义当前增量的比较元素
            for(let j = i - gap;j >= 0 ; j -= gap){
                if(arr[j+gap]<arr[j]){
                    [arr[j+gap],arr[j]]=[arr[j],arr[j+gap]]
                }else{
                    break;
                }
            }
        }
        gap = gap >> 1;
    }
    return arr;
}

```