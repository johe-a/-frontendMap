<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-05-18 22:54:07
--> 
# 前言
> I/O是Input/Output的缩写，即输入输出端口，是信息处理系统(例如计算机)与外部世界(可能是人类或另一信息处理系统)之间的通信。  
> 输入是系统接收的信号或者数据，输出则是从其发送的信号或者数据。

# 关于IO
每个设备都会有一个专用的I/O地址，用来处理自己的输入输出信息，例如网络I/O，磁盘I/O等。  
一次I/O操作分为**等待资源、使用资源**两个阶段。

## 阻塞与非阻塞I/O
阻塞与非阻塞I/O是对于操作系统内核而言的，发生在**等待资源阶段**，根据发起I/O请求是否阻塞来判断。

- 阻塞I/O：用户进程在发起一个I/O操作之后，只有收到响应或者超时才可以进行处理其它的事情，否则I/O会一直阻塞。例如读取磁盘文件时，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才算完成。阻塞的这段时间对CPU资源是浪费的。
- 非阻塞I/O：用户进程发起I/O之后，如果数据没有就绪，会立刻返回（标志数据资源不可用），此时CPU时间片可以用来做一些其他事情。

## 同步与异步I/O
同步和异步I/O发生在**使用资源阶段**,根据实际I/O操作来判断。

- 同步I/O:应用发送或者接收数据后，如果不返回，继续等待（此处发生阻塞），直到数据成功或者失败返回。
- 异步I/O:应用发送或接收数据后立刻返回，数据写入OS缓存，由OS完成数据发送或者接收，并返回成功或失败的信息给引用。Node就是典型的异步I/O

## 用户空间与内核空间
操作系统为了支持多个应用同时运行，需要保证不同进程间相对独立，内核的安全，因此不能谁都操作内核空间。操作系统将内存空间划分为用户空间、内核空间两部分。
- 用户空间：应用程序代码和数据。
- 内核空间：存放内核代码和数据。

从OSI七层模型图和网际网谢雨族来看待用户空间与内核空间的分界线:  
传输层之上为用户空间，下四层为内核空间
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gex0gmkdmij30ob0cumxi.jpg)

# 操作系统I/O模型演进
操作系统的I/O模型分为以下几种：
- 同步阻塞I/O
- 同步非阻塞I/O
- I/O复用
- 信号驱动I/O
- 异步I/O

## 同步阻塞I/O
从应用程序开始进行系统调用->数据就绪进行拷贝->拷贝结束，这之间应用程序都处于等待状态，不能做其它事情，直到将数据拷贝到用户空间或出错才返回，称之为阻塞I/O模式。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gex0oz0bx0j30se0j23zu.jpg)

## 同步非阻塞I/O
同步非阻塞I/O在每次调用之后，如果数据没有就绪就会立即返回，之后通过**轮询**来检查I/O操作是否就绪，这对CPU资源是一个极其浪费的操作。直到数据就绪将数据从内核拷贝到用户空间，返回成功指示给到引用程序。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gex0r8p6qdj30sg0jcjtf.jpg)

## IO多路复用
链接(socket)并发大的情况下，上面两种就不适合了。前面一个处理不完，后面就只能干等。这时候就用到了I/O多路复用的技术，分为两步，先进行select,数据就绪后，再调用recufrom进行真正的I/O读写操作。它的高级之处在于能够一个线程同时处理多个Socket。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gex0uyu9mjj30rm0jgwg9.jpg)

**这里的I/O通常指网络I/O，多路指多个Socket链接，复用指操作系统进行运算调度的最小单位线程。也就是多个网络I/O复用一个或者少量的线程来处理Socket**

> 多路复用的实现:select、poll、epoll、kqueue(和epoll一样)

- select:通过轮询检查在文件描述符上设置的标识位来进行判断，**select的轮询相当于在数据库中查找一条没有建立索引的数据**,对所有的socket进行全部遍历，这对CPU是浪费的。并且select存在单个进程所能打开的文件描述符最大只能是1024的限制。
- poll:相当于select，但基于链表来实现，没有1024限制，但依然是线性遍历，性能低下。
- epoll:通过callback回调通知机制，不是每次调用都对链接进行线性遍历，在1GB内存的机器上能监听大约10万个端口，远超过select的1024限制，具体可以在服务器上查看```cat /proc/sys/fs/file-max```


## 信号驱动I/O
仅在 Unix 上支持，与 I/O 多路复用相比避免了 select 的阻塞轮询。应用程序进行系统调用后立即返回，处理其它事物，在数据就绪之后系统会发送一个 SIGIO 信号到应用程序，应用进程开始读取数据

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gex15zq6eqj30sq0jg40d.jpg)

## 异步I/O模型
异步 I/O 模型是目前最理想的一种形式，应用程序发起系统调用后无需等待直接返回当前调用状态，进行后续的其它任务，结果由内核完成 I/O 操作之后通过回调通知到我们的应用程序，中间没有阻塞过程。

在 Linux2.6 之后增加了异步 I/O 的实现方式 AIO，但是很少系统能够实现。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gex16fvq5uj30rk0iwmyh.jpg)


