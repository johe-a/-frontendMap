<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-04-26 22:56:45
 -->
# Events模块
***在Node总一个很重要的模块Events（EventEmitter事件触发器）,也称为发布订阅模式，为什么说它重要，因为在Node中大多数模块都依赖于此，例如Net、HTTP、fs、Stream等。除了这些系统模块，Express、koa框架中也能看到EventEmitter的踪迹。在Vue中，跨组件交流的EventBus也是类似EventEmitter。***

与浏览器中的事件不同的是它不存在事件冒泡、preventDefault、stopPropagation等方法。

EventEmitter提供了on()、once()、removeListener()等会方法对事件进行监听移除。

问题：
- EventEmitter是什么，如何使用
- Node核心模块Stream、fs、Net是怎么使用EventEmitter的
- Express/koa基于此实现，如何实现一个基于EventEmitter的自定义对象
- 高并发场景下雪崩问题如何利用EventEmitter解决
- 事件是否等价于异步


## 基本使用

```javascript
const EventEmitter = require('events').EventEmitter;
const emitter = new EventEmitter();

emitter.on("起床",function(time){
    console.log(`早上${time}开始起床，新的一天加油`);
})

//早上6:00起床，新的一天加油
emitter.emit("起床","6:00");

```

将this传给监听器，默认情况下，监听器的this指向EventEmitter实例
```javascript
emitter.on("event",function(a,b){
    console.log(a,b,this,this===emitter);
    /*
    a,b,EventEmitter{
        _events:{event:[Function]},
        _eventsCount:1,
        _maxListeners:undefined
    }
    true
    */
});
emitter.emit("event",'a','b');
```
如果我们想将this传给EventEmitter的监听器，有两种方法：
- 使用bind
- 利用匿名函数的闭包（与Bind原理一致)
- 使用箭头函数

```javascript
//使用bind
function listener(a, b) {
    console.log(this);
    console.log(this === emitter);
}
emitter.on("event", listener.bind(this));

//使用匿名函数
emitter.on("event", (function (that) {
    return function (a, b) {
        console.log(that);
        console.log(that === emitter);
    }
})(this));

//使用箭头函数
emitter.on("event", (a, b) => {
    console.log(this);
    console.log(this === emitter);
})
```

## 异步还是同步
EventEmitter以注册的顺序 ***同步地*** 调用所有监听器。所以必须确保事件的排序正确，且避免竞态条件。

```javascript
const events = require("events");
const emitter = new events.EventEmitter();

emitter.on("test",function(){
    console.log(111);
})
emitter.emit("test");
console.log(222);

// 111
// 222
```


适当时，可以使用setImmediate()宏异步任务和process.nextTick()微异步任务方法切换到异步的操作模式。

类似的宏异步任务还有:setTimeout\setInterval\MessageChannel等等

类似的微异步任务还有:promise\MutationObserver（用于监听DOM）

```javascript
emitter.on("test",()=>{
    //同步发生
    setImmediate(()=>{
        console.log('111')
    })
});
emitter.emit("test");
console.log(222);
//222
//111
```

## 系统模块如何继承EventEmitter
所有能够触发事件的对象都是EventEmitter类的实例，这些对象有一个eventEmitter.on()函数，用于将一个或者多个函数绑定到命名事件上。  
例如net.Server会在每次有新连接时触发事件,fs.ReadStream会在打开文件时触发事件,stream会在数据可读时触发事件。

系统模块是如何继承EventEmitter的：
```javascript
//Stream模块
const EventEmitter = require("events");
const utils = require("util");

function Stream(){
    //继承EventEmitter实例属性
    EventEmitter.call(this);
}
//设置EventEmitter为Stream原型
util.inherits(Stream,EventEmitter);

//Net模块
const EventEmitter = require('events');
const util = require('util');

function Server(options, connectionListener) {
  if (!(this instanceof Server))
    return new Server(options, connectionListener);

  EventEmitter.call(this);
}
util.inherits(Server, EventEmitter);

```

## 如何继承EventEmitter

```javascript
const EventEmitter = require("events");

class MyEmitter extends EventEmitter{};

//或者是
function MyEmitter(){
    EventEmitter.call(this);
}
//相当于MyEmitter.prototype.__proto__ = EventEmitter.prototype
Object.setPrototypeOf(MyEmitter.prototype,EventEmitter.Prototype);
//构造函数也要继承，静态方法
//相当于MyEmitter.__proto__ = EventEmitter
Object.setPrototypeOf(MyEmitter,EventEmitter);


```

## once方法
当触发多次相同名称事件，通过once添加的监听器只会执行一次，并且再执行之后会解除once的监听器，相当于on方法和removeListener方法的组合。

```javascript
emitter.once("test",function(){
    console.log("once");
})
emitter.on("test",function(){
    console.log("on");
})

emitter.emit("test");
emitter.emit("test");
emitter.emit("test");
//once
//on
//on
//on
```

对于需要查询数据库的数据，我们称之为热点数据，在高并发情况下对数据库造成一定的压力，我们可以通过once方法来解决。

这里用fs模块读取文件来模拟查询数据库:
```javascript
const events = require("events");
const emitter = new events.EventEmitter();
const fs = require("fs");

const status = {};
// 或者使用weakMap 
const status = new WeakMap();

const select = function(file,filename,cb){
    //将文件作为先将回调推入到emitter中
    emitter.once(file,cb);
    if(stats[file] === undefined){
        status[file] = 'ready'
    }
    if(status[file]==='ready'){
        //表明文件正在读取中，避免再次读取
        stats[file] = 'pending';
        //如果file是个大文件，这将是个非常耗时的工作，回调将会在文件读取完毕后执行
        fs.readFile(file,function(err,result){
            emitter.emit(file,err,result);
            //读取完毕，可以再次读取
            status[file] = 'ready';

            setTimeout(function(){
                //避免大文件作为键值造成内存泄漏无法回收
                delete status[file];
            },1000);
        })
    }
}

//假设有多个请求要读取a文件，
for(let i = 0;i<10;i++){
    //即使调用了10次，也可能只读取了一次文件
    select('/a.txt','a.文件',function(err,result){
        console.log(err,result);
    })
}
```
上面应该注意到一点，使用对象来将大文件作为key时，无法避免内存泄漏，需要自己手动释放，可以使用WeakSet(成员是弱引用),WeakMap(key是弱引用)替代.

## 错误处理(防止程序因错误而退出进程)
当EventEmitter实例出错时，应该触发'error'事件。  
如果没有为'error'事件注册监听器,则当'error'事件触发时,会抛出错误、打印堆栈跟踪、***并退出Node进程***
```javascript
//将导致抛出错误并使得Node.js崩溃
emitter.emit('error',new Error('错误信息'));
```
作为最佳实现，应该始终为error事件注册监听器
```javascript
emitter.on('error',function(err){
    console.error(err);
})
emitter.emit('error',new Error('this is a error'));

```

# 加密模块Crypto
> Crypto加密模块是C/C++实现这些算法后，暴露给Node的模块，包含对OpenSSL的哈希、HMAC、加密、解密、签名、以及验证功能的封装。

查看系统所支持的算法：***openssl list-cipher-algorithms***


## 对称密钥加密Cipher
>Cipher累用于加密数据，属于对称密钥加密，假设通信双方为A、B,
>A使用Key对明文进行加密传输，B接收到密文后，使用同样的key进行解密得到明文。

Cipher加解密：  
数据加密：  
- crypto.createCipheriv(algorithm,pwd,iv)创建cipher加密对象
    - algorithm指定加密算法
    - pwd指定加密的密码
    - vi向量

Cipher实例有如下方法：
- cipher.update(data,inputFormat,outputFormat),生成加密数据
    - data代表要加密的数据
    - inputFormat代表传入数据的格式，可以是'utf8','ascii','latin1'
    - outputFormat为加密数据的输出格式,可以是'latin1','base64','hex'.没有则返回Buffer 

- cipher.final(format),返回任意加密内容


```javascript
function cipher(str){
    try{
        const crypto = require('crypto');
        //根据算法、密码、向量创建ciper加密对象
        const cipher = crypto.createCipheriv('desc-ecb','12345678','');
        //生成加密数据
        let encrypted = cipher.update(str,'uft8','hex');
        encrypted += cipher.final('hex');

        return encryted;
    }catch(e){
        console.log('加密失败');
        return e.message || e;
    }
}
//81c66a1d39d302205c55f0afac95c06bc985155d4ddb751c
cipher('hello world !!!')

```

数据解密:
- crypto.createDecipheriv(algorithm,pwd,iv)指定算法、密码、向量创建decipher解密对象

```javascript
function decipher(encrypted){
    try{
        const crypto = require('crypto');
        const decipher = crypto.createDecipheriv('des-ecb','12345678','');
        let decrypted = decipher.update(encrypted,'hex','utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    }catch(e){
        console.log("解密失败");
        return e.message||e;
    }
}

```

## MD5加密
MD5的作用和特点：
- 作用
让大容量信息在数字签名软件签署私人秘钥前被压缩成一种保密格式，***也就是把一个任意长度的字节串变成一定长度的十六进制数字串（32个字符）一致性验证***
- 特点
    - 输入两个不同的明文不会得到相同的输出值
    - 根据输出值，不能得到原始的明文，即过程不可逆

MD5三种实现方式:
- crypto.createHash(algorithm)
创建并返回一个hash对象，它是一个指定算法的加密hash，用于生成hash摘要。  
参数algorithm可选择系统上安装的OpenSSL版本所支持的算法。

- hash.update(data)
更新hash的内容为指定的data,当使用流数据时可能会多次调用改方法。

- hash.digest(encoding='binary')
计算所有传入数据的hash摘要，encoding可以为hex、binary、base64

```javascript
const crypto = require('crypto');
const md5 = str =>{
    return crypto.createHash('md5').update(str,'utf8')
};

console.log(md5('123456789'));

console.log(md5('123456789').toUpperCase()); 

```


# Buffer(缓冲区)
>在引入TypeArray之前，js语言没有用于读取或者操作二进制数据流的机制，Buffer类是作为Node的一部分引入的，用于在TCP流、文件系统操作、以及其他上下文中与八位字节流进行交互。***也就是Node可以通过Buffer来处理二进制流数据并且与之进行交互***

Buffer用于读取或者操作二进制数据流，作为Node的API，使用时无须require，用于操作网络协议、数据库、图片和文件I/O等一些需要大量二进制数据的场景。

Buffer在创建时大小已经被确定且无法调整，在内存分配这块Buffer是由C++层面提供而不是V8。

二进制、流(Stream)、缓冲区(Buffer)都是些什么呢？

## 二进制数据
什么是二进制数据，有什么作用？

二进制数据使用0和1来表示数据，为了存储数据，计算机需要先将这些数据转换成二进制来表示，例如我想存储66这个数字，计算机会将数字66转化成二进制01000010表示:

|---|---|---|---|---|---|---|---|
|128|64|32|16|8|4|2|1|
|0|1|0|0|0|0|1|0|


数字只是数据类型之一，其他的还有字符串、图像、文件等。例如我们要获取M的二进制表示，需要先转化成ASCII码后，再转化为二进制表示，JS通过charCodeAt()来获取ASCII码。
```javascript
'M'.chartCodeAt();
```

## Stream
流，Stream是对输入输出管道的抽象，这里的管道可以是文件、内存、网络等。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8sinjkxgj31400nogo7.jpg)

流具有方向性，当程序从某个数据源读取数据，会开启一个输入流。当我们的程序需要写出数据到指定数据源时(文件、网络等)时，则开启一个输出流。  
当有一些大文件操作时，我们就需要Stream像管道一样，一点一点的将数据流出。

一个恰当的比喻，当我们有一桶水需要浇一片菜地，如果我们将一桶水全部倒入菜地（假设这桶水非常多），需要非常大的力气（这里的力气就比作计算机中的硬件性能）。如果我们拿来了水管将谁一点点流入我们的菜地，就不需要那么大的力气就可以完成（用时间换性能）

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8sivcbflj30zk0logr6.jpg)


## Buffer
Buffer是二进制数据的容器，是Uint8Array的子类

伴随着时间的推移，每一个过程都会有一个最小或者最大数据量。
- 如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。
- 如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理。

举个例子：与公共汽车站类似，通常汽车会隔一定时间来一趟，在这个时间到达之前就算乘客已经满了，车辆也不会提前发车，早到的乘客就需要先在车站进行等待，假设到达的乘客过多，后到的一部分则需要等下一趟车到来。

- 公交汽车站：类似于Node中的缓冲区(Buffer)  
- 乘客：类似于数据流，我们无法控制乘客到达的速度，所以我们也无法控制数据流到达的时间
- 何时发车:我们可以决定何时发送数据。

在Node中，Buffer对象用于以字节序列的形式来表示二进制数据。  
许多API（例如流和文件系统操作）都支持Buffer，因为与操作系统或者其他进程的交互通常总是以二进制数据的形式发送。

***Buffer类是js语言内置的Uint8Array类的子类。只要支持Buffer的API都可以接受Uint8Array。***

***Buffer类与的实例，以及Uint8Array(八位无符号整数，U代表无符号，int代表整数,8代表八位)，都是类似于从0到255之间的整数数组(因为是8位)。一个Buffer的大小在创建时确定，且无法更改。***

### Buffer基本使用
创建Buffer:  
在6.0之前的版本中，Buffer实例是使用Buffer构造函数创建的，该函数根据提供的参数以不同方式分配返回的Buffer。
```
new Buffer();
```
现在可以通过Buffer.from()、Buffer.alloc()、Buffer.allocUnsafe()三种方式来创建。

```javascript
//创建一个包含字节[1,2,3]的Buffer
const buf4 = Buffer.from([1,2,3]);

//创建一个包含字节[1,1,1,1]的Buffer
//其中所有条目均使用`(value & 255)`进行截断以符合0-255的范围。
const buf5 = Buffer.from([257,257.5,-255,'1']);

//创建一个Buffer,其中包含'test'的UTF-8编码字节
//[0x74,0xc3,0xa9,0x73,0x74](以十六进制表示)
//[116,195,169,115,116](以十进制表示)
const buf6 = Buffer.from('test');

//创建一个包含Latin-1字节 [0x74,0xe9,0x73,0x74]的Buffer
const buf7 = Buffer.from('tést', 'latin1');

//创建一个长度为10的Buffer
//其中填充了全部值为`1`的字节。
const buf1 = Buffer.alloc(10);

// 创建一个长度为 10、且用 0x1 填充的 Buffer。 
const buf2 = Buffer.alloc(10, 1);

// 创建一个长度为 10、且未初始化的 Buffer。
// 这个方法比调用 Buffer.alloc() 更快，
// 但返回的 Buffer 实例可能包含旧数据，
// 因此需要使用 fill()、write() 或其他能填充 Buffer 的内容的函数进行重写。
const buf3 = Buffer.allocUnsafe(10);
```

### Buffer与字符编码
当在Buffer和字符串之间转换时，可以指定字符编码，如果为指定字符编码，则使用UTF-8作为默认值。
- utf8:多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8。
- base64:Base64编码。
- ascii:仅适用于 7 位 ASCII 数据。此编码速度很快，如果设置则会剥离高位。
- utf16le:2 或 4 个字节，小端序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。

```javascript
const buf = Buffer.from('hello world', 'utf8');

console.log(buf.toString('hex'));
// 打印: 68656c6c6f20776f726c64
console.log(buf.toString('base64'));
// 打印: aGVsbG8gd29ybGQ=
```

### 字符串与Buffer类型互转
字符串转Buffer
```javascript
//<Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
const buf = Buffer.from('hello world', 'utf8');
```
Buffer转换为字符串  
- toString([encoding],[start],[end])
    - encoding编码方式，默认为UTF-8
    - start\end实现部分转换
```javascript
console.log(buf.toString('UTF-8'));
```
start\end会将字符截断造成乱码：
```javascript
const buf = Buffer.from('Node.js 技术栈', 'UTF-8');

// Node.js �
console.log(buf.toString('UTF-8', 0, 9)); 

// Node.js 技
console.log(buf.toString('UTF-8', 0, 11)); 
```
***因为技这个字在Buf中对应的字节为8a 80 e6我们只截取到了8a，这个时候就会造成字符被截断出现乱码。***

### Buffer与迭代器
Buffer类实例可以使用for..of语法进行迭代，以下方法也可以用于创建迭代器。
- buffer.values()
- buffer.keys()
- buffer.entries()

```javascript
const buf = Buffer.from([1, 2, 3]);

for (const b of buf) {
  console.log(b);
}
// 打印:
//   1
//   2
//   3

```

### Buffer内存机制
***由于Buffer需要处理的是大量的二进制数据，假如用一点就向系统去申请，则会造成频繁的向系统社情内存调用，所以Buffer所占用的内存不由v8分配，而是在Node的C++层面完成申请，在Javascript中进行内存分配。因此，这部分内存我们称之为堆外内存。***

### Buffer内存分配原理：  
Node采用了slab机制预先在C++申请、事后在JS分配，是一种动态的管理机制。  
使用Buffer.alloc(size)传入一个指定的size就会申请一块固定大小的内存区域，slab具有如下三种状态：
- full:完全分配状态
- partial:部分分配状态
- empty:没有被分配状态

#### 大对象还是小对象
Node以8KB为界限来区分是小对象还是大对象,在buffer.js中可以看到如下代码:
```javascript
Buffer.poolSize = 8 * 1024;
```

#### 对象分配
以下代码示例，在加载时直接调用了createPool()相当于直接初始化了一个8KB的内存空间，这样在第一次进行内存分配时也会变得更高效，在通过poolOffset这个变量记录已经使用了多少字节。
```javascript
Buffer.poolSize = 8 * 1024;
var poolSize,poolOffset,allocPool;

function createPool(){
    poolSize = Buffer.poolSize;
    allocPool = createUnsafeArrayBuffer(poolSize);
    poolOffset = 0;
}
createPool();
```
新构造的slab如下所示：
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9wmotj3bj30zg094ab7.jpg)

尝试分配一个大小为2048的Buffer对象：
```javascript
Buffer.alloc(2 * 1024);
```
slab内存如下所示：
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9wnghedbj30zw0aa75o.jpg)

Buffer内存分配总结：
1. 在初次加载时就会初始化一个8KB的内存空间
2. 根据身亲搞得内存大小分为小Buffer对象和大Buffer对象
3. 如果是小Buffer，会继续判断这个小slab空间是否足够
    - 如果空间足够就去使用剩余空间，同时更新slab分配状态，偏移量会增加
    - 如果空间不足，slab空间不足，就会去创建一个新的slab空间来分配
4. 大Buffer,会直接走createUnSafeBuffer(size)直接向C++层面申请
5. 不论是小Buffer对象还是大Buffer对象，内存分配是在C++层面完成，内存管理在JavaScript层面，最终还是可以被V8的垃圾回收标记所回收。

### Buffer应用场景
- 文件格式转化，例如csv文件的buffer转化为utf8需要添加bom头，这个时候我们就要操作buffer
- I/O操作，流(stream)会自动创建Buffer
例如通过流的方式将input.txt信息写入到output.txt文件。
```javascript
const fs = require('fs');

//创建可读流
const inputStream = fs.createReadStream('input.txt');
//创建可写流
const outputStream = fs.createWriteSteam('output.txt');

//管道读写
inputStream.pipe(outputSteam);

```

- 优化传输速度，将String转化成Buffer再传递,传输性能能够得到显著提升
```javascript
const http = require('http');
let s = '';
for (let i=0; i<1024*10; i++) {
    s+='a'
}

const str = s;
const bufStr = Buffer.from(s);
const server = http.createServer((req, res) => {
    console.log(req.url);

    if (req.url === '/buffer') {
        res.end(bufStr);
    } else if (req.url === '/string') {
        res.end(str);
    }
});

server.listen(3000);
```

# 线程和进程
## 进程(process)
> 进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，***是系统进行资源分配和调度的基本单位***,是操作系统的基础，进程是线程的容器。
> Node通过```node app.js```开启一个服务进程，多进程就是进程的复制(fork),fork出来的每个进程都拥有自己的独立空间地址、数据栈。一个进程无法访问另外一个进程里定义的变量、数据结构。只有建立了IPC(Inter-Process Communication，进程间通信)，进程之间才可以数据共享。

***node进程查看和命名***：
```javascript
const http = require("http");
http.createServer().listen(3000,()=>{
    //进程命名
    process.title = '测试进程Node.js';
    //查看进程id
    console.log(`process.pid:${process.pid}`);
})
```
再通过mac自带的活动监视器查看:
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gedezwuydyj31400u0k03.jpg)

## 线程
> 线程是操作系统能够进行运算调度的最小单位，线程属于进程，被包含在进程之中，一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。

同一块代码，可以根据系统CPU核心数启动多个进程，每个进程都有数据自己的独立运行空间，进程之间是不互相影响的。同一进程中的多条线程将 *** 共享该进程中的全部系统资源,如虚拟地址空间，文件描述符和信号处理等 ***。 但同一进程中的多个线程有各自的调用栈(call stack),自己的寄存器环境(register context)，自己的线程本地存储(thread-local storage)，线程又有单线程和多线程之分。

### 单线程和多线程
***单线程***  
单线程就是一个进程只开一个线程，js就是属于单线程，程序顺序执行，类似于队列，前面一个执行完毕之后，后面才可以执行。在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。如果采用js进行编码，请尽可能的使用异步操作。

***一个计算耗时造成线程阻塞的例子***

先看一段例子，运行下面程序，浏览器执行http:://127.0.0.1:3000/compute大约每次需要15s,也就意味着下次用户请求需要等待15s。(这个问题可以使用child_process.forck实现多进程来解决。)
```javascript
const http = require('http');
const [url,port] = ['127.0.0.1',3000];

const computation = () => {
    let sum = 0;
    console.info('计算开始');
    //计算耗时，前后的标志必须一致
    console.time('计算耗时');

    for(let i =0 ;i < 1e10; i++){
        sum+=i;
    }
    console.info('计算结束');
    console.timeEnd('计算耗时')；
    return sum;
}

const server = http.createServer((req,res)=>{
    if(req.url == '/compute'){
        const sum = computation();
        res.end(sum);
    }
    res.end('ok');
})

server.listen(port,url,()=>{
    console.log(`server started at http://${url}:${port}`);
})

```
- Node虽然是单线程模型，但是基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的开销。


***多线程***  
多线程就是没有一个进程只开一个线程的限制。Java就是多线程编程语言的一种，可以有效避免代码阻塞导致的后续请求无法处理。

看如下代码示例，将count定义在全局变量和定义在test方法里有什么不同呢？
```java
public class TestApplication{
    
    Integer count = 0;
    
    @GetMapping("/test")
    public Integer Test() {
        count += 1;
        return count;
    }

    public static void main(String[] args){
        //开启线程
        SpringApplication.run(TestApplication.class,args);
    }
}
//1 第一次执行
//2 第二次执行

```
运行结果，每次执行都会修改count值，所以多线程中任何一个变量都可以被任何一个线程修改。

如果将count定义在test方法里，每次执行都是1，因为每个线程都拥有了自己的执行栈。
```java
public class TestApplication {
    @GetMapping("/test")
    public Integer Test() {
        Integer count = 0; // 改变定义位置
        count += 1;
        return count;
    }

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }
}
```
多线程的代价还在于创建新的线程和执行上下文线程的切换开销，由于每创建一个线程就会占用一定的内存，当应用程序并发大了之后，内存将会很快耗尽，类似于上面单线程模型中举的例子，需要一定的计算会造成线程阻塞的，推荐使用多进程来处理。

线程间资源是共享的，关注的是安全问题。


## NodeJs的线程和进程
在单核CPU系统上我们采用**单进程+单线程**的模式来开发，在多核CPU系统上，可以用child_process.fork开启多个进程(Node在v0.8版本之后新增了cluster来实现多进程架构)，即**多进程+单线程**的模式。

***开启多进程不是为了解决高并发，主要是解决了单进程模式下Node CPU利用率不足的情况，充分利用多核CPU的性能***

**Process**  
Process是一个全局对象，无需require直接使用

- process.env:环境变量，例如通过process.env.NODE_ENV获取不同环境项目配置信息
- process.nextTick: EventLoop中的微任务，但比普通微任务更先执行
- process.pid:获取当前进程id
- process.ppid:当前进程对应的父进程
- process.cwd():获取当前进程工作目录
- process.platform:虎丘当前进程运行的操作系统平台
- process.uptime():当前进程已运行时间，例如:pm2守护进程的uptime值
- 进程事件:
    - process.on('uncaughtException',cb)捕获异常信息
    - process.on('exit',cb)进程退出监听
- 标准流：
    - process.stdout标准输出
    - process.stdin标准输入
    - process.stderr标准错误输出

## Nodejs进程创建
Node提供了child_process内置模块，用于创建子进程。

- child_process.spawn(command[,args][,options])：适用于返回大量数据，例如图像处理，二进制数据处理。
    - command:执行的shell命令，必填
    - args:执行命令的参数
    - options:包含cwd等工作目录配置
- child_process.exec():适用于小量数据，maxBuffer默认为200*1024,超出这个值将会导致程序崩溃，数据量过大可采用spawn。
- child_process.execFile():类似于child_process.exec()，区别是不能通过shell来执行。
- child_process.fork()：衍生新的进程，进程之间是相互独立的，每个进程都有自己的V8实例、内存。系统资源是有限的，不建议衍生太多的子进程出来，通常根据系统CPU核心数设置。

创建进程间通信的三种方式：
- 让进程的stdio和当前进程的stdio之间建立管道链接
```javascript
child.stdout.pipe(process.stdout);
```
- 进程之间共用stdio
- 事件监听


方式一:spawn
```javascript
const spawn = require('child_process').spawn;
//cwd指定子进程的工作目录，默认当前目录
const child = spawn('ls',['-l'],{cwd:'/usr'})

child.stdout.pipe(process.stdout);
console.log(process.id,child.id);
```
方式二：exec
```javascript
const exec = require('child_process').exec;

exec('node - v',(err,stdout,stderr)=>{
    /*
        {error: null,stdout: 'v8.5.0',stderr:''}
    */
    console.log({error,stdoit,stderr});
})

```
方式三：execFile
```javascript
const execFile = require('child_process').execFile;

execFile(`node`, ['-v'], (error, stdout, stderr) => {
    console.log({ error, stdout, stderr })
    // { error: null, stdout: 'v8.5.0\n', stderr: '' }
})


```
方式四:fork
```javascript
const fork = require('child_process').fork;
//fork 一个新的进程
fork('./worker.js');
```

### fork子进程充分利用CPU资源
当CPU计算密度大的情况下，程序会造成阻塞导致后续请求需要等待，下面采用child_process.fork方法，在进行compute计算时创建子进程，子进程计算完成通过send方法将结果发送给主进程，主进程通过通过message监听到信息后处理并退出。
```javascript
//fork_app.js

const http = require('http');
const child_process = require('child_process');
const fork = child_process.fork;

const server = http.createServer((req, res)=>{
    if(req.url == '/compute'){
        const compute = fork('./for_compute.js');
        compute.send('传递给子进程的数据');

        // 监听子进程的message事件，当子进程调用process.send()的时候回触发
        compute.on('message',sum=>{
            res.end('Sum is ${sum}');
            compute.kill();
        })

        // 监听子进程的close事件
        compute.on('close',(code,signal)=>{
            console.log(`收到close事件，子进程收到信号 ${signal} 而终止，退出码 ${code}`);
            compute.kill();
        })
    }else{
        res.end('ok');
    }
})

server.listen(3000, '127.0.0.1',()=>{
    console.log(`server started at http://127.0.0.1:3000`);
})

```
```javascript
//compute.js
const computation = () => {
    let sum = 0;
    console.info('计算开始');
    console.time('计算耗时');

    for (let i = 0; i < 1e10; i++) {
        sum += i
    };

    console.info('计算结束');
    console.timeEnd('计算耗时');
    return sum;
};

process.on('message', msg => {
    console.log(msg, 'process.pid', process.pid); // 子进程id
    const sum = computation();

    // 如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息
    process.send(sum);
})
```

## Node多进程架构模型构建
多进程架构解决了单进程、单线程无法充分利用系统多核CPU的问题

通过一个例子来展示如何启动一批进程来提供服务.

### 主进程
主要处理以下逻辑：
- 创建一个HTTP服务器并监听3000端口
- 管理子进程
    - 根据系统CPU数开启多个子进程
    - 通过子进程对象的send方法发送消息到子进程进行通信
    - 在主进程中监听了子进程的变化，如果是自杀信号则重启
    - 主进程在监听到退出消息的时候，先退出子进程再退出主进程

```javascript
// master.js
const child_process = require('child_process');
const fork = child_process.fork;
const cpus = require('os').cpus();

const server = require('net').createServer();
server.listen(3000);
process.title = 'node-master';

const workers = {};

//创建工作进程
function createWorker(){
    const worker = for('worker.js');
    worker.on('message',function(message){
        //如果是自杀信号，则重启
        if(message.act === 'suicide'){
            createWorker();
        }
    });
    worker.on('exit',function(code,signal){
        console.log('worker process exited, code: %s signal: %s', code, signal);
        delete workers[worker.pid];
    });
    worker.send('server',server);
    workers[worker.pid] = worker;
    console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid);
}

//根据cpu数创建工作进程
for( let i = 0;i < cpus.length;i++){
    createWorker();
}

function close(code){
    console.log('进程退出！',code);
    if(code !== 0){
        for(let pid in workers){
            workers[pid].kill('SIGINT');
        }
    }
    process.exit(0);
}


//当前主进程收到Ctrl-C的信号，先关闭工作进程
process.once('SIGINT', close.bind(this,'SIGINT'));
//当前主进程收到Ctrl-\的信号，先关闭工作进程
process.once('SIGQUIT',close.bind(this,'SIGQUIT'));
process.once('SIGTERM',close.bind(this,'SIGTERM'));
process.once('exit',close.bind(this));

```