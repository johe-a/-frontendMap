<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-04-26 22:56:45
 -->
# Events模块
***在Node总一个很重要的模块Events（EventEmitter事件触发器）,也称为发布订阅模式，为什么说它重要，因为在Node中大多数模块都依赖于此，例如Net、HTTP、fs、Stream等。除了这些系统模块，Express、koa框架中也能看到EventEmitter的踪迹。在Vue中，跨组件交流的EventBus也是类似EventEmitter。***

与浏览器中的事件不同的是它不存在事件冒泡、preventDefault、stopPropagation等方法。

EventEmitter提供了on()、once()、removeListener()等会方法对事件进行监听移除。

问题：
- EventEmitter是什么，如何使用
- Node核心模块Stream、fs、Net是怎么使用EventEmitter的
- Express/koa基于此实现，如何实现一个基于EventEmitter的自定义对象
- 高并发场景下雪崩问题如何利用EventEmitter解决
- 事件是否等价于异步


## 基本使用

```javascript
const EventEmitter = require('events').EventEmitter;
const emitter = new EventEmitter();

emitter.on("起床",function(time){
    console.log(`早上${time}开始起床，新的一天加油`);
})

//早上6:00起床，新的一天加油
emitter.emit("起床","6:00");

```

将this传给监听器，默认情况下，监听器的this指向EventEmitter实例
```javascript
emitter.on("event",function(a,b){
    console.log(a,b,this,this===emitter);
    /*
    a,b,EventEmitter{
        _events:{event:[Function]},
        _eventsCount:1,
        _maxListeners:undefined
    }
    true
    */
});
emitter.emit("event",'a','b');
```
如果我们想将this传给EventEmitter的监听器，有两种方法：
- 使用bind
- 利用匿名函数的闭包（与Bind原理一致)
- 使用箭头函数

```javascript
//使用bind
function listener(a, b) {
    console.log(this);
    console.log(this === emitter);
}
emitter.on("event", listener.bind(this));

//使用匿名函数
emitter.on("event", (function (that) {
    return function (a, b) {
        console.log(that);
        console.log(that === emitter);
    }
})(this));

//使用箭头函数
emitter.on("event", (a, b) => {
    console.log(this);
    console.log(this === emitter);
})
```

## 异步还是同步
EventEmitter以注册的顺序 ***同步地*** 调用所有监听器。所以必须确保事件的排序正确，且避免竞态条件。

```javascript
const events = require("events");
const emitter = new events.EventEmitter();

emitter.on("test",function(){
    console.log(111);
})
emitter.emit("test");
console.log(222);

// 111
// 222
```


适当时，可以使用setImmediate()宏异步任务和process.nextTick()微异步任务方法切换到异步的操作模式。

类似的宏异步任务还有:setTimeout\setInterval\MessageChannel等等

类似的微异步任务还有:promise\MutationObserver（用于监听DOM）

```javascript
emitter.on("test",()=>{
    //同步发生
    setImmediate(()=>{
        console.log('111')
    })
});
emitter.emit("test");
console.log(222);
//222
//111
```

## 系统模块如何继承EventEmitter
所有能够触发事件的对象都是EventEmitter类的实例，这些对象有一个eventEmitter.on()函数，用于将一个或者多个函数绑定到命名事件上。  
例如net.Server会在每次有新连接时触发事件,fs.ReadStream会在打开文件时触发事件,stream会在数据可读时触发事件。

系统模块是如何继承EventEmitter的：
```javascript
//Stream模块
const EventEmitter = require("events");
const utils = require("util");

function Stream(){
    //继承EventEmitter实例属性
    EventEmitter.call(this);
}
//设置EventEmitter为Stream原型
util.inherits(Stream.EventEmitter);

//Net模块
const EventEmitter = require('events');
const util = require('util');

function Server(options, connectionListener) {
  if (!(this instanceof Server))
    return new Server(options, connectionListener);

  EventEmitter.call(this);
}
util.inherits(Server, EventEmitter);

```

## 如何继承EventEmitter

```javascript
const EventEmitter = require("events");

class MyEmitter extends EventEmitter{};

//或者是
function MyEmitter(){
    EventEmitter.call(this);
}
//相当于MyEmitter.prototype.__proto__ = EventEmitter.prototype
Object.setPrototypeOf(MyEmitter.prototype,EventEmitter.Prototype);
//构造函数也要继承，静态方法
//相当于MyEmitter.__proto__ = EventEmitter
Object.setPrototypeOf(MyEmitter,EventEmitter);


```

## once方法
当触发多次相同名称事件，通过once添加的监听器只会执行一次，并且再执行之后会解除once的监听器，相当于on方法和removeListener方法的组合。

```javascript
emitter.once("test",function(){
    console.log("once");
})
emitter.on("test",function(){
    console.log("on");
})

emitter.emit("test");
emitter.emit("test");
emitter.emit("test");
//once
//on
//on
//on
```

对于需要查询数据库的数据，我们称之为热点数据，在高并发情况下对数据库造成一定的压力，我们可以通过once方法来解决。

这里用fs模块读取文件来模拟查询数据库:
```javascript
const events = require("events");
const emitter = new events.EventEmitter();
const fs = require("fs");

const status = {};
// 或者使用weakMap 
const status = new WeakMap();

const select = function(file,filename,cb){
    //将文件作为先将回调推入到emitter中
    emitter.once(file,cb);
    if(stats[file] === undefined){
        status[file] = 'ready'
    }
    if(status[file]==='ready'){
        //表明文件正在读取中，避免再次读取
        stats[file] = 'pending';
        //如果file是个大文件，这将是个非常耗时的工作，回调将会在文件读取完毕后执行
        fs.readFile(file,function(err,result){
            emitter.emit(file,err,result);
            //读取完毕，可以再次读取
            status[file] = 'ready';

            setTimeout(function(){
                //避免大文件作为键值造成内存泄漏无法回收
                delete status[file];
            },1000);
        })
    }
}

//假设有多个请求要读取a文件，
for(let i = 0;i<10;i++){
    //即使调用了10次，也可能只读取了一次文件
    select('/a.txt','a.文件',function(err,result){
        console.log(err,result);
    })
}
```
上面应该注意到一点，使用对象来将大文件作为key时，无法避免内存泄漏，需要自己手动释放，可以使用WeakSet(成员是弱引用),WeakMap(key是弱引用)替代.

## 错误处理(防止程序因错误而退出进程)
当EventEmitter实例出错时，应该触发'error'事件。  
如果没有为'error'事件注册监听器,则当'error'事件触发时,会抛出错误、打印堆栈跟踪、***并退出Node进程***
```javascript
//将导致抛出错误并使得Node.js崩溃
emitter.emit('error',new Error('错误信息'));
```
作为最佳实现，应该始终为error事件注册监听器
```javascript
emitter.on('error',function(err){
    console.error(err);
})
emitter.emit('error',new Error('this is a error'));

```

# 加密模块Crypto
> Crypto加密模块是C/C++实现这些算法后，暴露给Node的模块，包含对OpenSSL的哈希、HMAC、加密、解密、签名、以及验证功能的封装。

查看系统所支持的算法：***openssl list-cipher-algorithms***


## 对称密钥加密Cipher
>Cipher累用于加密数据，属于对称密钥加密，假设通信双方为A、B,
>A使用Key对明文进行加密传输，B接收到密文后，使用同样的key进行解密得到明文。

Cipher加解密：  
数据加密：  
- crypto.createCipheriv(algorithm,pwd,iv)创建cipher加密对象
    - algorithm指定加密算法
    - pwd指定加密的密码
    - vi向量

Cipher实例有如下方法：
- cipher.update(data,inputFormat,outputFormat),生成加密数据
    - data代表要加密的数据
    - inputFormat代表传入数据的格式，可以是'utf8','ascii','latin1'
    - outputFormat为加密数据的输出格式,可以是'latin1','base64','hex'.没有则返回Buffer 

- cipher.final(format),返回任意加密内容


```javascript
function cipher(str){
    try{
        const crypto = require('crypto');
        //根据算法、密码、向量创建ciper加密对象
        const cipher = crypto.createCipheriv('desc-ecb','12345678','');
        //生成加密数据
        let encrypted = cipher.update(str,'uft8','hex');
        encrypted += cipher.final('hex');

        return encryted;
    }catch(e){
        console.log('加密失败');
        return e.message || e;
    }
}
//81c66a1d39d302205c55f0afac95c06bc985155d4ddb751c
cipher('hello world !!!')

```

数据解密:
- crypto.createDecipheriv(algorithm,pwd,iv)指定算法、密码、向量创建decipher解密对象

```javascript
function decipher(encrypted){
    try{
        const crypto = require('crypto');
        const decipher = crypto.createDecipheriv('des-ecb','12345678','');
        let decrypted = decipher.update(encrypted,'hex','utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    }catch(e){
        console.log("解密失败");
        return e.message||e;
    }
}

```

## MD5加密
MD5的作用和特点：
- 作用
让大容量信息在数字签名软件签署私人秘钥前被压缩成一种保密格式，***也就是把一个任意长度的字节串变成一定长度的十六进制数字串（32个字符）一致性验证***
- 特点
    - 输入两个不同的明文不会得到相同的输出值
    - 根据输出值，不能得到原始的明文，即过程不可逆

MD5三种实现方式:
- crypto.createHash(algorithm)
创建并返回一个hash对象，它是一个指定算法的加密hash，用于生成hash摘要。  
参数algorithm可选择系统上安装的OpenSSL版本所支持的算法。

- hash.update(data)
更新hash的内容为指定的data,当使用流数据时可能会多次调用改方法。

- hash.digest(encoding='binary')
计算所有传入数据的hash摘要，encoding可以为hex、binary、base64

```javascript
const crypto = require('crypto');
const md5 = str =>{
    return crypto.createHash('md5').update(str,'utf8')
};

console.log(md5('123456789'));

console.log(md5('123456789').toUpperCase()); 

```


# Buffer(缓冲区)
>在引入TypeArray之前，js语言没有用于读取或者操作二进制数据流的机制，Buffer类是作为Node的一部分引入的，用于在TCP流、文件系统操作、以及其他上下文中与八位字节流进行交互。***也就是Node可以通过Buffer来处理二进制流数据并且与之进行交互***

Buffer用于读取或者操作二进制数据流，作为Node的API，使用时无须require，用于操作网络协议、数据库、图片和文件I/O等一些需要大量二进制数据的场景。

Buffer在创建时大小已经被确定且无法调整，在内存分配这块Buffer是由C++层面提供而不是V8。

二进制、流(Stream)、缓冲区(Buffer)都是些什么呢？

## 二进制数据
什么是二进制数据，有什么作用？

二进制数据使用0和1来表示数据，为了存储数据，计算机需要先将这些数据转换成二进制来表示，例如我想存储66这个数字，计算机会将数字66转化成二进制01000010表示:

|---|---|---|---|---|---|---|---|
|128|64|32|16|8|4|2|1
|0|1|0|0|0|0|1|0|


数字只是数据类型之一，其他的还有字符串、图像、文件等。例如我们要获取M的二进制表示，需要先转化成ASCII码后，再转化为二进制表示，JS通过charCodeAt()来获取ASCII码。
```javascript
'M'.chartCodeAt();
```

## Stream
流，Stream是对输入输出管道的抽象，这里的管道可以是文件、内存、网络等。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8sinjkxgj31400nogo7.jpg)

流具有方向性，当程序从某个数据源读取数据，会开启一个输入流。当我们的程序需要写出数据到指定数据源时(文件、网络等)时，则开启一个输出流。  
当有一些大文件操作时，我们就需要Stream像管道一样，一点一点的将数据流出。

一个恰当的比喻，当我们有一桶水需要浇一片菜地，如果我们将一桶水全部倒入菜地（假设这桶水非常多），需要非常大的力气（这里的力气就比作计算机中的硬件性能）。如果我们拿来了水管将谁一点点流入我们的菜地，就不需要那么大的力气就可以完成（用时间换性能）

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8sivcbflj30zk0logr6.jpg)