<!--
 * @Description: 
 * @Author: johe.huang
 * @Date: 2020-04-26 22:56:45
 -->
# Events模块
***在Node总一个很重要的模块Events（EventEmitter事件触发器）,也称为发布订阅模式，为什么说它重要，因为在Node中大多数模块都依赖于此，例如Net、HTTP、fs、Stream等。除了这些系统模块，Express、koa框架中也能看到EventEmitter的踪迹。在Vue中，跨组件交流的EventBus也是类似EventEmitter。***

与浏览器中的事件不同的是它不存在事件冒泡、preventDefault、stopPropagation等方法。

EventEmitter提供了on()、once()、removeListener()等会方法对事件进行监听移除。

问题：
- EventEmitter是什么，如何使用
- Node核心模块Stream、fs、Net是怎么使用EventEmitter的
- Express/koa基于此实现，如何实现一个基于EventEmitter的自定义对象
- 高并发场景下雪崩问题如何利用EventEmitter解决
- 事件是否等价于异步


## 基本使用

```javascript
const EventEmitter = require('events').EventEmitter;
const emitter = new EventEmitter();

emitter.on("起床",function(time){
    console.log(`早上${time}开始起床，新的一天加油`);
})

//早上6:00起床，新的一天加油
emitter.emit("起床","6:00");

```

将this传给监听器，默认情况下，监听器的this指向EventEmitter实例
```javascript
emitter.on("event",function(a,b){
    console.log(a,b,this,this===emitter);
    /*
    a,b,EventEmitter{
        _events:{event:[Function]},
        _eventsCount:1,
        _maxListeners:undefined
    }
    true
    */
});
emitter.emit("event",'a','b');
```
如果我们想将this传给EventEmitter的监听器，有两种方法：
- 使用bind
- 利用匿名函数的闭包（与Bind原理一致)
- 使用箭头函数

```javascript
//使用bind
function listener(a, b) {
    console.log(this);
    console.log(this === emitter);
}
emitter.on("event", listener.bind(this));

//使用匿名函数
emitter.on("event", (function (that) {
    return function (a, b) {
        console.log(that);
        console.log(that === emitter);
    }
})(this));

//使用箭头函数
emitter.on("event", (a, b) => {
    console.log(this);
    console.log(this === emitter);
})
```

## 异步还是同步
EventEmitter以注册的顺序 ***同步地*** 调用所有监听器。所以必须确保事件的排序正确，且避免竞态条件。

```javascript
const events = require("events");
const emitter = new events.EventEmitter();

emitter.on("test",function(){
    console.log(111);
})
emitter.emit("test");
console.log(222);

// 111
// 222
```


适当时，可以使用setImmediate()宏异步任务和process.nextTick()微异步任务方法切换到异步的操作模式。

类似的宏异步任务还有:setTimeout\setInterval\MessageChannel等等

类似的微异步任务还有:promise\MutationObserver（用于监听DOM）

```javascript
emitter.on("test",()=>{
    //同步发生
    setImmediate(()=>{
        console.log('111')
    })
});
emitter.emit("test");
console.log(222);
//222
//111
```

## 系统模块如何继承EventEmitter
所有能够触发事件的对象都是EventEmitter类的实例，这些对象有一个eventEmitter.on()函数，用于将一个或者多个函数绑定到命名事件上。  
例如net.Server会在每次有新连接时触发事件,fs.ReadStream会在打开文件时触发事件,stream会在数据可读时触发事件。

系统模块是如何继承EventEmitter的：
```javascript
//Stream模块
const EventEmitter = require("events");
const utils = require("util");

function Stream(){
    //继承EventEmitter实例属性
    EventEmitter.call(this);
}
//设置EventEmitter为Stream原型
util.inherits(Stream,EventEmitter);

//Net模块
const EventEmitter = require('events');
const util = require('util');

function Server(options, connectionListener) {
  if (!(this instanceof Server))
    return new Server(options, connectionListener);

  EventEmitter.call(this);
}
util.inherits(Server, EventEmitter);

```

## 如何继承EventEmitter

```javascript
const EventEmitter = require("events");

class MyEmitter extends EventEmitter{};

//或者是
function MyEmitter(){
    EventEmitter.call(this);
}
//相当于MyEmitter.prototype.__proto__ = EventEmitter.prototype
Object.setPrototypeOf(MyEmitter.prototype,EventEmitter.Prototype);
//构造函数也要继承，静态方法
//相当于MyEmitter.__proto__ = EventEmitter
Object.setPrototypeOf(MyEmitter,EventEmitter);


```

## once方法
当触发多次相同名称事件，通过once添加的监听器只会执行一次，并且再执行之后会解除once的监听器，相当于on方法和removeListener方法的组合。

```javascript
emitter.once("test",function(){
    console.log("once");
})
emitter.on("test",function(){
    console.log("on");
})

emitter.emit("test");
emitter.emit("test");
emitter.emit("test");
//once
//on
//on
//on
```

对于需要查询数据库的数据，我们称之为热点数据，在高并发情况下对数据库造成一定的压力，我们可以通过once方法来解决。

这里用fs模块读取文件来模拟查询数据库:
```javascript
const events = require("events");
const emitter = new events.EventEmitter();
const fs = require("fs");

const status = {};
// 或者使用weakMap 
const status = new WeakMap();

const select = function(file,filename,cb){
    //将文件作为先将回调推入到emitter中
    emitter.once(file,cb);
    if(stats[file] === undefined){
        status[file] = 'ready'
    }
    if(status[file]==='ready'){
        //表明文件正在读取中，避免再次读取
        stats[file] = 'pending';
        //如果file是个大文件，这将是个非常耗时的工作，回调将会在文件读取完毕后执行
        fs.readFile(file,function(err,result){
            emitter.emit(file,err,result);
            //读取完毕，可以再次读取
            status[file] = 'ready';

            setTimeout(function(){
                //避免大文件作为键值造成内存泄漏无法回收
                delete status[file];
            },1000);
        })
    }
}

//假设有多个请求要读取a文件，
for(let i = 0;i<10;i++){
    //即使调用了10次，也可能只读取了一次文件
    select('/a.txt','a.文件',function(err,result){
        console.log(err,result);
    })
}
```
上面应该注意到一点，使用对象来将大文件作为key时，无法避免内存泄漏，需要自己手动释放，可以使用WeakSet(成员是弱引用),WeakMap(key是弱引用)替代.

## 错误处理(防止程序因错误而退出进程)
当EventEmitter实例出错时，应该触发'error'事件。  
如果没有为'error'事件注册监听器,则当'error'事件触发时,会抛出错误、打印堆栈跟踪、***并退出Node进程***
```javascript
//将导致抛出错误并使得Node.js崩溃
emitter.emit('error',new Error('错误信息'));
```
作为最佳实现，应该始终为error事件注册监听器
```javascript
emitter.on('error',function(err){
    console.error(err);
})
emitter.emit('error',new Error('this is a error'));

```

# 加密模块Crypto
> Crypto加密模块是C/C++实现这些算法后，暴露给Node的模块，包含对OpenSSL的哈希、HMAC、加密、解密、签名、以及验证功能的封装。

查看系统所支持的算法：***openssl list-cipher-algorithms***


## 对称密钥加密Cipher
>Cipher累用于加密数据，属于对称密钥加密，假设通信双方为A、B,
>A使用Key对明文进行加密传输，B接收到密文后，使用同样的key进行解密得到明文。

Cipher加解密：  
数据加密：  
- crypto.createCipheriv(algorithm,pwd,iv)创建cipher加密对象
    - algorithm指定加密算法
    - pwd指定加密的密码
    - vi向量

Cipher实例有如下方法：
- cipher.update(data,inputFormat,outputFormat),生成加密数据
    - data代表要加密的数据
    - inputFormat代表传入数据的格式，可以是'utf8','ascii','latin1'
    - outputFormat为加密数据的输出格式,可以是'latin1','base64','hex'.没有则返回Buffer 

- cipher.final(format),返回任意加密内容


```javascript
function cipher(str){
    try{
        const crypto = require('crypto');
        //根据算法、密码、向量创建ciper加密对象
        const cipher = crypto.createCipheriv('desc-ecb','12345678','');
        //生成加密数据
        let encrypted = cipher.update(str,'uft8','hex');
        encrypted += cipher.final('hex');

        return encryted;
    }catch(e){
        console.log('加密失败');
        return e.message || e;
    }
}
//81c66a1d39d302205c55f0afac95c06bc985155d4ddb751c
cipher('hello world !!!')

```

数据解密:
- crypto.createDecipheriv(algorithm,pwd,iv)指定算法、密码、向量创建decipher解密对象

```javascript
function decipher(encrypted){
    try{
        const crypto = require('crypto');
        const decipher = crypto.createDecipheriv('des-ecb','12345678','');
        let decrypted = decipher.update(encrypted,'hex','utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    }catch(e){
        console.log("解密失败");
        return e.message||e;
    }
}

```

## MD5加密
MD5的作用和特点：
- 作用
让大容量信息在数字签名软件签署私人秘钥前被压缩成一种保密格式，***也就是把一个任意长度的字节串变成一定长度的十六进制数字串（32个字符）一致性验证***
- 特点
    - 输入两个不同的明文不会得到相同的输出值
    - 根据输出值，不能得到原始的明文，即过程不可逆

MD5三种实现方式:
- crypto.createHash(algorithm)
创建并返回一个hash对象，它是一个指定算法的加密hash，用于生成hash摘要。  
参数algorithm可选择系统上安装的OpenSSL版本所支持的算法。

- hash.update(data)
更新hash的内容为指定的data,当使用流数据时可能会多次调用改方法。

- hash.digest(encoding='binary')
计算所有传入数据的hash摘要，encoding可以为hex、binary、base64

```javascript
const crypto = require('crypto');
const md5 = str =>{
    return crypto.createHash('md5').update(str,'utf8')
};

console.log(md5('123456789'));

console.log(md5('123456789').toUpperCase()); 

```


# Buffer(缓冲区)
>在引入TypeArray之前，js语言没有用于读取或者操作二进制数据流的机制，Buffer类是作为Node的一部分引入的，用于在TCP流、文件系统操作、以及其他上下文中与八位字节流进行交互。***也就是Node可以通过Buffer来处理二进制流数据并且与之进行交互***

Buffer用于读取或者操作二进制数据流，作为Node的API，使用时无须require，用于操作网络协议、数据库、图片和文件I/O等一些需要大量二进制数据的场景。

Buffer在创建时大小已经被确定且无法调整，在内存分配这块Buffer是由C++层面提供而不是V8。

二进制、流(Stream)、缓冲区(Buffer)都是些什么呢？

## 二进制数据
什么是二进制数据，有什么作用？

二进制数据使用0和1来表示数据，为了存储数据，计算机需要先将这些数据转换成二进制来表示，例如我想存储66这个数字，计算机会将数字66转化成二进制01000010表示:

|---|---|---|---|---|---|---|---|
|128|64|32|16|8|4|2|1|
|0|1|0|0|0|0|1|0|


数字只是数据类型之一，其他的还有字符串、图像、文件等。例如我们要获取M的二进制表示，需要先转化成ASCII码后，再转化为二进制表示，JS通过charCodeAt()来获取ASCII码。
```javascript
'M'.chartCodeAt();
```

## Stream
流，Stream是对输入输出管道的抽象，这里的管道可以是文件、内存、网络等。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8sinjkxgj31400nogo7.jpg)

流具有方向性，当程序从某个数据源读取数据，会开启一个输入流。当我们的程序需要写出数据到指定数据源时(文件、网络等)时，则开启一个输出流。  
当有一些大文件操作时，我们就需要Stream像管道一样，一点一点的将数据流出。

一个恰当的比喻，当我们有一桶水需要浇一片菜地，如果我们将一桶水全部倒入菜地（假设这桶水非常多），需要非常大的力气（这里的力气就比作计算机中的硬件性能）。如果我们拿来了水管将谁一点点流入我们的菜地，就不需要那么大的力气就可以完成（用时间换性能）

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8sivcbflj30zk0logr6.jpg)


## Buffer
Buffer是二进制数据的容器，是Uint8Array的子类

伴随着时间的推移，每一个过程都会有一个最小或者最大数据量。
- 如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。
- 如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理。

举个例子：与公共汽车站类似，通常汽车会隔一定时间来一趟，在这个时间到达之前就算乘客已经满了，车辆也不会提前发车，早到的乘客就需要先在车站进行等待，假设到达的乘客过多，后到的一部分则需要等下一趟车到来。

- 公交汽车站：类似于Node中的缓冲区(Buffer)  
- 乘客：类似于数据流，我们无法控制乘客到达的速度，所以我们也无法控制数据流到达的时间
- 何时发车:我们可以决定何时发送数据。

在Node中，Buffer对象用于以字节序列的形式来表示二进制数据。  
许多API（例如流和文件系统操作）都支持Buffer，因为与操作系统或者其他进程的交互通常总是以二进制数据的形式发送。

***Buffer类是js语言内置的Uint8Array类的子类。只要支持Buffer的API都可以接受Uint8Array。***

***Buffer类与的实例，以及Uint8Array(八位无符号整数，U代表无符号，int代表整数,8代表八位)，都是类似于从0到255之间的整数数组(因为是8位)。一个Buffer的大小在创建时确定，且无法更改。***

### Buffer基本使用
创建Buffer:  
在6.0之前的版本中，Buffer实例是使用Buffer构造函数创建的，该函数根据提供的参数以不同方式分配返回的Buffer。
```
new Buffer();
```
现在可以通过Buffer.from()、Buffer.alloc()、Buffer.allocUnsafe()三种方式来创建。

```javascript
//创建一个包含字节[1,2,3]的Buffer
const buf4 = Buffer.from([1,2,3]);

//创建一个包含字节[1,1,1,1]的Buffer
//其中所有条目均使用`(value & 255)`进行截断以符合0-255的范围。
const buf5 = Buffer.from([257,257.5,-255,'1']);

//创建一个Buffer,其中包含'test'的UTF-8编码字节
//[0x74,0xc3,0xa9,0x73,0x74](以十六进制表示)
//[116,195,169,115,116](以十进制表示)
const buf6 = Buffer.from('test');

//创建一个包含Latin-1字节 [0x74,0xe9,0x73,0x74]的Buffer
const buf7 = Buffer.from('tést', 'latin1');

//创建一个长度为10的Buffer
//其中填充了全部值为`1`的字节。
const buf1 = Buffer.alloc(10);

// 创建一个长度为 10、且用 0x1 填充的 Buffer。 
const buf2 = Buffer.alloc(10, 1);

// 创建一个长度为 10、且未初始化的 Buffer。
// 这个方法比调用 Buffer.alloc() 更快，
// 但返回的 Buffer 实例可能包含旧数据，
// 因此需要使用 fill()、write() 或其他能填充 Buffer 的内容的函数进行重写。
const buf3 = Buffer.allocUnsafe(10);
```

### Buffer与字符编码
当在Buffer和字符串之间转换时，可以指定字符编码，如果为指定字符编码，则使用UTF-8作为默认值。
- utf8:多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8。
- base64:Base64编码。
- ascii:仅适用于 7 位 ASCII 数据。此编码速度很快，如果设置则会剥离高位。
- utf16le:2 或 4 个字节，小端序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。

```javascript
const buf = Buffer.from('hello world', 'utf8');

console.log(buf.toString('hex'));
// 打印: 68656c6c6f20776f726c64
console.log(buf.toString('base64'));
// 打印: aGVsbG8gd29ybGQ=
```

### 字符串与Buffer类型互转
字符串转Buffer
```javascript
//<Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
const buf = Buffer.from('hello world', 'utf8');
```
Buffer转换为字符串  
- toString([encoding],[start],[end])
    - encoding编码方式，默认为UTF-8
    - start\end实现部分转换
```javascript
console.log(buf.toString('UTF-8'));
```
start\end会将字符截断造成乱码：
```javascript
const buf = Buffer.from('Node.js 技术栈', 'UTF-8');

// Node.js �
console.log(buf.toString('UTF-8', 0, 9)); 

// Node.js 技
console.log(buf.toString('UTF-8', 0, 11)); 
```
***因为技这个字在Buf中对应的字节为8a 80 e6我们只截取到了8a，这个时候就会造成字符被截断出现乱码。***

### Buffer与迭代器
Buffer类实例可以使用for..of语法进行迭代，以下方法也可以用于创建迭代器。
- buffer.values()
- buffer.keys()
- buffer.entries()

```javascript
const buf = Buffer.from([1, 2, 3]);

for (const b of buf) {
  console.log(b);
}
// 打印:
//   1
//   2
//   3

```

### Buffer内存机制
***由于Buffer需要处理的是大量的二进制数据，假如用一点就向系统去申请，则会造成频繁的向系统社情内存调用，所以Buffer所占用的内存不由v8分配，而是在Node的C++层面完成申请，在Javascript中进行内存分配。因此，这部分内存我们称之为堆外内存。***

### Buffer内存分配原理：  
Node采用了slab机制预先在C++申请、事后在JS分配，是一种动态的管理机制。  
使用Buffer.alloc(size)传入一个指定的size就会申请一块固定大小的内存区域，slab具有如下三种状态：
- full:完全分配状态
- partial:部分分配状态
- empty:没有被分配状态

#### 大对象还是小对象
Node以8KB为界限来区分是小对象还是大对象,在buffer.js中可以看到如下代码:
```javascript
Buffer.poolSize = 8 * 1024;
```

#### 对象分配
以下代码示例，在加载时直接调用了createPool()相当于直接初始化了一个8KB的内存空间，这样在第一次进行内存分配时也会变得更高效，在通过poolOffset这个变量记录已经使用了多少字节。
```javascript
Buffer.poolSize = 8 * 1024;
var poolSize,poolOffset,allocPool;

function createPool(){
    poolSize = Buffer.poolSize;
    allocPool = createUnsafeArrayBuffer(poolSize);
    poolOffset = 0;
}
createPool();
```
新构造的slab如下所示：
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9wmotj3bj30zg094ab7.jpg)

尝试分配一个大小为2048的Buffer对象：
```javascript
Buffer.alloc(2 * 1024);
```
slab内存如下所示：
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9wnghedbj30zw0aa75o.jpg)

Buffer内存分配总结：
1. 在初次加载时就会初始化一个8KB的内存空间
2. 根据身亲搞得内存大小分为小Buffer对象和大Buffer对象
3. 如果是小Buffer，会继续判断这个小slab空间是否足够
    - 如果空间足够就去使用剩余空间，同时更新slab分配状态，偏移量会增加
    - 如果空间不足，slab空间不足，就会去创建一个新的slab空间来分配
4. 大Buffer,会直接走createUnSafeBuffer(size)直接向C++层面申请
5. 不论是小Buffer对象还是大Buffer对象，内存分配是在C++层面完成，内存管理在JavaScript层面，最终还是可以被V8的垃圾回收标记所回收。

### Buffer应用场景
- 文件格式转化，例如csv文件的buffer转化为utf8需要添加bom头，这个时候我们就要操作buffer
- I/O操作，流(stream)会自动创建Buffer
例如通过流的方式将input.txt信息写入到output.txt文件。
```javascript
const fs = require('fs');

//创建可读流
const inputStream = fs.createReadStream('input.txt');
//创建可写流
const outputStream = fs.createWriteSteam('output.txt');

//管道读写
inputStream.pipe(outputSteam);

```

- 优化传输速度，将String转化成Buffer再传递,传输性能能够得到显著提升
```javascript
const http = require('http');
let s = '';
for (let i=0; i<1024*10; i++) {
    s+='a'
}

const str = s;
const bufStr = Buffer.from(s);
const server = http.createServer((req, res) => {
    console.log(req.url);

    if (req.url === '/buffer') {
        res.end(bufStr);
    } else if (req.url === '/string') {
        res.end(str);
    }
});

server.listen(3000);
```

# 线程和进程
## 进程(process)
> 进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，***是系统进行资源分配和调度的基本单位***,是操作系统的基础，进程是线程的容器。
> Node通过```node app.js```开启一个服务进程，多进程就是进程的复制(fork),fork出来的每个进程都拥有自己的独立空间地址、数据栈。一个进程无法访问另外一个进程里定义的变量、数据结构。只有建立了IPC(Inter-Process Communication，进程间通信)，进程之间才可以数据共享。

***node进程查看和命名***：
```javascript
const http = require("http");
http.createServer().listen(3000,()=>{
    //进程命名
    process.title = '测试进程Node.js';
    //查看进程id
    console.log(`process.pid:${process.pid}`);
})
```
再通过mac自带的活动监视器查看:
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gedezwuydyj31400u0k03.jpg)

## 线程
> 线程是操作系统能够进行运算调度的最小单位，线程属于进程，被包含在进程之中，一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。

同一块代码，可以根据系统CPU核心数启动多个进程，每个进程都有数据自己的独立运行空间，进程之间是不互相影响的。同一进程中的多条线程将 *** 共享该进程中的全部系统资源,如虚拟地址空间，文件描述符和信号处理等 ***。 但同一进程中的多个线程有各自的调用栈(call stack),自己的寄存器环境(register context)，自己的线程本地存储(thread-local storage)，线程又有单线程和多线程之分。

### 单线程和多线程
***单线程***  
单线程就是一个进程只开一个线程，js就是属于单线程，程序顺序执行，类似于队列，前面一个执行完毕之后，后面才可以执行。在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。如果采用js进行编码，请尽可能的使用异步操作。

***一个计算耗时造成线程阻塞的例子***

先看一段例子，运行下面程序，浏览器执行http:://127.0.0.1:3000/compute大约每次需要15s,也就意味着下次用户请求需要等待15s。(这个问题可以使用child_process.forck实现多进程来解决。)
```javascript
const http = require('http');
const [url,port] = ['127.0.0.1',3000];

const computation = () => {
    let sum = 0;
    console.info('计算开始');
    //计算耗时，前后的标志必须一致
    console.time('计算耗时');

    for(let i =0 ;i < 1e10; i++){
        sum+=i;
    }
    console.info('计算结束');
    console.timeEnd('计算耗时')；
    return sum;
}

const server = http.createServer((req,res)=>{
    if(req.url == '/compute'){
        const sum = computation();
        res.end(sum);
    }
    res.end('ok');
})

server.listen(port,url,()=>{
    console.log(`server started at http://${url}:${port}`);
})

```
- Node虽然是单线程模型，但是基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的开销。


***多线程***  
多线程就是没有一个进程只开一个线程的限制。Java就是多线程编程语言的一种，可以有效避免代码阻塞导致的后续请求无法处理。

看如下代码示例，将count定义在全局变量和定义在test方法里有什么不同呢？
```java
public class TestApplication{
    
    Integer count = 0;
    
    @GetMapping("/test")
    public Integer Test() {
        count += 1;
        return count;
    }

    public static void main(String[] args){
        //开启线程
        SpringApplication.run(TestApplication.class,args);
    }
}
//1 第一次执行
//2 第二次执行

```
运行结果，每次执行都会修改count值，所以多线程中任何一个变量都可以被任何一个线程修改。

如果将count定义在test方法里，每次执行都是1，因为每个线程都拥有了自己的执行栈。
```java
public class TestApplication {
    @GetMapping("/test")
    public Integer Test() {
        Integer count = 0; // 改变定义位置
        count += 1;
        return count;
    }

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }
}
```
多线程的代价还在于创建新的线程和执行上下文线程的切换开销，由于每创建一个线程就会占用一定的内存，当应用程序并发大了之后，内存将会很快耗尽，类似于上面单线程模型中举的例子，需要一定的计算会造成线程阻塞的，推荐使用多进程来处理。

线程间资源是共享的，关注的是安全问题。


## NodeJs的线程和进程
在单核CPU系统上我们采用**单进程+单线程**的模式来开发，在多核CPU系统上，可以用child_process.fork开启多个进程(Node在v0.8版本之后新增了cluster来实现多进程架构)，即**多进程+单线程**的模式。

***开启多进程不是为了解决高并发，主要是解决了单进程模式下Node CPU利用率不足的情况，充分利用多核CPU的性能***

**Process**  
Process是一个全局对象，无需require直接使用

- process.env:环境变量，例如通过process.env.NODE_ENV获取不同环境项目配置信息
- process.nextTick: EventLoop中的微任务，但比普通微任务更先执行
- process.pid:获取当前进程id
- process.ppid:当前进程对应的父进程
- process.cwd():获取当前进程工作目录
- process.platform:虎丘当前进程运行的操作系统平台
- process.uptime():当前进程已运行时间，例如:pm2守护进程的uptime值
- 进程事件:
    - process.on('uncaughtException',cb)捕获异常信息
    - process.on('exit',cb)进程退出监听
- 标准流：
    - process.stdout标准输出
    - process.stdin标准输入
    - process.stderr标准错误输出

## Nodejs进程创建
Node提供了child_process内置模块，用于创建子进程。

- child_process.spawn(command[,args][,options])：适用于返回大量数据，例如图像处理，二进制数据处理。
    - command:执行的shell命令，必填
    - args:执行命令的参数
    - options:包含cwd等工作目录配置
- child_process.exec():适用于小量数据，maxBuffer默认为200*1024,超出这个值将会导致程序崩溃，数据量过大可采用spawn。
- child_process.execFile():类似于child_process.exec()，区别是不能通过shell来执行。
- child_process.fork()：衍生新的进程，进程之间是相互独立的，每个进程都有自己的V8实例、内存。系统资源是有限的，不建议衍生太多的子进程出来，通常根据系统CPU核心数设置。

创建进程间通信的三种方式：
- 让进程的stdio和当前进程的stdio之间建立管道链接
```javascript
child.stdout.pipe(process.stdout);
```
- 进程之间共用stdio
- 事件监听


方式一:spawn
```javascript
const spawn = require('child_process').spawn;
//cwd指定子进程的工作目录，默认当前目录
const child = spawn('ls',['-l'],{cwd:'/usr'})

child.stdout.pipe(process.stdout);
console.log(process.id,child.id);
```
方式二：exec
```javascript
const exec = require('child_process').exec;

exec('node - v',(err,stdout,stderr)=>{
    /*
        {error: null,stdout: 'v8.5.0',stderr:''}
    */
    console.log({error,stdoit,stderr});
})

```
方式三：execFile
```javascript
const execFile = require('child_process').execFile;

execFile(`node`, ['-v'], (error, stdout, stderr) => {
    console.log({ error, stdout, stderr })
    // { error: null, stdout: 'v8.5.0\n', stderr: '' }
})


```
方式四:fork
```javascript
const fork = require('child_process').fork;
//fork 一个新的进程
fork('./worker.js');
```

### fork子进程充分利用CPU资源
当CPU计算密度大的情况下，程序会造成阻塞导致后续请求需要等待，下面采用child_process.fork方法，在进行compute计算时创建子进程，子进程计算完成通过send方法将结果发送给主进程，主进程通过通过message监听到信息后处理并退出。
```javascript
//fork_app.js

const http = require('http');
const child_process = require('child_process');
const fork = child_process.fork;

const server = http.createServer((req, res)=>{
    if(req.url == '/compute'){
        const compute = fork('./for_compute.js');
        compute.send('传递给子进程的数据');

        // 监听子进程的message事件，当子进程调用process.send()的时候回触发
        compute.on('message',sum=>{
            res.end('Sum is ${sum}');
            compute.kill();
        })

        // 监听子进程的close事件
        compute.on('close',(code,signal)=>{
            console.log(`收到close事件，子进程收到信号 ${signal} 而终止，退出码 ${code}`);
            compute.kill();
        })
    }else{
        res.end('ok');
    }
})

server.listen(3000, '127.0.0.1',()=>{
    console.log(`server started at http://127.0.0.1:3000`);
})

```
```javascript
//compute.js
const computation = () => {
    let sum = 0;
    console.info('计算开始');
    console.time('计算耗时');

    for (let i = 0; i < 1e10; i++) {
        sum += i
    };

    console.info('计算结束');
    console.timeEnd('计算耗时');
    return sum;
};

process.on('message', msg => {
    console.log(msg, 'process.pid', process.pid); // 子进程id
    const sum = computation();

    // 如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息
    process.send(sum);
})
```

## Node多进程架构模型构建
多进程架构解决了单进程、单线程无法充分利用系统多核CPU的问题

通过一个例子来展示如何启动一批进程来提供服务.

一般情况下，Node进程退出可以分为两类：
- 未捕获异常（uncaughtException）
当代码抛出了异常没有被捕获到时，进程将会退出，Node提供了process.on('uncaughtException',handler)接口来捕获它，但是当一个Worker进程遇到未捕获异常时，它已经处于一个不确定状态，此时我们应该让这个进程优雅退出：
1. 关闭异常Worker进程所有的TCP server(将已有的连接快速断开，且不再接收新的连接)，断开和Master的IPC通道，不再接受新的用户请求。
2. Master立刻fork一个新的Worker进程，保证在线的工人总数不变。
3. 异常Worker等待一段时间，处理完已经接受的请求后退出。

```
+---------+                 +---------+
|  Worker |                 |  Master |
+---------+                 +----+----+
     | uncaughtException         |
     +------------+              |
     |            |              |                   +---------+
     | <----------+              |                   |  Worker |
     |                           |                   +----+----+
     |        disconnect         |   fork a new worker    |
     +-------------------------> + ---------------------> |
     |         wait...           |                        |
     |          exit             |                        |
     +-------------------------> |                        |
     |                           |                        |
    die                          |                        |
                                 |                        |
                                 |                        |
```

### 主进程
主要处理以下逻辑：
- 创建一个HTTP服务器并监听3000端口
- 管理子进程
    - 根据系统CPU数开启多个子进程
    - 通过子进程对象的send方法发送消息到子进程进行通信
    - 在主进程中监听了子进程的变化，如果是自杀信号则重启
    - 主进程在监听到退出消息的时候，先退出子进程再退出主进程

```javascript
// master.js
const child_process = require('child_process');
const fork = child_process.fork;
const cpus = require('os').cpus();

const server = require('net').createServer();
server.listen(3000);
process.title = 'node-master';

const workers = {};

//创建工作进程
function createWorker(){
    const worker = for('worker.js');
    worker.on('message',function(message){
        //如果是自杀信号，则重启
        if(message.act === 'suicide'){
            createWorker();
        }
    });
    worker.on('exit',function(code,signal){
        console.log('worker process exited, code: %s signal: %s', code, signal);
        delete workers[worker.pid];
    });
    worker.send('server',server);
    workers[worker.pid] = worker;
    console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid);
}

//根据cpu数创建工作进程
for( let i = 0;i < cpus.length;i++){
    createWorker();
}

function close(code){
    console.log('进程退出！',code);
    if(code !== 0){
        for(let pid in workers){
            workers[pid].kill('SIGINT');
        }
    }
    process.exit(0);
}


//当前主进程收到Ctrl-C的信号，先关闭工作进程
process.once('SIGINT', close.bind(this,'SIGINT'));
//当前主进程收到Ctrl-\的信号，先关闭工作进程
process.once('SIGQUIT',close.bind(this,'SIGQUIT'));
process.once('SIGTERM',close.bind(this,'SIGTERM'));
process.once('exit',close.bind(this));

```

### 工作进程

工作进程的处理逻辑：
- 创建一个server对象，这里最开始并没有监听端口
- 通过message事件接收主进程send方法发送的消息
- 监听uncaughtException事件，捕获未处理的异常，发送自杀信息由追进程重建进程，子进程在链接关闭之后推出。

```javascript
const http = require('http');
const server = http.createServer((req,res)=>{
    res.writeHead(200,{
        'Content-Type':'text/plain'
    });
    res.end(`pid:${process.pid},ppid:${process.ppid}`);
    //测试异常进程退出、重建
    throw new Error('worker process exception');
})

let worker;
process.title = 'node-worker';
process.on('message',function(message,sendHandle){
    if(message === 'server'){
        worker = sendHandle;
        worker.on('connection',function(socket){
            server.emit('connection',socket);
        })
    }
});

process.on('uncaughtException',function(err){
    console.log(err);
    process.send({act:'suicide'});
    worker.close(function(){
        process.exit(1);
    })
})

```
以上例子简单的介绍了多进程创建，异常监听，重启等。但是做为企业级应用程序我们开需要考虑的更完善，例如：进程的重启次数限制、与守护进程结合、多进程模式下定时任务处理等。

### 使用集群cluster
> 单个Node实例在单线程环境下运行，为了更好的利用多核环境，用户有时希望启动一批Node进程用于加载。 集群化模块使得你很方便地创建子进程，以便于在服务端口之间共享。

简单地说，cluster能够：
- 在服务器上同时启动多个进程
- 每个进程里跑的都是同一份源代码，好比把以前一个进程的工作分给多个进程去做
- 这些进程还可以同时监听一个端口

其中：
- 负责启动其他进程的叫做Master进程，他好比是个包工头，不做具体的工作，只负责启动其他进程。
- 其他被启动的叫Worker进程，就是干活的工人。它们接收请求，对外提供服务。
- Worker进程的数量一般根据服务器的CPU核数来定，这样就可以完美利用多核资源。

```javascript
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if(cluster.isMaster){
    //主进程，负责启动其他进程
    for(let i = 0 ;i < numCPUs;i++){
        cluster.fork();
    }
    cluster.on('exit',function(worker,code,signal){
        console.log(`worker ${worker.process.pid} died`);
    });
}else{
    //workers 能够分享TCP连接
    //在这个例子中是HTTP server
    http.createServer(function(req,res){
        res.writeHead(200);
        res.end('hello world');
    }).listen(8000);
}

```

### 守护进程
>守护进程运行在后台不受中断的影响，正常情况下，当我们打开中断执行**node app.js**的时候，会开启一个服务进程，这个端口就会被一直占用，如果关掉终端，服务就会中断，这种模式称为**前台运行模式**。而守护进程运行的方式，可以在后台一直运行。

**Agent机制**：  
我们发现有些工作其实不需要每个Worker都去做，如果都做，一来是浪费资源，更重要的是可能会导致多进程间资源访问冲突。  

举个例子：生产环境的日志文件我们一般会按照日期进行归档  
1. 每天凌晨0点，将当前日志文件按照日期进行重命名
2. 销毁以前的文件句柄，并创建新的日志文件继续写入

如果是4个进程来做同样的事情，是不是就会乱套了？所以，对于这一类后台运行的逻辑，我们希望将它们放到一个单独的进程上去执行，这个进程就叫做Agent Worker(守护进程),简称Agent。Agent好比是Master给其他Worker请的一个秘书，它不对外提供服务，只给App Worker打工，专门处理一些公共事务。

现在我们的多进程模型就变成如下：
```
                +--------+          +-------+
                | Master |<-------->| Agent |
                +--------+          +-------+
                ^   ^    ^
               /    |     \
             /      |       \
           /        |         \
         v          v          v
+----------+   +----------+   +----------+
| Worker 1 |   | Worker 2 |   | Worker 3 |
+----------+   +----------+   +----------+
```
框架的启动时序如下：
```
+---------+           +---------+          +---------+
|  Master |           |  Agent  |          |  Worker |
+---------+           +----+----+          +----+----+
     |      fork agent     |                    |
     +-------------------->|                    |
     |      agent ready    |                    |
     |<--------------------+                    |
     |                     |     fork worker    |
     +----------------------------------------->|
     |     worker ready    |                    |
     |<-----------------------------------------+
     |      Egg ready      |                    |
     +-------------------->|                    |
     |      Egg ready      |                    |
     +----------------------------------------->|
```
1. Master启动后先fork Agent进程
2. Agent初始化成功后，通过IPC通道通知Master
3. Master再fork多个App Worker
4. App Worker初始化成功，通知Master
5. 所有的进程初始化成功后，Master通知Agent和Worker应用启动成功

关于Agent Worker还有几点需要注意：
1. 由于App Worker依赖于Agent,所以必须等Agent初始化完成后才能fork App Worker
2. Agent虽然是App Worker的秘书，但是业务相关的工作不应该放到Agent上去做，不然把Agent累垮了就不好了
3. 由于Agent的特殊定位，我们应该保证它相对稳定。当它发生未捕获异常，框架不会像App Worker一样让他退出重启，而是记录异常日志、报警灯人工处理

使用Node编写守护进程：
1. 创建守护进程，通过spawn方法，设置options.detached为true，可以使子进程在父进程退出后继续运行（系统层会调用setsid方法）
2. 改变守护进程的工作目录，设置options.cwd
3. 主进程终止
```javascript
//master.js
const spawn = requre('child_process').spawn;

function startDaemon(){
    //创建守护进程，改变其工作目录
    const agent = spawn('node',['agent.js'],{
        cwd:'/usr',
        detached:true,
        stdio:'ignore'
    });
    console.log('守护进程开启，父进程pid%s,守护进程pid:%s',process.pid,agent.pid);
    //主进程终止
    agent.unref();
}
startDaemon();
```
```javascript
//agent.js
const fs = require('fs');
const { Console } = require('console');

//创建两个输入流，一个为标准输出，一个是标准异常输出
const logger = new Console(fs.createWriteStream('./stdout.log'),fs.createWriteStream('./stderr.log'));

setInterval(function(){
    logger.log('agent pid:',process.pid,',ppid:',process.ppid);
},10000)

```
Egg的守护进程用法：  
在应用或者插件跟母下的agent.js中实现
```javascript
//agent.js
module.exports = agent => {
  // 在这里写你的初始化逻辑

  // 也可以通过 messenger 对象发送消息给 App Worker
  // 但需要等待 App Worker 启动成功后才能发送，不然很可能丢失
  agent.messenger.on('egg-ready',()=>{
      const data = { ... };
      agent.messenger.sendToApp('xxx_action',data);
  });
}
```
```javascript
//app.js
module.exports = app =>{
    app.messenger.on('xxx_action',data=>{
        //...
    })
}
```
agnet.js的代码会执行在agent进程上，app.js的代码会执行在Worker进程上，他们通过框架封装的messenger对象进行进程间通讯(IPC)。


### Master VS Agent VS Worker
当一个应用刚启动时，会同时启动这三类进程
|类型|进程数量|作用|稳定性|是否运行业务代码|
|---|---|---|---|---|
|Master|1||进程管理，进程间消息转发|非常高|否|
|Agent|1|后台运行工作(长连接客户端)|高|少量|
|Worker|一般设置为CPU核数|执行业务代码|一般|是|

**Master**:  
> 在这个模型下，Master进程承担了进程管理的工作（类似pm2），不运行任何业务代码。我们只需要运行起一个Master进程它就会帮我们搞定所有的Worker、Agent进程的初始化以及重启等工作了。Master进程的稳定性是极高的。

**Agent**:  
> 在大部分情况下，我们在写业务代码的时候，完全不用考虑Agent进程的存在，但是当我们遇到一些场景，指向让代码运行在一个进程上的时候，Agent进程就到了发挥作用的时候。
> 由于Agent进程只有一个，而且会负责许多维持连接的脏活累活，因此它不能轻易的挂掉和重启，所以Agent进程在监听到未捕获异常时，不会退出，但是会打印出错误日志，**我们需要对日志中未捕获异常提高警惕**

**Worker**:  
> Worker进程负责处理真正的用户请求和定时任务的处理。Egg中的定时任务也停工了只让一个Worker进程运行的能力，所以能够通过定时任务解决的问题就不要放到Agent上执行。Wokrer运行的是业务代码，相比会比Agent和Master进程上运行的代码复杂度更高，稳定性也低一点，当Worker进程异常退出时，Master进程会重启一个Worker进程。

### 进程间通讯（IPC）
虽然每个Worker进程是相对独立的，但是它们之间始终还是需要通讯的，叫进程间通讯(IPC)。

Node中Cluster进程间的通讯:
```javascript
const cluster = require('cluster');

if(cluster.isMaster){
    const worker = cluster.fork();
    worker.send('hi there');
    worker.on('mesaage',msg => {
        console.log(`msg:${msg} from worker ${worker.id}`);
    });
}else if (cluster.isWorker){
    process.on('message',(msg)=>{
        process.sned(msg);
    })
}

```
cluster的IPC通道只存在于Master和Worker/Agent之间，Worker和Agent进程互相间是没有的。那么如果Worker之间想要通讯该怎么办？通过Master来转发。
```
广播消息： agent => all workers
                  +--------+          +-------+
                  | Master |<---------| Agent |
                  +--------+          +-------+
                 /    |     \
                /     |      \
               /      |       \
              /       |        \
             v        v         v
  +----------+   +----------+   +----------+
  | Worker 1 |   | Worker 2 |   | Worker 3 |
  +----------+   +----------+   +----------+

指定接收方： one worker => another worker
                  +--------+          +-------+
                  | Master |----------| Agent |
                  +--------+          +-------+
                 ^    |
     send to    /     |
    worker 2   /      |
              /       |
             /        v
  +----------+   +----------+   +----------+
  | Worker 1 |   | Worker 2 |   | Worker 3 |
  +----------+   +----------+   +----------+
```

egg封装了一个messenger对象挂在app/agent实例上，提供了一系列友好的API：  
**发送**:  
- app.messenger.broadcast(action,data):发送给所有的agent/app进程(包括自己)
- app.messenger.sendToApp(action,data):发送给所有的app进程
    - 在app上调用改方法会发送给自己和其他的app进程
    - 在agent上调用改方法会发送给所有的app进程
- app.messenger.sendToAgent(action,data):发送给agent进程
    - 在app上调用该方法会发送给agent进程
    - 在agent上调用改方法会发送给自己
- agent.messenger.sendRandom(action,data)
    - app上没有此方法
    - agent会随机发送消息给一个app进程，由master来控制发给谁
- app.messenger.sendTo(pid,action,data)：发送给指定进程

```javascript
// app.js
module.exports = app => {
  // 注意，只有在 egg-ready 事件拿到之后才能发送消息
  app.messenger.once('egg-ready', () => {
    app.messenger.sendToAgent('agent-event', { foo: 'bar' });
    app.messenger.sendToApp('app-event', { foo: 'bar' });
  });
}
```
需要等 egg-ready 消息之后才能发送消息。只有在 Master 确认所有的 Agent 进程和 Worker 进程都已经成功启动（并 ready）之后，才会通过 messenger 发送 egg-ready 消息给所有的 Agent 和 Worker，告知一切准备就绪，IPC 通道可以开始使用了。

**接收**:
```javascript
app.messenger.on(action, data => {
  // process data
});
app.messenger.once(action, data => {
  // process data
});

```
### IPC实战
需求:我们有一个接口需要从远程数据源中读取一些数据，对外部提供 API，但是这个数据源的数据很少变化，因此我们希望将数据缓存到内存中以提升服务能力，降低 RT。此时就需要有一个更新内存缓存的机制。
1. 定时从远程数据源获取数据，更新内存缓存，为了降低对数据源压力，更新的间隔时间会设置的比较长。(force强制更新)
2. 远程数据源提供一个检查是否有数据更新的接口，我们的服务可以更频繁的调用检查接口，当有数据更新时才去重新拉取数据。(pull拉取更新)
3. 远程数据源通过消息中间件推送数据更新的消息，我们的服务监听消息来更新数据。(push推送更新)

在实际项目中，我们可以采用方案一用于兜底，结合方案三或者方案二的一种用于提升数据更新的实时性。而在这个示例中，我们会通过 IPC + 定时任务来同时实现这三种缓存更新方案。

实现：  
我们将所有的与远程数据源交互的逻辑封装在一个Service中，并提供get方法给Controller调用。

```javascript
// app/service/source.js
let memoryCache = {};

class SourceService extends Service {
  get(key) {
    return memoryCache[key];
  }

  async checkUpdate() {
    // check if remote data source has changed
    const updated = await mockCheck();
    this.ctx.logger.info('check update response %s', updated);
    return updated;
  }

  async update() {
    // update memory cache from remote
    memoryCache = await mockFetch();
    this.ctx.logger.info('update memory cache from remote: %j', memoryCache);
  }
}
```

编写定时任务，实现方案一，每十分钟定时从远程数据获取数据更新缓存做兜底（强制更新）
```javascript
// app/schedule/force_refresh.js
exports.schedule = {
  interval: '10m',
  type: 'all', // run in all workers
};

exports.task = async ctx => {
  await ctx.service.source.update();
  ctx.app.lastUpdateBy = 'force';
};

```
编写定时任务实现方案二的检查逻辑，每10s让一个worker调用检查接口，当数据有变化时，通过messenger提供的方法通知所有Worker
```javascript
// app/schedule/pull_refresh.js
exports.schedule = {
  interval: '10s',
  type: 'worker', // only run in one worker
};

exports.task = async ctx => {
  const needRefresh = await ctx.service.source.checkUpdate();
  if (!needRefresh) return;

  // notify all workers to update memory cache from `file`
  ctx.app.messenger.sendToApp('refresh', 'pull');
};

```
在app.js中监听refresh时间，并更新数据。
```javascript
// app.js
module.exports = app => {
  app.messenger.on('refresh', by => {
    app.logger.info('start update by %s', by);
    // create an anonymous context to access service
    const ctx = app.createAnonymousContext();
    ctx.runInBackground(async () => {
      await ctx.service.source.update();
      app.lastUpdateBy = by;
    });
  });
};
```
现在我们来看看如何实现第三个方案。我们需要有一个消息中间件的客户端，它会和服务端保持长连接，这一类的长连接维持比较适合在 Agent 进程上做，可以有效降低连接数，减少两端的消耗。所以我们在 Agent 进程上来开启消息监听。
```javascript
// agent.js

const Subscriber = require('./lib/subscriber');

module.exports = agent => {
  const subscriber = new Subscriber();
  // listen changed event, broadcast to all workers
  subscriber.on('changed', () => agent.messenger.sendToApp('refresh', 'push'));
};

```

## Node进程常见问题
### 进程和线程的区别
- 进程：系统进行资源分配和调度的基本单位,进程之间相互独立，通讯需要通过IPC,进程之间关注的是通信问题。
- 线程：系统进行运算调度的最小单位，线程属于进程，线程之间共享进程资源，线程间关注的是安全问题。

### 什么是孤儿进程
父进程创建子进程之后，父进程退出了，但是父进程对应的一个或者多个子进程还在运行，这些子进程会被系统的init进程手痒，对应的进程ppid为1，这就是孤儿进程。
```javascript
// master.js
const fork = require('child_process').fork;
const server = require('net').createServer();
server.listen(3000);
const worker = fork('worker.js');

worker.send('server', server);
console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid);
process.exit(0); // 创建子进程之后，主进程退出，此时创建的 worker 进程会成为孤儿进程

```
```javascript
// worker.js
const http = require('http');
const server = http.createServer((req, res) => {
    res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid); // 记录当前工作进程 pid 及父进程 ppid
});

let worker;
process.on('message', function (message, sendHandle) {
    if (message === 'server') {
        worker = sendHandle;
        worker.on('connection', function(socket) {
            server.emit('connection', socket);
        });
    }
});

```

### 多进程如何同时监听一个端口
先看下端口被占用的情况:
```javascript
// master.js
const child_process = require('child_process');
const fork = child_process.fork;
const cpus = require('os').cpus();

for(let i = 0;i<cpus.length;i++){
    const worker = fork('./worker.js');
}
```

```javascript
//worker.js
const http = require('http');
http.createServer((req,res)=>{
    res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid);
}).listen(3000);

```
以上代码示例，控制台执行 node master.js 只有一个 worker 可以监听到 3000 端口，其余将会抛出 **Error: listen EADDRINUSE :::3000** 错误

**多进程模式下怎么实现多端口监听呢？**
- 通过传递句柄，子进程对象的send方法发送消息，第二个参数sendHandle就是句柄，可以是TCP套接字、TCP服务器、UDP套接字等。
```javascript
childProcess.send(message,sendHandle)
```
为了解决上面多进程端口占用问题，我们将主进程的socket传递到子进程:
```javascript
//master.js
const fork = require('child_process').fork;
const cpus = require('os').cpus();
const server = require('net').createServer();
server.listen(3000);
process.title = 'node-master';

for(let i = 0;i< cpus.length; i++){
    const worker = fork('worker.js');
    worker.send('server',server);
    if(i + 1 === cpus.length){
        console.log('server close');
        //关闭服务器监听，交由子进程处理
        server.close();
    }
}
```
```javascript
//worker.js
const http = require('http');
const server = http.createServer((req,res)=>{
    res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid);
});

let masterServer;
process.title= 'node-worker';
process.on('message',function(message,sendHandle){
    if(message === 'server'){
        masterServer = sendHandler;
        //将主进程的socket传递到子进程，类似于转发？
        masterServer.on('connection',function(socket){
            server.emit('connection',socket);
        })
    }
})

```
### IPC通信
什么是IPC通信，如何建立IPC通信？

IPC（inter-process communication），即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现IPC的目的就是为了进程之间资源共享访问，实现IPC的方式有多种：管道、消息队列、信号量、Domain Socket。Node通过pipe来实现。

未使用IPC的情况下，工作进程没办法打印日志：
```javascript
//master.js
const spawn = require('child_process').spawn;
const child = spawn('node',['worker.js']);
console.log(process.pid,child.pid);
//worker.js
//不会被打印
console.log('I am worker,PID:',process.id);
```
worker进程内的信息并没有在控制台打印，原因是新创建的子进程有自己的stdio流。

创建一个父进程和子进程之间传递消息的IPC通道实现输出信息

```javascript
// master.js
const spawn = require('child_process').spawn;
const child = spawn('node',['worker.js']);
child.stdout.pipe(process.stdout);
console.log(process.pid,child.pid);
```

### IPC通信原理
- 主进程创建IPC通道并监听
- 创建子进程
- 主进程通过环境变量(NODE_CHANNEL_FD)的方式将IPC通道的文件描述符传递给子进程。
- 子进程根据文件描述符去链接IPC通道

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gek89l07u1j30cb07r0sz.jpg)

### Node是多线程还是单线程
Node是多线程还是单线程，为什么JS是单线程

**我们常说的多线程和单线程，是指我们在写代码的时候，所关注的主线程是单线程的。但不代表代码运行过程是单线程的，例如JS在执行setTimeout的时候，会通过计时器线程来计时后，推入事件触发线程的宏任务队列，等待主线程空闲时，再从宏任务队列中取出执行。所以我们往往说JS是单线程的**

**Node12以前没有模块能够开启多线程，12及之后，Node可以通过worker-threads开启真的多线程**

为什么JS要是单线程的？  
这主要关于到DOM的操作，如果多个线程来对同一个DOM操作，会造成混乱。也就意味着DOM操作只能是单线程的，避免DOM渲染冲突。在浏览器环境中渲染线程和JS主线程是互斥的，乙方在执行时都会导致另一方被挂起。