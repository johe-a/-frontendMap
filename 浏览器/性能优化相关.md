# 前言
性能优化的角度有很多，有从编码角度，有从编译角度，有从网络和缓存角度来进行优化，众所纷纭，但没有系统化的知识体系。

为了更加系统化的学习性能优化，不是为了优化而优化，而是为了知道为什么这样做可以优化的目的以及造成性能的瓶颈，再去了解优化的手段。我选择从浏览器加载文档的角度切入，从各阶段讲一下优化的可能

# 浏览器加载文档的过程
>输入URL，浏览器主进程接管，开启一个下载线程，进行HTTP请求，将响应内容转发给渲染进程。

![输入URL的浏览器行为](https://tva1.sinaimg.cn/large/006tNbRwgy1gbfry9pv9lj31cw0tiwr9.jpg)

整个过程被分为9个小块： 
- 提示卸载旧文档 
- 重定向/卸载旧文档 
- 应用缓存 
- DNS域名解析 
- TCP握手 
- HTTP请求处理 
- HTTP响应处理 
- 文档处理(关键渲染路径) 
- 文档装载完成

# 重定向文档
雅虎军规里面有一条Avoid Redirects，意味着避免重定向。这是由于重定向在完成之前，浏览器没有任何东西可以下载和渲染。

http头部状态码中的301和302用来控制重定向，301为永久重定向、302为临时重定向。301永久重定向可以被缓存，而302临时重定向默认不缓存。在必须重定向的情况下，优先选择301永久重定向，因为有缓存。但也要考虑实际情况，类似于多平台的单点登录，是必须要用302临时重定向的。

最浪费的跳转出现在url尾部的/缺失。例如www.yahoo.com/astrology会301跳转到www.yahoo.com/astrology/

# 应用缓存
浏览器会根据http的响应头部来决定资源是否被缓存，缓存分为强缓存和协商缓存。合理应用缓存可以省去加载资源的等待。

- 强缓存：响应头部Cache-Control或者Expires(优先级较低)字段来决定,一旦启用，只要过期时间没有过，不请求后台，直接从浏览器缓存内取(分为磁盘缓存和内存缓存)  
- 协商缓存：响应头部
```
//设置强缓存过期时间
Cache-Control: max-age=3600
//取消强缓存但每次都要协商缓存，对于一些需要保证是最新的资源可用，例如Index.html
Cache-Control: no-cache
//取消所有缓存，每次从后台获取，不建议
Cache-Control: no-store
```
- 对于静态资源，例如字体、图片、js，我们可以合理应用强缓存。但对于这些静态资源，如果发生了改变，我们需要修改文件名(通过添加版本号)
- 对于动态资源，例如index.html（永远要保持最新的），合理使用Cache-Control，根据场景决定使用强缓存还是协商缓存。

# DNS域名解析
减少DNS查询，在浏览器输入URL后，通过DNS(域名解析系统)查询得到网站真实IP。 DNS是有成本的，它需要20到120毫秒去查找给定域名的IP地址。在DNS完成之前，浏览器依旧无法从主机下载任何东西。

一般来说，DNS查询存在浏览器缓存、系统缓存(本地hosts文件)。**如果客户端的DNS缓存是空的，DNS查找数就等同于页面上资源引用的不同主机名数，包括页面URL、图片、脚本文件、样式表等等，减少不同的主机名就可以减少DNS查找。（也就是不同的资源尽量请求的是同一域名下的资源）**


# TCP握手与HTTP请求
在发送HTTP报文之前，需要建立TCP三次握手。

在HTTP1.0的时代，每次发生HTTP请求都要重新建立TCP三次握手(现在应该没人用了吧？)，在HTTP1.1的时代，增加了keep-alive，意味着TCP的连接能够复用，发送多次HTTP请求的时候，可以不用重复建立TCP连接。但仍然存在队头阻塞问题(即使客户端在一个TCP连接并行发送了多个HTTP请求，服务端仍然按照请求的顺序来进行响应，这是由于HTTP基于文本传输，接收端在响应返回时无法区分请求对应的响应)

**由于目前大范围使用的是HTTP/1.1的协议版本，所以我们主要解决队头阻塞问题，为了减少队头阻塞的发生情况，需要我们减少HTTP请求(主要指的同一时间段内)、尽量减少每次请求的大小**
- css雪碧图
- 小文件合并成大文件请求(需要权衡，一旦大文件加载不成功影响到渲染，会影响用户体验)
- 行内图片,将图片编码成为base64格式，嵌入到页面中。
- 合理应用缓存
- 抽取公共代码，减少重复代码
- 按需加载/懒加载，而不是一次性加载所有资源
- 合理进行并行请求(针对域名，每个浏览器对不同域名有4-6个的TCP连接限制,虽然能缓解队头阻塞问题，但会提高耗时)
- cookie合理配置，每一次的http请求都会携带cookie，要合理设置cookie的作用域、尽量压缩、静态资源不传递cookie等
- 压缩请求体和响应体，一般采用Gzip压缩法
- 使用Preload和Prefetch，Preload帮助我们提高对渲染有影响的必要资源加载优先级，Prefetch用于页面中未来可能使用的资源的预加载(不阻塞，加载资源的时间由浏览器决定，一般是网络空闲时)。例如<link rel='prefetch'>其原理是提高该资源在浏览器加载的优先级。
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggl7v87nrej31ch0u0qc1.jpg)

实际上，浏览器是可以支持4-6个的并行HTTP请求的(针对单个域名,这也是为什么有一些站点将资源放到多个域名的原因之一)，但这些并行请求是新建TCP连接而完成的，在一定程度上可以缓解某个资源加载阻塞带来的队头阻塞影响后续资源加载。  
但是重复建立TCP连接需要耗时，并且TCP的拥塞控制是慢启动的(发送速度慢慢提升，还受到服务器的滑动窗口影响)，也就是发送速度在一个TCP连接内是由慢到快的，所以比起合并资源用一个TCP连接速度是较慢的。

注意保持在2-4个域名内，以避免DNS查询损耗。例如，动态内容放在csspod.com上，静态资源放在static.csspod.com上。这样还可以禁用静态资源域下的Cookie，减少数据传输。

那么当所需加载的资源数量到达多少或资源大小小于多少，我们才可以自信地宣称我们的 Web 应用拥有出色的性能呢？
1. 页面初载时，所有未压缩的js大小<=200KB
2. 页面初载时，所有未压缩的css资源大小:<=100KB
3. HTTP/1.1，请求资源数<=6个
4. HTTP/2协议下，请求资源数<=20个
5. 90%的代码利用率

**如何查看代码利用率？代码利用率=页面中实际被执行的代码/页面中引入的代码*100%,通过谷歌调试工具按下Cmd+Shift+P搜索Coverage，然后点击reload:**
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggl7sepbsjj30id0rvjx1.jpg)


**减少HTTP请求实际上治标不治本，没解决本质问题，为了从本质上解决问题，HTTP/2.0采用了多路复用,在一个TCP连接上采用双工流，基于二进制分帧传输，客户端可以并行发起请求，服务端根据实际情况来决定响应，从根本上解决队头阻塞问题。这是由于二进制分帧的每一个帧，能够识别出自己属于哪个流，客户端收到响应时，能够区分响应对应的请求**



# HTTP响应
HTTP的响应速度是有可能提升的，主要依靠CDN(内容分发网络)，CDN能够加速HTTP请求和响应的速度。

CDN主要从以下方式提高请求响应速度：
- 跨地域，从最近的地域节点请求
- 负载均衡，从最空闲的机器请求(这一点Nginx也可以做到)
- 跨运营商，电信用户不会请求到移动的服务器，请求到电信的服务器

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggdxqeiwvhj30go09kq3f.jpg)


# 文档处理(关键渲染路径)
减少重定向、合理利用缓存、减少DNS查询、减少HTTP请求、加快HTTP响应等都是为了文档都够更快的返回到客户端。而文档处理则涉及到了如何更快的渲染出网页、提升网页流畅性、降低网页占用的内存等等与用户体验直接相关的东西，这是我们在编程中需要考虑的。

了解浏览器如何进行文档处理，从了解关键渲染路径开始：

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggfc293m16j30kv08cq3l.jpg)

- 处理HTML/CSS，构建DOM/CSSOM(对象模型)
- 构建render tree渲染树(DOM与CSSOM合并)
- 布局(Layout，根据渲染树来布局)
- 绘制(Paint, 将各节点绘制到屏幕上)

实际浏览器渲染：(cmd+shift+i打开开发者工具点击performance后打开左上角录制后查看）

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggfc59olpnj30zk0av0va.jpg)

**在加载JS的时候，实际上是会阻塞DOM的构建的，因为JS有可能会操作DOM。并且加载CSS也会阻塞JS的加载，因为JS会可能会查询或操作CSSOM：**

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggfcc48wh5j30rs08zq3r.jpg)

从上图我们可以得到一个明确的结论，为了不阻塞渲染：
- 对于页面所需的CSS需要尽早加载，能压缩进行压缩，能合并进行合并，放在头部。
- 操作DOM的JS尽量放在后面加载，或者使用defer和async,或者使用动态导入

关于defer与async以及不用属性时的差别：

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggfci2z6oej30k203daag.jpg)

当文档遇到script标签时：
- 不用属性，请求过程、请求完毕后立即执行，都会阻塞DOM的构建。
- 用defer，请求过程不阻塞、请求完毕后立即执行，阻塞DOM构建。
- 用async，请求过程不阻塞、请求完毕不会立即执行，会等DOM构建完毕执行。

一般async和defer同时使用，是因为async的兼容性要求比defer要高。

## 了解回流与重绘
网页在生成的过程中，至少会渲染一次，在访问的过程中，还会不断的重新渲染。

重新渲染，就可能会重新布局和重新绘制。
- 回流：意味着重新布局和重新绘制，代价更高
- 重绘：意味着重新绘制

CSS和JS都会引起回流和重绘，这是无法避免的，但是我们可以选择：
- 减少回流与重绘
- 能用重绘替代回流的地方使用重绘

为什么说JS操作DOM的代价是很高的？因为随时有可能引起回流和重绘，现代框架都在为了减少操作DOM而做努力，例如Vue、React。

Vue、React是怎么从本质上减少DOM操作的？
- 通过构建虚拟DOM树，不直接操作DOM
- 通过diff算法优化，得到可以复用的VNode，进行局部渲染
- 通过宏任务、微任务，将一个事件循环内的DOM操作汇总到一起执行，减少操作DOM的次数

减少重绘与回流的九个编程技巧:
```
1. DOM的多个读操作，应该汇总到一起，而不是在两个读操作之间插入一个写操作。

2. 如果某个样式是通过回流得到的，最好缓存结果，避免下次用到的时候，又导致回流。

3. 不要一条条的改变样式，通过修改classList或者使用csstext

// bad
var left = 10;
var top = 10;
el.style.left = left + "px";
el.style.top  = top  + "px";
// good 
el.className += " theclassname";
// good
el.style.cssText += "; left: " + left + "px; top: " + top + "px;";

4.尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式，比如操作Document Fragment对象，完成后再把这个对象加入DOM。再比如使用cloneNode()方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。(Vue用到了Fragment)

5. 先将元素设为dispaly:none(需要一次重排和重绘)，然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘)。这样一来，就用两次重新渲染，取代了可能高达100次的重新渲染。

6. position属性为absolute或者fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响

7. 只在必要的时候，才将元素的dispaly属性为可见，因为不可见的元素不影响重排和重绘，另外visibility:hidden的元素只对重绘有影响，不影响重排。

8. 使用虚拟DOM的脚本库，例如vue、react

9. 使用window.requestAnimationFrame()用于下一次重绘之前更新动画帧调用函数、window.requestIdleCallback() 这两个方法调节重新渲染

```

# 从CPU、内存、本地资源占用来看优化
由于用户的机器性能因人而异，我们在使用开发机器进行模拟时，可能网页不会卡顿，但对于CPU性能较差、内存较小、磁盘空间不足的机器来说，可能会直接导致网页崩溃。

- 避免需要消耗大量CPU的计算，将这些计算放到后台，由后台计算后返回。
- 避免内存泄漏，及时释放内存，例如大对象的引用、监听器的删除、计时器的清除等。或者只加载有用的DOM，例如无限列表的优化，只渲染可视窗口。
- 对于持久化缓存storage和IndexDB要看情况使用，避免占用磁盘空间过大

# 从Vue编程角度来看优化
在编程过程中，我们可能会遇到DOM的构建、回流重绘、资源负荷等问题

## 从渲染角度
### v-if和v-show区分使用场景
由于v-if是**真正的条件渲染，它会确保再切换过程中对条件块内的事件监听器和子组件适当的销毁和重建**。并且是惰性的，如果在初始渲染条件为假时，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块。

v-show不管初始条件是什么，元素都会被渲染，只是对display属性进行切换。

**所以v-if适用于运行时很少改变条件，不需要频繁切换条件的场景，v-show适用于需要非常频繁切换的场景**

### v-for遍历添加key(提高DOM的复用)
这是由于vue在对子元素进行diff算法时，每一轮循环会先对新旧子节点的首尾节点进行两两对比，如果对不不成功(sameVNode)，则会根据旧的子节点的key生成key-VNode的map结构，然后用新的开始节点的key去获取对应的旧节点，如果没有key，则会找不到旧的节点，此时新的开始节点会被直接插入，即使在旧的节点中存在节点可以复用。  
例如旧的子节点为A、B、C、D、E，去掉头尾变成B、C、D，在每一轮进行首尾节点两两对比都会不成功，如果没有key，新的B、C、D都会直接插入到A之前，旧的A、B、C、D、E则会被全部删除，B、C、D旧节点得不到复用

### v-for不于v-if使用，用computed属性替代
这是由于v-for的优先级比v-if更高，相当于如下代码:
```javascript
<div v-for="user in users" v-if="user.active">
</div>

this.users.map((user)=>{
    if(user.active){
        return user;
    }
});
```

因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。
1. 渲染时会遍历所有用户，渲染低效
2. 每次都遍历整个列表，不管user是否发生改变

使用computed属性替代：
```javascript
<div v-for="user in computedUsers">
</div>

export default{
    computed:{
        computedUsers(){
            return this.users.filter((user)=>user.active)
        }
    }
}
```
1. 渲染时只遍历活跃用户，更高效
2. 计算属性会有缓存，不会重复计算，只有users改变时会重新计算

### v-if/v-else 使用key
Vue会尽可能的更新DOM。这就意味着在相同类型的元素之间切换时，会修补已经存在的元素，而不是移除后添加一个新的元素。

## 从资源负荷角度
### 区分响应式数据和非响应式数据
响应式数据的成本是很高的，需要为每一个对象、数组生成Obeserver类，在一些不需要响应式的数据场景下，会造成很大的资源浪费，例如长列表，对于长列表只是纯展示的作用，一般不需要响应式。那么如何添加一个非响应式数据到data中呢？
- 在created阶段赋值到this,这是因为created阶段已经完成了data的响应式初始化。
- 在赋值时，对数据进行冻结，使用Object.freeze()递归冻结，这可以使得属性的configurable为false,一旦configurable为false,就无法通过Object.defineProperty对数据进行响应式。

### 事件的销毁
Vue组件销毁时，会接触组件的指令和事件监听器，但是仅限于组件本身的事件。或者是使用keep-alive组件的情况下，实际上watch内的监听时不会销毁的，这时候即使组件失活，也有可能会引起失活组件watch的执行，例如watch的是'$route'。  

所以，有两种情况下的事件监听我们需要手动销毁：
- 使用keep-alive的情况下，手动销毁失活组件的watch(主要针对路由的监听)
- 在js中使用addEventListener的地方，不管有没有使用keep-alive都要手动销毁

一般监听和销毁监听的时机不同，会在不同的生命周期内，为了提高聚合，我们可以使用Vue的Hook
```javascript
created(){
    //监听与销毁
    window.addEventListener('click',this.click);
    this.$once('hook:beforeDestroy',()=>{
        window.removeEventListener('click',this.click);
    })
},
activated(){
    const unwatch = this.$watch('$route.query',this.fetch,{
        deep:true
    });
    this.$once('hook:deactivated',()=>{
        unwatch();
    })
}
```
### 图片资源懒加载(网络资源阻塞)
为了加速页面的加载速度，对于图片过多的页面，我们会将可视区域的图片先加载，未出现在可视区域内的图片先不加载，等到图片到达可视区域后再加载(未加载的图片使用统一的loading图片或者默认图片)。  
一方面是为了防止HTTP单位时间内加载过多资源引起队头阻塞，一方面是为了让用户能够更快的看到可视区域的资源。

Vue中有成熟的vue-lazyload插件可以使用：
```html
<img v-lazy="1.png">
```
其原理是通过注册自定义指令，监听元素父容器的scroll事件。判断元素是否在可视区域内，对元素的src属性进行替换。

### 需要消耗大量资源的图表懒加载
对于一些可视化数据，可能在一个看板内会存在多个图表，一方面这些图表数据量的大小不一致会对内存造成压力，一方面这些图表的绘制和计算需要消耗大量的CPU。
- 对于消耗大量CPU计算的，我们应该进行懒加载，对于可视区域内的图表进行懒加载，其原理也是监听图表是否在可视区域内。
- 对于需要消耗大量内存的图表，考虑只加载首页或一定时间段范围的数据，后续数据从后台拉取，或提供用户下载。

### 路由懒加载
Vue是单页应用，可能会有很多的路由引入，如果这些路由的组件都同步导入，会使webpack打包后的文件很大，当进入首页时，加载资源过多，会出现白屏的情况，不利于用户体验。  

我们可以通过把不同路由对应的组件分割成不同的代码块(需要动态import语法以及webpack代码分割的功能)，然后路由被访问时才加载对应的组件。

```javascript
const router = new VueRouter({
    routes:[
        path:'foo',
        component:()=>import('Foo.vue')
    ]
})

```

### 第三方插件按需引入
我们在项目中经常会使用到第三方插件，例如elementUI，如果整体导入，有些组件我们是不需要使用的，会导致项目体积太大，我们可以借助babel-plugin-component，然后只按需引入需要的组件。


## 无限列表的优化
如果应用中存在非常长的列表或者无限滚动的情况。那么需要采用窗口化的技术来优化性能，只渲染少部分区域的内容，减少重新渲染组件和创建dom节点的事件。例如vue-virtual-scroll-list或者vue-virtual-scroller。原理是通过scroll事件监听或者IntersectionObserver API实现的。

# 从构建角度看待性能优化